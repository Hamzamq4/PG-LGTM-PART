{"$schema":"https://json.schemastore.org/sarif-2.1.0.json","version":"2.1.0","runs":[{"tool":{"driver":{"name":"CodeQL","organization":"GitHub","semanticVersion":"2.20.4","notifications":[{"id":"cli/expected-extracted-files/python","name":"cli/expected-extracted-files/python","shortDescription":{"text":"Expected extracted files"},"fullDescription":{"text":"Files appearing in the source archive that are expected to be extracted."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["expected-extracted-files","telemetry"],"languageDisplayName":"Python"}},{"id":"cli/expected-extracted-files/java","name":"cli/expected-extracted-files/java","shortDescription":{"text":"Expected extracted files"},"fullDescription":{"text":"Files appearing in the source archive that are expected to be extracted."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["expected-extracted-files","telemetry"],"languageDisplayName":"Java"}},{"id":"cli/expected-extracted-files/c","name":"cli/expected-extracted-files/c","shortDescription":{"text":"Expected extracted files"},"fullDescription":{"text":"Files appearing in the source archive that are expected to be extracted."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["expected-extracted-files","telemetry"],"languageDisplayName":"C"}},{"id":"cli/build-mode","name":"cli/build-mode","shortDescription":{"text":"A build mode was specified"},"fullDescription":{"text":"A build mode was specified"},"defaultConfiguration":{"enabled":true}},{"id":"codeql-action/bundle-download-telemetry","name":"codeql-action/bundle-download-telemetry","shortDescription":{"text":"CodeQL bundle download telemetry"},"fullDescription":{"text":"CodeQL bundle download telemetry"},"defaultConfiguration":{"enabled":true}}],"rules":[]},"extensions":[{"name":"codeql/java-queries","semanticVersion":"1.1.13+c524a98eb91c769cb2994b8373181c2ebd27c20f","notifications":[{"id":"java/diagnostic/database-quality","name":"java/diagnostic/database-quality","shortDescription":{"text":"Low Java analysis quality"},"fullDescription":{"text":"Low Java analysis quality"},"defaultConfiguration":{"enabled":true},"properties":{"description":"Low Java analysis quality","id":"java/diagnostic/database-quality","kind":"diagnostic","name":"Low Java analysis quality"}},{"id":"java/diagnostics/successfully-extracted-files","name":"java/diagnostics/successfully-extracted-files","shortDescription":{"text":"Extracted files"},"fullDescription":{"text":"A list of all files in the source code directory that were extracted."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["successfully-extracted-files"],"description":"A list of all files in the source code directory that\n              were extracted.","id":"java/diagnostics/successfully-extracted-files","kind":"diagnostic","name":"Extracted files"}},{"id":"java/diagnostics/extraction-errors","name":"java/diagnostics/extraction-errors","shortDescription":{"text":"Extraction errors"},"fullDescription":{"text":"A list of extraction errors for files in the source code directory."},"defaultConfiguration":{"enabled":true},"properties":{"description":"A list of extraction errors for files in the source code directory.","id":"java/diagnostics/extraction-errors","kind":"diagnostic","name":"Extraction errors"}},{"id":"java/diagnostics/extraction-warnings","name":"java/diagnostics/extraction-warnings","shortDescription":{"text":"Extraction warnings"},"fullDescription":{"text":"A list of extraction warnings for files in the source code directory."},"defaultConfiguration":{"enabled":true},"properties":{"description":"A list of extraction warnings for files in the source code directory.","id":"java/diagnostics/extraction-warnings","kind":"diagnostic","name":"Extraction warnings"}}],"rules":[{"id":"java/non-final-call-in-constructor","name":"java/non-final-call-in-constructor","shortDescription":{"text":"Non-final method invocation in constructor"},"fullDescription":{"text":"If a constructor calls a method that is overridden in a subclass, the result can be unpredictable."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Non-final method invocation in constructor\nIf a constructor calls a method that is overridden in a subclass, it can cause the overriding method in the subclass to be called before the subclass has been initialized. This can lead to unexpected results.\n\n\n## Recommendation\nDo not call a non-final method from within a constructor if that method could be overridden in a subclass.\n\n\n## Example\nIn the following example, executing `new Sub(\"test\")` results in a `NullPointerException`. This is because the subclass constructor implicitly calls the superclass constructor, which in turn calls the overridden `init` method before the field `s` is initialized in the subclass constructor.\n\n\n```java\npublic class Super {\n\tpublic Super() {\n\t\tinit();\n\t}\n\t\n\tpublic void init() {\n\t}\n}\n\npublic class Sub extends Super {\n\tString s;\n\tint length;\n\n\tpublic Sub(String s) {\n\t\tthis.s = s==null ? \"\" : s;\n\t}\n\t\n\t@Override\n\tpublic void init() {\n\t\tlength = s.length();\n\t}\n}\n```\nTo avoid this problem:\n\n* The `init` method in the super constructor should be made `final` or `private`.\n* The initialization that is performed in the overridden `init` method in the subclass can be moved to the subclass constructor itself, or delegated to a separate final or private method that is called from within the subclass constructor.\n\n## References\n* J. Bloch, *Effective Java (second edition)*, pp. 89&ndash;90. Addison-Wesley, 2008.\n* The Java Tutorials: [Writing Final Classes and Methods](https://docs.oracle.com/javase/tutorial/java/IandI/final.html).\n","markdown":"# Non-final method invocation in constructor\nIf a constructor calls a method that is overridden in a subclass, it can cause the overriding method in the subclass to be called before the subclass has been initialized. This can lead to unexpected results.\n\n\n## Recommendation\nDo not call a non-final method from within a constructor if that method could be overridden in a subclass.\n\n\n## Example\nIn the following example, executing `new Sub(\"test\")` results in a `NullPointerException`. This is because the subclass constructor implicitly calls the superclass constructor, which in turn calls the overridden `init` method before the field `s` is initialized in the subclass constructor.\n\n\n```java\npublic class Super {\n\tpublic Super() {\n\t\tinit();\n\t}\n\t\n\tpublic void init() {\n\t}\n}\n\npublic class Sub extends Super {\n\tString s;\n\tint length;\n\n\tpublic Sub(String s) {\n\t\tthis.s = s==null ? \"\" : s;\n\t}\n\t\n\t@Override\n\tpublic void init() {\n\t\tlength = s.length();\n\t}\n}\n```\nTo avoid this problem:\n\n* The `init` method in the super constructor should be made `final` or `private`.\n* The initialization that is performed in the overridden `init` method in the subclass can be moved to the subclass constructor itself, or delegated to a separate final or private method that is called from within the subclass constructor.\n\n## References\n* J. Bloch, *Effective Java (second edition)*, pp. 89&ndash;90. Addison-Wesley, 2008.\n* The Java Tutorials: [Writing Final Classes and Methods](https://docs.oracle.com/javase/tutorial/java/IandI/final.html).\n"},"properties":{"tags":["reliability","correctness","logic"],"description":"If a constructor calls a method that is overridden in a subclass, the result can be\n              unpredictable.","id":"java/non-final-call-in-constructor","kind":"problem","name":"Non-final method invocation in constructor","precision":"very-high","problem.severity":"error"}},{"id":"java/unsafe-double-checked-locking","name":"java/unsafe-double-checked-locking","shortDescription":{"text":"Double-checked locking is not thread-safe"},"fullDescription":{"text":"A repeated check on a non-volatile field is not thread-safe, and could result in unexpected behavior."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Double-checked locking is not thread-safe\nDouble-checked locking is a common pattern for lazy initialization of a field accessed by multiple threads. Depending on the memory model of the underlying runtime, it can, however, be quite difficult to implement correctly, since reorderings performed by compiler, runtime, or CPU might expose un-initialized or half-way initialized objects to other threads. Java has since version 5 improved its memory model to support double-checked locking if the underlying field is marked `volatile` and if all initialization happens before the volatile write.\n\n\n## Recommendation\nFirst, it should be considered whether the getter that performs the lazy initialization is performance critical. If not, a much simpler solution is to completely avoid double-checked locking and simply mark the entire getter as `synchronized`. This is much easier to get right and guards against hard-to-find concurrency bugs.\n\nIf double-checked locking is used, it is important that the underlying field is `volatile` and that the update to the field is the last thing that happens in the synchronized region, that is, all initialization must be done before the field is assigned. Furthermore, the Java version must be 5 or newer. Reading a `volatile` field has a slight overhead, so it is also useful to use a local variable to minimize the number of volatile reads.\n\n\n## Example\nThe following code lazily initializes `f` to `new MyObject()`.\n\n\n```java\nprivate Object lock = new Object();\nprivate MyObject f = null;\n\npublic MyObject getMyObject() {\n  if (f == null) {\n    synchronized(lock) {\n      if (f == null) {\n        f = new MyObject(); // BAD\n      }\n    }\n  }\n  return f;\n}\n\n```\nThis code is not thread-safe as another thread might see the assignment to `f` before the constructor finishes evaluating, for example if the compiler inlines the memory allocation and the constructor and reorders the assignment to `f` to occur just after the memory allocation.\n\nAnother example that also is not thread-safe, even when `volatile` is used, is if additional initialization happens after the assignment to `f`, since then other threads may access the constructed object before it is fully initialized, even without any reorderings by the compiler or runtime.\n\n\n```java\nprivate Object lock = new Object();\nprivate volatile MyObject f = null;\n\npublic MyObject getMyObject() {\n  if (f == null) {\n    synchronized(lock) {\n      if (f == null) {\n        f = new MyObject();\n        f.init(); // BAD\n      }\n    }\n  }\n  return f;\n}\n\n```\nThe code above should be rewritten to both use `volatile` and finish all initialization before `f` is updated. Additionally, a local variable can be used to avoid reading the field more times than necessary.\n\n\n```java\nprivate Object lock = new Object();\nprivate volatile MyObject f = null;\n\npublic MyObject getMyObject() {\n  MyObject result = f;\n  if (result == null) {\n    synchronized(lock) {\n      result = f;\n      if (result == null) {\n        result = new MyObject();\n        result.init();\n        f = result; // GOOD\n      }\n    }\n  }\n  return result;\n}\n\n```\nAs a final note, it is possible to use double-checked locking correctly without `volatile` if the object you construct is immutable (that is, the object declares all fields as `final`), and the double-checked field is read exactly once outside the synchronized block.\n\nGiven that all fields in `MyImmutableObject` are declared `final` then the following example is protected against exposing uninitialized fields to another thread. However, since there are two reads of `f` without synchronization, it is possible that these are reordered, which means that this method can return `null`.\n\n\n```java\nprivate Object lock = new Object();\nprivate MyImmutableObject f = null;\n\npublic MyImmutableObject getMyImmutableObject() {\n  if (f == null) {\n    synchronized(lock) {\n      if (f == null) {\n        f = new MyImmutableObject();\n      }\n    }\n  }\n  return f; // BAD\n}\n\n```\nIn this case, using a local variable to minimize the number of field reads is no longer a performance improvement, but rather a crucial detail that is necessary for correctness.\n\n\n## References\n* [The \"Double-Checked Locking is Broken\" Declaration](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html).\n* Java Language Specification: [17.4. Memory Model](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4).\n* Wikipedia: [Double-checked locking](https://en.wikipedia.org/wiki/Double-checked_locking).\n* Aleksey Shipilëv: [Safe Publication and Safe Initialization in Java](https://shipilev.net/blog/2014/safe-public-construction/).\n* Aleksey Shipilëv: [Close Encounters of The Java Memory Model Kind](https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/).\n* Common Weakness Enumeration: [CWE-609](https://cwe.mitre.org/data/definitions/609.html).\n","markdown":"# Double-checked locking is not thread-safe\nDouble-checked locking is a common pattern for lazy initialization of a field accessed by multiple threads. Depending on the memory model of the underlying runtime, it can, however, be quite difficult to implement correctly, since reorderings performed by compiler, runtime, or CPU might expose un-initialized or half-way initialized objects to other threads. Java has since version 5 improved its memory model to support double-checked locking if the underlying field is marked `volatile` and if all initialization happens before the volatile write.\n\n\n## Recommendation\nFirst, it should be considered whether the getter that performs the lazy initialization is performance critical. If not, a much simpler solution is to completely avoid double-checked locking and simply mark the entire getter as `synchronized`. This is much easier to get right and guards against hard-to-find concurrency bugs.\n\nIf double-checked locking is used, it is important that the underlying field is `volatile` and that the update to the field is the last thing that happens in the synchronized region, that is, all initialization must be done before the field is assigned. Furthermore, the Java version must be 5 or newer. Reading a `volatile` field has a slight overhead, so it is also useful to use a local variable to minimize the number of volatile reads.\n\n\n## Example\nThe following code lazily initializes `f` to `new MyObject()`.\n\n\n```java\nprivate Object lock = new Object();\nprivate MyObject f = null;\n\npublic MyObject getMyObject() {\n  if (f == null) {\n    synchronized(lock) {\n      if (f == null) {\n        f = new MyObject(); // BAD\n      }\n    }\n  }\n  return f;\n}\n\n```\nThis code is not thread-safe as another thread might see the assignment to `f` before the constructor finishes evaluating, for example if the compiler inlines the memory allocation and the constructor and reorders the assignment to `f` to occur just after the memory allocation.\n\nAnother example that also is not thread-safe, even when `volatile` is used, is if additional initialization happens after the assignment to `f`, since then other threads may access the constructed object before it is fully initialized, even without any reorderings by the compiler or runtime.\n\n\n```java\nprivate Object lock = new Object();\nprivate volatile MyObject f = null;\n\npublic MyObject getMyObject() {\n  if (f == null) {\n    synchronized(lock) {\n      if (f == null) {\n        f = new MyObject();\n        f.init(); // BAD\n      }\n    }\n  }\n  return f;\n}\n\n```\nThe code above should be rewritten to both use `volatile` and finish all initialization before `f` is updated. Additionally, a local variable can be used to avoid reading the field more times than necessary.\n\n\n```java\nprivate Object lock = new Object();\nprivate volatile MyObject f = null;\n\npublic MyObject getMyObject() {\n  MyObject result = f;\n  if (result == null) {\n    synchronized(lock) {\n      result = f;\n      if (result == null) {\n        result = new MyObject();\n        result.init();\n        f = result; // GOOD\n      }\n    }\n  }\n  return result;\n}\n\n```\nAs a final note, it is possible to use double-checked locking correctly without `volatile` if the object you construct is immutable (that is, the object declares all fields as `final`), and the double-checked field is read exactly once outside the synchronized block.\n\nGiven that all fields in `MyImmutableObject` are declared `final` then the following example is protected against exposing uninitialized fields to another thread. However, since there are two reads of `f` without synchronization, it is possible that these are reordered, which means that this method can return `null`.\n\n\n```java\nprivate Object lock = new Object();\nprivate MyImmutableObject f = null;\n\npublic MyImmutableObject getMyImmutableObject() {\n  if (f == null) {\n    synchronized(lock) {\n      if (f == null) {\n        f = new MyImmutableObject();\n      }\n    }\n  }\n  return f; // BAD\n}\n\n```\nIn this case, using a local variable to minimize the number of field reads is no longer a performance improvement, but rather a crucial detail that is necessary for correctness.\n\n\n## References\n* [The \"Double-Checked Locking is Broken\" Declaration](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html).\n* Java Language Specification: [17.4. Memory Model](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4).\n* Wikipedia: [Double-checked locking](https://en.wikipedia.org/wiki/Double-checked_locking).\n* Aleksey Shipilëv: [Safe Publication and Safe Initialization in Java](https://shipilev.net/blog/2014/safe-public-construction/).\n* Aleksey Shipilëv: [Close Encounters of The Java Memory Model Kind](https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/).\n* Common Weakness Enumeration: [CWE-609](https://cwe.mitre.org/data/definitions/609.html).\n"},"properties":{"tags":["reliability","correctness","concurrency","external/cwe/cwe-609"],"description":"A repeated check on a non-volatile field is not thread-safe, and\n              could result in unexpected behavior.","id":"java/unsafe-double-checked-locking","kind":"problem","name":"Double-checked locking is not thread-safe","precision":"high","problem.severity":"error"}},{"id":"java/unsafe-double-checked-locking-init-order","name":"java/unsafe-double-checked-locking-init-order","shortDescription":{"text":"Race condition in double-checked locking object initialization"},"fullDescription":{"text":"Performing additional initialization on an object after assignment to a shared variable guarded by double-checked locking is not thread-safe, and could result in unexpected behavior."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Race condition in double-checked locking object initialization\nDouble-checked locking is a common pattern for lazy initialization of a field accessed by multiple threads. Depending on the memory model of the underlying runtime, it can, however, be quite difficult to implement correctly, since reorderings performed by compiler, runtime, or CPU might expose un-initialized or half-way initialized objects to other threads. Java has since version 5 improved its memory model to support double-checked locking if the underlying field is marked `volatile` and if all initialization happens before the volatile write.\n\n\n## Recommendation\nFirst, it should be considered whether the getter that performs the lazy initialization is performance critical. If not, a much simpler solution is to completely avoid double-checked locking and simply mark the entire getter as `synchronized`. This is much easier to get right and guards against hard-to-find concurrency bugs.\n\nIf double-checked locking is used, it is important that the underlying field is `volatile` and that the update to the field is the last thing that happens in the synchronized region, that is, all initialization must be done before the field is assigned. Furthermore, the Java version must be 5 or newer. Reading a `volatile` field has a slight overhead, so it is also useful to use a local variable to minimize the number of volatile reads.\n\n\n## Example\nThe following code lazily initializes `f` to `new MyObject()`.\n\n\n```java\nprivate Object lock = new Object();\nprivate MyObject f = null;\n\npublic MyObject getMyObject() {\n  if (f == null) {\n    synchronized(lock) {\n      if (f == null) {\n        f = new MyObject(); // BAD\n      }\n    }\n  }\n  return f;\n}\n\n```\nThis code is not thread-safe as another thread might see the assignment to `f` before the constructor finishes evaluating, for example if the compiler inlines the memory allocation and the constructor and reorders the assignment to `f` to occur just after the memory allocation.\n\nAnother example that also is not thread-safe, even when `volatile` is used, is if additional initialization happens after the assignment to `f`, since then other threads may access the constructed object before it is fully initialized, even without any reorderings by the compiler or runtime.\n\n\n```java\nprivate Object lock = new Object();\nprivate volatile MyObject f = null;\n\npublic MyObject getMyObject() {\n  if (f == null) {\n    synchronized(lock) {\n      if (f == null) {\n        f = new MyObject();\n        f.init(); // BAD\n      }\n    }\n  }\n  return f;\n}\n\n```\nThe code above should be rewritten to both use `volatile` and finish all initialization before `f` is updated. Additionally, a local variable can be used to avoid reading the field more times than necessary.\n\n\n```java\nprivate Object lock = new Object();\nprivate volatile MyObject f = null;\n\npublic MyObject getMyObject() {\n  MyObject result = f;\n  if (result == null) {\n    synchronized(lock) {\n      result = f;\n      if (result == null) {\n        result = new MyObject();\n        result.init();\n        f = result; // GOOD\n      }\n    }\n  }\n  return result;\n}\n\n```\nAs a final note, it is possible to use double-checked locking correctly without `volatile` if the object you construct is immutable (that is, the object declares all fields as `final`), and the double-checked field is read exactly once outside the synchronized block.\n\nGiven that all fields in `MyImmutableObject` are declared `final` then the following example is protected against exposing uninitialized fields to another thread. However, since there are two reads of `f` without synchronization, it is possible that these are reordered, which means that this method can return `null`.\n\n\n```java\nprivate Object lock = new Object();\nprivate MyImmutableObject f = null;\n\npublic MyImmutableObject getMyImmutableObject() {\n  if (f == null) {\n    synchronized(lock) {\n      if (f == null) {\n        f = new MyImmutableObject();\n      }\n    }\n  }\n  return f; // BAD\n}\n\n```\nIn this case, using a local variable to minimize the number of field reads is no longer a performance improvement, but rather a crucial detail that is necessary for correctness.\n\n\n## References\n* [The \"Double-Checked Locking is Broken\" Declaration](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html).\n* Java Language Specification: [17.4. Memory Model](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4).\n* Wikipedia: [Double-checked locking](https://en.wikipedia.org/wiki/Double-checked_locking).\n* Aleksey Shipilëv: [Safe Publication and Safe Initialization in Java](https://shipilev.net/blog/2014/safe-public-construction/).\n* Aleksey Shipilëv: [Close Encounters of The Java Memory Model Kind](https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/).\n* Common Weakness Enumeration: [CWE-609](https://cwe.mitre.org/data/definitions/609.html).\n","markdown":"# Race condition in double-checked locking object initialization\nDouble-checked locking is a common pattern for lazy initialization of a field accessed by multiple threads. Depending on the memory model of the underlying runtime, it can, however, be quite difficult to implement correctly, since reorderings performed by compiler, runtime, or CPU might expose un-initialized or half-way initialized objects to other threads. Java has since version 5 improved its memory model to support double-checked locking if the underlying field is marked `volatile` and if all initialization happens before the volatile write.\n\n\n## Recommendation\nFirst, it should be considered whether the getter that performs the lazy initialization is performance critical. If not, a much simpler solution is to completely avoid double-checked locking and simply mark the entire getter as `synchronized`. This is much easier to get right and guards against hard-to-find concurrency bugs.\n\nIf double-checked locking is used, it is important that the underlying field is `volatile` and that the update to the field is the last thing that happens in the synchronized region, that is, all initialization must be done before the field is assigned. Furthermore, the Java version must be 5 or newer. Reading a `volatile` field has a slight overhead, so it is also useful to use a local variable to minimize the number of volatile reads.\n\n\n## Example\nThe following code lazily initializes `f` to `new MyObject()`.\n\n\n```java\nprivate Object lock = new Object();\nprivate MyObject f = null;\n\npublic MyObject getMyObject() {\n  if (f == null) {\n    synchronized(lock) {\n      if (f == null) {\n        f = new MyObject(); // BAD\n      }\n    }\n  }\n  return f;\n}\n\n```\nThis code is not thread-safe as another thread might see the assignment to `f` before the constructor finishes evaluating, for example if the compiler inlines the memory allocation and the constructor and reorders the assignment to `f` to occur just after the memory allocation.\n\nAnother example that also is not thread-safe, even when `volatile` is used, is if additional initialization happens after the assignment to `f`, since then other threads may access the constructed object before it is fully initialized, even without any reorderings by the compiler or runtime.\n\n\n```java\nprivate Object lock = new Object();\nprivate volatile MyObject f = null;\n\npublic MyObject getMyObject() {\n  if (f == null) {\n    synchronized(lock) {\n      if (f == null) {\n        f = new MyObject();\n        f.init(); // BAD\n      }\n    }\n  }\n  return f;\n}\n\n```\nThe code above should be rewritten to both use `volatile` and finish all initialization before `f` is updated. Additionally, a local variable can be used to avoid reading the field more times than necessary.\n\n\n```java\nprivate Object lock = new Object();\nprivate volatile MyObject f = null;\n\npublic MyObject getMyObject() {\n  MyObject result = f;\n  if (result == null) {\n    synchronized(lock) {\n      result = f;\n      if (result == null) {\n        result = new MyObject();\n        result.init();\n        f = result; // GOOD\n      }\n    }\n  }\n  return result;\n}\n\n```\nAs a final note, it is possible to use double-checked locking correctly without `volatile` if the object you construct is immutable (that is, the object declares all fields as `final`), and the double-checked field is read exactly once outside the synchronized block.\n\nGiven that all fields in `MyImmutableObject` are declared `final` then the following example is protected against exposing uninitialized fields to another thread. However, since there are two reads of `f` without synchronization, it is possible that these are reordered, which means that this method can return `null`.\n\n\n```java\nprivate Object lock = new Object();\nprivate MyImmutableObject f = null;\n\npublic MyImmutableObject getMyImmutableObject() {\n  if (f == null) {\n    synchronized(lock) {\n      if (f == null) {\n        f = new MyImmutableObject();\n      }\n    }\n  }\n  return f; // BAD\n}\n\n```\nIn this case, using a local variable to minimize the number of field reads is no longer a performance improvement, but rather a crucial detail that is necessary for correctness.\n\n\n## References\n* [The \"Double-Checked Locking is Broken\" Declaration](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html).\n* Java Language Specification: [17.4. Memory Model](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4).\n* Wikipedia: [Double-checked locking](https://en.wikipedia.org/wiki/Double-checked_locking).\n* Aleksey Shipilëv: [Safe Publication and Safe Initialization in Java](https://shipilev.net/blog/2014/safe-public-construction/).\n* Aleksey Shipilëv: [Close Encounters of The Java Memory Model Kind](https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/).\n* Common Weakness Enumeration: [CWE-609](https://cwe.mitre.org/data/definitions/609.html).\n"},"properties":{"tags":["reliability","correctness","concurrency","external/cwe/cwe-609"],"description":"Performing additional initialization on an object after\n              assignment to a shared variable guarded by double-checked\n              locking is not thread-safe, and could result in unexpected\n              behavior.","id":"java/unsafe-double-checked-locking-init-order","kind":"problem","name":"Race condition in double-checked locking object initialization","precision":"high","problem.severity":"warning"}},{"id":"java/sync-on-boxed-types","name":"java/sync-on-boxed-types","shortDescription":{"text":"Synchronization on boxed types or strings"},"fullDescription":{"text":"Synchronizing on boxed types or strings may lead to deadlock since an instance of that type is likely to be shared between many parts of the program."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Synchronization on boxed types or strings\nCode should not synchronize on a variable or field of a boxed type (for example `Integer`, `Boolean`) or of type `String` since it is likely to contain an object that is used throughout the program. For example, `Boolean.TRUE` holds a single instance that will be used in many places throughout the program: whenever `true` is autoboxed or a call to `Boolean.valueOf` is made with `true` as an argument the same instance of `Boolean` is returned. It is therefore likely that two classes synchronizing on a field of type `Boolean` will end up synchronizing on the same object. This may lead to deadlock or threads being blocked unnecessarily.\n\n\n## Recommendation\nSynchronize on a specific lock object instead of using an object with a boxed type.\n\n\n## Example\nIn the following example, the intention is to allow `ThreadA` and `ThreadB` to run at the same time. Unfortunately, `ThreadA.lock` and `ThreadB.lock` both refer to the same object (that is, the interned value of the `String` `\"lock\"`) so the synchronized blocks in their run methods can not be executed concurrently.\n\n\n```java\nclass BadSynchronize{\n\t\t\n\tclass ThreadA extends Thread{\n\t\tprivate String value = \"lock\"\n\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(value){\n\t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass ThreadB extends Thread{\n\t\tprivate String value = \"lock\"\n\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(value){\n\t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run(){\n\t\tnew ThreadA().start();\n\t\tnew ThreadB().start();\n\t}\n\t\t\n}\n```\nIn the following example, the approach recommended above is shown. A separate lock object is created for each thread allowing them to execute concurrently.\n\n\n```java\nclass GoodSynchronize{\n\t\t\n\tclass ThreadA extends Thread{\n\t\tprivate Object lock = new Object();\n\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(lock){\n\t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass ThreadB extends Thread{\n\t\tprivate Object lock = new Object();\n\t\t\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(lock){\n\t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run(){\n\t\tnew ThreadA().start();\n\t\tnew ThreadB().start();\n\t}\n\t\t\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [LCK01-J. Do not synchronize on objects that may be reused](https://wiki.sei.cmu.edu/confluence/display/java/LCK01-J.+Do+not+synchronize+on+objects+that+may+be+reused),\n* Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n","markdown":"# Synchronization on boxed types or strings\nCode should not synchronize on a variable or field of a boxed type (for example `Integer`, `Boolean`) or of type `String` since it is likely to contain an object that is used throughout the program. For example, `Boolean.TRUE` holds a single instance that will be used in many places throughout the program: whenever `true` is autoboxed or a call to `Boolean.valueOf` is made with `true` as an argument the same instance of `Boolean` is returned. It is therefore likely that two classes synchronizing on a field of type `Boolean` will end up synchronizing on the same object. This may lead to deadlock or threads being blocked unnecessarily.\n\n\n## Recommendation\nSynchronize on a specific lock object instead of using an object with a boxed type.\n\n\n## Example\nIn the following example, the intention is to allow `ThreadA` and `ThreadB` to run at the same time. Unfortunately, `ThreadA.lock` and `ThreadB.lock` both refer to the same object (that is, the interned value of the `String` `\"lock\"`) so the synchronized blocks in their run methods can not be executed concurrently.\n\n\n```java\nclass BadSynchronize{\n\t\t\n\tclass ThreadA extends Thread{\n\t\tprivate String value = \"lock\"\n\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(value){\n\t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass ThreadB extends Thread{\n\t\tprivate String value = \"lock\"\n\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(value){\n\t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run(){\n\t\tnew ThreadA().start();\n\t\tnew ThreadB().start();\n\t}\n\t\t\n}\n```\nIn the following example, the approach recommended above is shown. A separate lock object is created for each thread allowing them to execute concurrently.\n\n\n```java\nclass GoodSynchronize{\n\t\t\n\tclass ThreadA extends Thread{\n\t\tprivate Object lock = new Object();\n\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(lock){\n\t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass ThreadB extends Thread{\n\t\tprivate Object lock = new Object();\n\t\t\t\t\n\t\tpublic void run(){\n\t\t\tsynchronized(lock){\n\t\t\t\t//...\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run(){\n\t\tnew ThreadA().start();\n\t\tnew ThreadB().start();\n\t}\n\t\t\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [LCK01-J. Do not synchronize on objects that may be reused](https://wiki.sei.cmu.edu/confluence/display/java/LCK01-J.+Do+not+synchronize+on+objects+that+may+be+reused),\n* Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n"},"properties":{"tags":["reliability","correctness","concurrency","language-features","external/cwe/cwe-662"],"description":"Synchronizing on boxed types or strings may lead to\n              deadlock since an instance of that type is likely to\n              be shared between many parts of the program.","id":"java/sync-on-boxed-types","kind":"problem","name":"Synchronization on boxed types or strings","precision":"very-high","problem.severity":"error"}},{"id":"java/call-to-thread-run","name":"java/call-to-thread-run","shortDescription":{"text":"Direct call to a run() method"},"fullDescription":{"text":"Directly calling a 'Thread' object's 'run' method does not start a separate thread but executes the method within the current thread."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Direct call to a run() method\nA direct call of a `Thread` object's `run` method does not start a separate thread. The method is executed within the current thread. This is an unusual use because `Thread.run()` is normally intended to be called from within a separate thread.\n\n\n## Recommendation\nTo execute `Runnable.run` from within a separate thread, do one of the following:\n\n* Construct a `Thread` object using the `Runnable` object, and call `start` on the `Thread` object.\n* Define a subclass of a `Thread` object, and override the definition of its `run` method. Then construct an instance of this subclass and call `start` on that instance directly.\n\n## Example\nIn the following example, the main thread, `ThreadDemo`, calls the child thread, `NewThread`, using `run`. This causes the child thread to run to completion before the rest of the main thread is executed, so that \"Child thread activity\" is printed before \"Main thread activity\".\n\n\n```java\npublic class ThreadDemo {\n    public static void main(String args[]) {\n        NewThread runnable = new NewThread();\n\n        runnable.run();    // Call to 'run' does not start a separate thread\n\n        System.out.println(\"Main thread activity.\");\n    }\n}\n\nclass NewThread extends Thread {\n    public void run() {\n        try {\n            Thread.sleep(10000);\n        }\n        catch (InterruptedException e) {\n            System.out.println(\"Child interrupted.\");\n        }\n        System.out.println(\"Child thread activity.\");\n    }\n}\n```\nTo enable the two threads to run concurrently, create the child thread and call `start`, as shown below. This causes the main thread to continue while the child thread is waiting, so that \"Main thread activity\" is printed before \"Child thread activity\".\n\n\n```java\npublic class ThreadDemo {\n    public static void main(String args[]) {\n    \tNewThread runnable = new NewThread();\n    \t\n        runnable.start();                                         // Call 'start' method\n        \n        System.out.println(\"Main thread activity.\");\n    }\n}\n```\n\n## References\n* The Java Tutorials: [Defining and Starting a Thread](https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html).\n* Common Weakness Enumeration: [CWE-572](https://cwe.mitre.org/data/definitions/572.html).\n","markdown":"# Direct call to a run() method\nA direct call of a `Thread` object's `run` method does not start a separate thread. The method is executed within the current thread. This is an unusual use because `Thread.run()` is normally intended to be called from within a separate thread.\n\n\n## Recommendation\nTo execute `Runnable.run` from within a separate thread, do one of the following:\n\n* Construct a `Thread` object using the `Runnable` object, and call `start` on the `Thread` object.\n* Define a subclass of a `Thread` object, and override the definition of its `run` method. Then construct an instance of this subclass and call `start` on that instance directly.\n\n## Example\nIn the following example, the main thread, `ThreadDemo`, calls the child thread, `NewThread`, using `run`. This causes the child thread to run to completion before the rest of the main thread is executed, so that \"Child thread activity\" is printed before \"Main thread activity\".\n\n\n```java\npublic class ThreadDemo {\n    public static void main(String args[]) {\n        NewThread runnable = new NewThread();\n\n        runnable.run();    // Call to 'run' does not start a separate thread\n\n        System.out.println(\"Main thread activity.\");\n    }\n}\n\nclass NewThread extends Thread {\n    public void run() {\n        try {\n            Thread.sleep(10000);\n        }\n        catch (InterruptedException e) {\n            System.out.println(\"Child interrupted.\");\n        }\n        System.out.println(\"Child thread activity.\");\n    }\n}\n```\nTo enable the two threads to run concurrently, create the child thread and call `start`, as shown below. This causes the main thread to continue while the child thread is waiting, so that \"Main thread activity\" is printed before \"Child thread activity\".\n\n\n```java\npublic class ThreadDemo {\n    public static void main(String args[]) {\n    \tNewThread runnable = new NewThread();\n    \t\n        runnable.start();                                         // Call 'start' method\n        \n        System.out.println(\"Main thread activity.\");\n    }\n}\n```\n\n## References\n* The Java Tutorials: [Defining and Starting a Thread](https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html).\n* Common Weakness Enumeration: [CWE-572](https://cwe.mitre.org/data/definitions/572.html).\n"},"properties":{"tags":["reliability","correctness","concurrency","external/cwe/cwe-572"],"description":"Directly calling a 'Thread' object's 'run' method does not start a separate thread\n              but executes the method within the current thread.","id":"java/call-to-thread-run","kind":"problem","name":"Direct call to a run() method","precision":"high","problem.severity":"recommendation"}},{"id":"java/unsynchronized-getter","name":"java/unsynchronized-getter","shortDescription":{"text":"Inconsistent synchronization of getter and setter"},"fullDescription":{"text":"If a class has a synchronized 'set' method, and a similarly-named 'get' method is not also synchronized, calls to the 'get' method may not return a consistent state for the object."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Inconsistent synchronization of getter and setter\nIf a class has a synchronized `set` method and a similarly-named `get` method is not also synchronized, calls to the `get` method may not return a consistent state for the object.\n\n\n## Recommendation\nSynchronize read operations as well as write operations. You should usually synchronize the `get` method.\n\n\n## References\n* Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).\n* Common Weakness Enumeration: [CWE-413](https://cwe.mitre.org/data/definitions/413.html).\n* Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n","markdown":"# Inconsistent synchronization of getter and setter\nIf a class has a synchronized `set` method and a similarly-named `get` method is not also synchronized, calls to the `get` method may not return a consistent state for the object.\n\n\n## Recommendation\nSynchronize read operations as well as write operations. You should usually synchronize the `get` method.\n\n\n## References\n* Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).\n* Common Weakness Enumeration: [CWE-413](https://cwe.mitre.org/data/definitions/413.html).\n* Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n"},"properties":{"tags":["reliability","correctness","concurrency","language-features","external/cwe/cwe-413","external/cwe/cwe-662"],"description":"If a class has a synchronized 'set' method, and a similarly-named 'get' method is\n              not also synchronized, calls to the 'get' method may not return a consistent state\n              for the object.","id":"java/unsynchronized-getter","kind":"problem","name":"Inconsistent synchronization of getter and setter","precision":"very-high","problem.severity":"error"}},{"id":"java/non-sync-override","name":"java/non-sync-override","shortDescription":{"text":"Non-synchronized override of synchronized method"},"fullDescription":{"text":"If a synchronized method is overridden in a subclass, and the overriding method is not synchronized, the thread-safety of the subclass may be broken."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Non-synchronized override of synchronized method\nIf a synchronized method is overridden in a subclass, the compiler does not require the overriding method to be synchronized. However, if the overriding method is not synchronized, the thread-safety of the subclass may be broken.\n\n\n## Recommendation\nEnsure that the overriding method is synchronized, if necessary.\n\n\n## References\n* Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-820](https://cwe.mitre.org/data/definitions/820.html).\n","markdown":"# Non-synchronized override of synchronized method\nIf a synchronized method is overridden in a subclass, the compiler does not require the overriding method to be synchronized. However, if the overriding method is not synchronized, the thread-safety of the subclass may be broken.\n\n\n## Recommendation\nEnsure that the overriding method is synchronized, if necessary.\n\n\n## References\n* Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-820](https://cwe.mitre.org/data/definitions/820.html).\n"},"properties":{"tags":["reliability","correctness","concurrency","language-features","external/cwe/cwe-820"],"description":"If a synchronized method is overridden in a subclass, and the overriding method is\n              not synchronized, the thread-safety of the subclass may be broken.","id":"java/non-sync-override","kind":"problem","name":"Non-synchronized override of synchronized method","precision":"very-high","problem.severity":"warning"}},{"id":"java/database-resource-leak","name":"java/database-resource-leak","shortDescription":{"text":"Potential database resource leak"},"fullDescription":{"text":"A database resource that is opened but not closed may cause a resource leak."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Potential database resource leak\nA database resource in the `java.sql` package that is opened but not closed may cause a resource leak and ultimately resource exhaustion.\n\n\n## Recommendation\nEnsure that the resource is always closed to avoid a resource leak. Note that, because of exceptions, it is safest to close a resource in a `finally` block.\n\nFor Java 7 or later, the recommended way to close resources that implement `java.lang.AutoCloseable` is to declare them within a `try-with-resources` statement, so that they are closed implicitly.\n\n\n## Example\nIn the following example, the resources `stmt` and `rs` are opened but not closed.\n\n\n```java\npublic class CloseSql {\n\tpublic static void runQuery(Connection con, String query) throws SQLException {\n\t\tStatement stmt = con.createStatement();\n\t\tResultSet rs = stmt.executeQuery(query);\n\t\twhile (rs.next()) {\n\t\t\t// process result set\n\t\t}\n\t}\n}\n```\nIn the following example, the resources `stmt` and `rs` are declared within a `try-with-resources` block and are thus closed implicitly.\n\n\n```java\npublic class CloseSqlGood {\n\tpublic static void runQuery(Connection con, String query) throws SQLException {\n\t\ttry (Statement stmt = con.createStatement();\n\t\t\t\tResultSet rs = stmt.executeQuery(query)) {\n\t\t\twhile (rs.next()) {\n\t\t\t\t// process result set\n\t\t\t}\n\t\t}\n\t}\n}\n```\nNote that the `Connection` that is passed into the method is a long-lived object that was created elsewhere and therefore need not be closed locally. It should instead be closed by the code that created it or by a server shutdown procedure, as appropriate.\n\n\n## References\n* IBM developerWorks: [Java theory and practice: Good housekeeping practices](https://web.archive.org/web/20201109041839/http://www.ibm.com/developerworks/java/library/j-jtp03216/index.html).\n* The Java Tutorials: [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).\n* Common Weakness Enumeration: [CWE-404](https://cwe.mitre.org/data/definitions/404.html).\n* Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n","markdown":"# Potential database resource leak\nA database resource in the `java.sql` package that is opened but not closed may cause a resource leak and ultimately resource exhaustion.\n\n\n## Recommendation\nEnsure that the resource is always closed to avoid a resource leak. Note that, because of exceptions, it is safest to close a resource in a `finally` block.\n\nFor Java 7 or later, the recommended way to close resources that implement `java.lang.AutoCloseable` is to declare them within a `try-with-resources` statement, so that they are closed implicitly.\n\n\n## Example\nIn the following example, the resources `stmt` and `rs` are opened but not closed.\n\n\n```java\npublic class CloseSql {\n\tpublic static void runQuery(Connection con, String query) throws SQLException {\n\t\tStatement stmt = con.createStatement();\n\t\tResultSet rs = stmt.executeQuery(query);\n\t\twhile (rs.next()) {\n\t\t\t// process result set\n\t\t}\n\t}\n}\n```\nIn the following example, the resources `stmt` and `rs` are declared within a `try-with-resources` block and are thus closed implicitly.\n\n\n```java\npublic class CloseSqlGood {\n\tpublic static void runQuery(Connection con, String query) throws SQLException {\n\t\ttry (Statement stmt = con.createStatement();\n\t\t\t\tResultSet rs = stmt.executeQuery(query)) {\n\t\t\twhile (rs.next()) {\n\t\t\t\t// process result set\n\t\t\t}\n\t\t}\n\t}\n}\n```\nNote that the `Connection` that is passed into the method is a long-lived object that was created elsewhere and therefore need not be closed locally. It should instead be closed by the code that created it or by a server shutdown procedure, as appropriate.\n\n\n## References\n* IBM developerWorks: [Java theory and practice: Good housekeeping practices](https://web.archive.org/web/20201109041839/http://www.ibm.com/developerworks/java/library/j-jtp03216/index.html).\n* The Java Tutorials: [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).\n* Common Weakness Enumeration: [CWE-404](https://cwe.mitre.org/data/definitions/404.html).\n* Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n"},"properties":{"tags":["correctness","resources","external/cwe/cwe-404","external/cwe/cwe-772"],"description":"A database resource that is opened but not closed may cause a resource leak.","id":"java/database-resource-leak","kind":"problem","name":"Potential database resource leak","precision":"high","problem.severity":"warning"}},{"id":"java/input-resource-leak","name":"java/input-resource-leak","shortDescription":{"text":"Potential input resource leak"},"fullDescription":{"text":"A resource that is opened for reading but not closed may cause a resource leak."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Potential input resource leak\nA subclass of `Reader` or `InputStream` that is opened for reading but not closed may cause a resource leak.\n\n\n## Recommendation\nEnsure that the resource is always closed to avoid a resource leak. Note that, because of exceptions, it is safest to close a resource in a `finally` block. (However, this is unnecessary for subclasses of `CharArrayReader`, `StringReader` and `ByteArrayInputStream`.)\n\nFor Java 7 or later, the recommended way to close resources that implement `java.lang.AutoCloseable` is to declare them within a `try-with-resources` statement, so that they are closed implicitly.\n\n\n## Example\nIn the following example, the resource `br` is opened but not closed.\n\n\n```java\npublic class CloseReader {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new FileReader(\"C:\\\\test.txt\"));\n\t\tSystem.out.println(br.readLine());\n\t\t// ...\n\t}\n}\n```\nIn the following example, the resource `br` is opened in a `try` block and later closed in a `finally` block.\n\n\n```java\npublic class CloseReaderFix {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\tbr = new BufferedReader(new FileReader(\"C:\\\\test.txt\"));\n\t\t\tSystem.out.println(br.readLine());\n\t\t}\n\t\tfinally {\n\t\t\tif(br != null)\n\t\t\t\tbr.close();  // 'br' is closed\n\t\t}\n\t\t// ...\n\t}\n}\n```\nNote that nested class instance creation expressions of `Reader`s or `InputStream`s are not safe to use if the constructor of the outer expression may throw an exception. In the following example, the `InputStreamReader` may throw an exception, in which case the inner `FileInputStream` is not closed.\n\n\n```java\npublic class CloseReaderNested {\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStreamReader reader = null;\n\t\ttry {\n\t\t\t// InputStreamReader may throw an exception, in which case the ...\n\t\t\treader = new InputStreamReader(\n\t\t\t\t\t// ... FileInputStream is not closed by the finally block\n\t\t\t\t\tnew FileInputStream(\"C:\\\\test.txt\"), \"UTF-8\");\n\t\t\tSystem.out.println(reader.read());\n\t\t}\n\t\tfinally {\n\t\t\tif (reader != null)\n\t\t\t\treader.close();\n\t\t}\n\t}\n}\n```\nIn this case, the inner expression needs to be assigned to a local variable and closed separately, as shown below.\n\n\n```java\npublic class CloseReaderNestedFix {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFileInputStream fis = null;\n\t\tInputStreamReader reader = null;\n\t\ttry {\n\t\t\tfis = new FileInputStream(\"C:\\\\test.txt\");\n\t\t\treader = new InputStreamReader(fis);\n\t\t\tSystem.out.println(reader.read());\n\t\t}\n\t\tfinally {\n\t\t\tif (reader != null)\n\t\t\t\treader.close();  // 'reader' is closed\n\t\t\tif (fis != null)\n\t\t\t\tfis.close();  // 'fis' is closed\n\t\t}\n\t}\n}\n```\n\n## References\n* IBM developerWorks: [Java theory and practice: Good housekeeping practices](https://web.archive.org/web/20201109041839/http://www.ibm.com/developerworks/java/library/j-jtp03216/index.html).\n* The Java Tutorials: [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).\n* Common Weakness Enumeration: [CWE-404](https://cwe.mitre.org/data/definitions/404.html).\n* Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n","markdown":"# Potential input resource leak\nA subclass of `Reader` or `InputStream` that is opened for reading but not closed may cause a resource leak.\n\n\n## Recommendation\nEnsure that the resource is always closed to avoid a resource leak. Note that, because of exceptions, it is safest to close a resource in a `finally` block. (However, this is unnecessary for subclasses of `CharArrayReader`, `StringReader` and `ByteArrayInputStream`.)\n\nFor Java 7 or later, the recommended way to close resources that implement `java.lang.AutoCloseable` is to declare them within a `try-with-resources` statement, so that they are closed implicitly.\n\n\n## Example\nIn the following example, the resource `br` is opened but not closed.\n\n\n```java\npublic class CloseReader {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new FileReader(\"C:\\\\test.txt\"));\n\t\tSystem.out.println(br.readLine());\n\t\t// ...\n\t}\n}\n```\nIn the following example, the resource `br` is opened in a `try` block and later closed in a `finally` block.\n\n\n```java\npublic class CloseReaderFix {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\tbr = new BufferedReader(new FileReader(\"C:\\\\test.txt\"));\n\t\t\tSystem.out.println(br.readLine());\n\t\t}\n\t\tfinally {\n\t\t\tif(br != null)\n\t\t\t\tbr.close();  // 'br' is closed\n\t\t}\n\t\t// ...\n\t}\n}\n```\nNote that nested class instance creation expressions of `Reader`s or `InputStream`s are not safe to use if the constructor of the outer expression may throw an exception. In the following example, the `InputStreamReader` may throw an exception, in which case the inner `FileInputStream` is not closed.\n\n\n```java\npublic class CloseReaderNested {\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStreamReader reader = null;\n\t\ttry {\n\t\t\t// InputStreamReader may throw an exception, in which case the ...\n\t\t\treader = new InputStreamReader(\n\t\t\t\t\t// ... FileInputStream is not closed by the finally block\n\t\t\t\t\tnew FileInputStream(\"C:\\\\test.txt\"), \"UTF-8\");\n\t\t\tSystem.out.println(reader.read());\n\t\t}\n\t\tfinally {\n\t\t\tif (reader != null)\n\t\t\t\treader.close();\n\t\t}\n\t}\n}\n```\nIn this case, the inner expression needs to be assigned to a local variable and closed separately, as shown below.\n\n\n```java\npublic class CloseReaderNestedFix {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFileInputStream fis = null;\n\t\tInputStreamReader reader = null;\n\t\ttry {\n\t\t\tfis = new FileInputStream(\"C:\\\\test.txt\");\n\t\t\treader = new InputStreamReader(fis);\n\t\t\tSystem.out.println(reader.read());\n\t\t}\n\t\tfinally {\n\t\t\tif (reader != null)\n\t\t\t\treader.close();  // 'reader' is closed\n\t\t\tif (fis != null)\n\t\t\t\tfis.close();  // 'fis' is closed\n\t\t}\n\t}\n}\n```\n\n## References\n* IBM developerWorks: [Java theory and practice: Good housekeeping practices](https://web.archive.org/web/20201109041839/http://www.ibm.com/developerworks/java/library/j-jtp03216/index.html).\n* The Java Tutorials: [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).\n* Common Weakness Enumeration: [CWE-404](https://cwe.mitre.org/data/definitions/404.html).\n* Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n"},"properties":{"tags":["efficiency","correctness","resources","external/cwe/cwe-404","external/cwe/cwe-772"],"description":"A resource that is opened for reading but not closed may cause a resource\n              leak.","id":"java/input-resource-leak","kind":"problem","name":"Potential input resource leak","precision":"high","problem.severity":"warning"}},{"id":"java/output-resource-leak","name":"java/output-resource-leak","shortDescription":{"text":"Potential output resource leak"},"fullDescription":{"text":"A resource that is opened for writing but not closed may cause a resource leak."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Potential output resource leak\nA subclass of `Writer` or `OutputStream` that is opened for writing but not properly closed later may cause a resource leak.\n\n\n## Recommendation\nEnsure that the resource is always closed to avoid a resource leak. Note that, because of exceptions, it is safest to close a resource properly in a `finally` block. (However, this is unnecessary for subclasses of `CharArrayWriter`, `StringWriter` and `ByteArrayOutputStream`.)\n\nFor Java 7 or later, the recommended way to close resources that implement `java.lang.AutoCloseable` is to declare them within a `try-with-resources` statement, so that they are closed implicitly.\n\n\n## Example\nIn the following example, the resource `bw` is opened but not closed.\n\n\n```java\npublic class CloseWriter {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(\"C:\\\\test.txt\"));\n\t\tbw.write(\"Hello world!\");\n\t\t// ...\n\t}\n}\n```\nIn the following example, the resource `bw` is opened in a `try` block and later closed in a `finally` block.\n\n\n```java\npublic class CloseWriterFix {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedWriter bw = null;\n\t\ttry {\n\t\t\tbw = new BufferedWriter(new FileWriter(\"C:\\\\test.txt\"));\n\t\t\tbw.write(\"Hello world!\");\n\t\t}\n\t\tfinally {\n\t\t\tif(bw != null)\n\t\t\t\tbw.close();  // 'bw' is closed\n\t\t}\n\t\t// ...\n\t}\n}\n```\nNote that nested class instance creation expressions of `Writer`s or `OutputStream`s are not safe to use if the constructor of the outer expression may throw an exception. In the following example, the `OutputStreamWriter` may throw an exception, in which case the inner `FileOutputStream` is not closed.\n\n\n```java\npublic class CloseWriterNested {\n\tpublic static void main(String[] args) throws IOException {\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\t// OutputStreamWriter may throw an exception, in which case the ...\n\t\t\twriter = new OutputStreamWriter(\n\t\t\t\t\t// ... FileOutputStream is not closed by the finally block\n\t\t\t\t\tnew FileOutputStream(\"C:\\\\test.txt\"), \"UTF-8\");\n\t\t\twriter.write(\"Hello world!\");\n\t\t}\n\t\tfinally {\n\t\t\tif (writer != null)\n\t\t\t\twriter.close();\n\t\t}\n\t}\n}\n```\nIn this case, the inner expression needs to be assigned to a local variable and closed separately, as shown below.\n\n\n```java\npublic class CloseWriterNestedFix {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFileOutputStream fos = null;\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\tfos = new FileOutputStream(\"C:\\\\test.txt\");\n\t\t\twriter = new OutputStreamWriter(fos);\n\t\t\twriter.write(\"Hello world!\");\n\t\t}\n\t\tfinally {\n\t\t\tif (writer != null)\n\t\t\t\twriter.close();  // 'writer' is closed\n\t\t\tif (fos != null)\n\t\t\t\tfos.close();  // 'fos' is closed\n\t\t}\n\t}\n}\n```\n\n## References\n* IBM developerWorks: [Java theory and practice: Good housekeeping practices](https://web.archive.org/web/20201109041839/http://www.ibm.com/developerworks/java/library/j-jtp03216/index.html).\n* The Java Tutorials: [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).\n* Common Weakness Enumeration: [CWE-404](https://cwe.mitre.org/data/definitions/404.html).\n* Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n","markdown":"# Potential output resource leak\nA subclass of `Writer` or `OutputStream` that is opened for writing but not properly closed later may cause a resource leak.\n\n\n## Recommendation\nEnsure that the resource is always closed to avoid a resource leak. Note that, because of exceptions, it is safest to close a resource properly in a `finally` block. (However, this is unnecessary for subclasses of `CharArrayWriter`, `StringWriter` and `ByteArrayOutputStream`.)\n\nFor Java 7 or later, the recommended way to close resources that implement `java.lang.AutoCloseable` is to declare them within a `try-with-resources` statement, so that they are closed implicitly.\n\n\n## Example\nIn the following example, the resource `bw` is opened but not closed.\n\n\n```java\npublic class CloseWriter {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(\"C:\\\\test.txt\"));\n\t\tbw.write(\"Hello world!\");\n\t\t// ...\n\t}\n}\n```\nIn the following example, the resource `bw` is opened in a `try` block and later closed in a `finally` block.\n\n\n```java\npublic class CloseWriterFix {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedWriter bw = null;\n\t\ttry {\n\t\t\tbw = new BufferedWriter(new FileWriter(\"C:\\\\test.txt\"));\n\t\t\tbw.write(\"Hello world!\");\n\t\t}\n\t\tfinally {\n\t\t\tif(bw != null)\n\t\t\t\tbw.close();  // 'bw' is closed\n\t\t}\n\t\t// ...\n\t}\n}\n```\nNote that nested class instance creation expressions of `Writer`s or `OutputStream`s are not safe to use if the constructor of the outer expression may throw an exception. In the following example, the `OutputStreamWriter` may throw an exception, in which case the inner `FileOutputStream` is not closed.\n\n\n```java\npublic class CloseWriterNested {\n\tpublic static void main(String[] args) throws IOException {\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\t// OutputStreamWriter may throw an exception, in which case the ...\n\t\t\twriter = new OutputStreamWriter(\n\t\t\t\t\t// ... FileOutputStream is not closed by the finally block\n\t\t\t\t\tnew FileOutputStream(\"C:\\\\test.txt\"), \"UTF-8\");\n\t\t\twriter.write(\"Hello world!\");\n\t\t}\n\t\tfinally {\n\t\t\tif (writer != null)\n\t\t\t\twriter.close();\n\t\t}\n\t}\n}\n```\nIn this case, the inner expression needs to be assigned to a local variable and closed separately, as shown below.\n\n\n```java\npublic class CloseWriterNestedFix {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFileOutputStream fos = null;\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\tfos = new FileOutputStream(\"C:\\\\test.txt\");\n\t\t\twriter = new OutputStreamWriter(fos);\n\t\t\twriter.write(\"Hello world!\");\n\t\t}\n\t\tfinally {\n\t\t\tif (writer != null)\n\t\t\t\twriter.close();  // 'writer' is closed\n\t\t\tif (fos != null)\n\t\t\t\tfos.close();  // 'fos' is closed\n\t\t}\n\t}\n}\n```\n\n## References\n* IBM developerWorks: [Java theory and practice: Good housekeeping practices](https://web.archive.org/web/20201109041839/http://www.ibm.com/developerworks/java/library/j-jtp03216/index.html).\n* The Java Tutorials: [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).\n* Common Weakness Enumeration: [CWE-404](https://cwe.mitre.org/data/definitions/404.html).\n* Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n"},"properties":{"tags":["efficiency","correctness","resources","external/cwe/cwe-404","external/cwe/cwe-772"],"description":"A resource that is opened for writing but not closed may cause a resource\n              leak.","id":"java/output-resource-leak","kind":"problem","name":"Potential output resource leak","precision":"high","problem.severity":"warning"}},{"id":"java/reference-equality-of-boxed-types","name":"java/reference-equality-of-boxed-types","shortDescription":{"text":"Reference equality test of boxed types"},"fullDescription":{"text":"Comparing two boxed primitive values using the == or != operator compares object identity, which may not be intended."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Reference equality test of boxed types\nComparing two boxed primitive values using `==` or `!=` compares object identity, which may not be intended.\n\n\n## Recommendation\nUsually, you should compare non-primitive objects, for example boxed primitive values, by using their `equals` methods.\n\n\n## Example\nWith the following definition, the method call `refEq(new Integer(2), new Integer(2))` returns `false` because the objects are not identical.\n\n\n```java\nboolean refEq(Integer i, Integer j) {\n\treturn i == j;\n}\n```\nWith the following definition, the method call `realEq(new Integer(2), new Integer(2))` returns `true` because the objects contain equal values.\n\n\n```java\nboolean realEq(Integer i, Integer j) {\n\treturn i.equals(j);\n}\n```\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 32. Addison-Wesley, 2005.\n* Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)), [Integer.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#equals(java.lang.Object)).\n* Common Weakness Enumeration: [CWE-595](https://cwe.mitre.org/data/definitions/595.html).\n","markdown":"# Reference equality test of boxed types\nComparing two boxed primitive values using `==` or `!=` compares object identity, which may not be intended.\n\n\n## Recommendation\nUsually, you should compare non-primitive objects, for example boxed primitive values, by using their `equals` methods.\n\n\n## Example\nWith the following definition, the method call `refEq(new Integer(2), new Integer(2))` returns `false` because the objects are not identical.\n\n\n```java\nboolean refEq(Integer i, Integer j) {\n\treturn i == j;\n}\n```\nWith the following definition, the method call `realEq(new Integer(2), new Integer(2))` returns `true` because the objects contain equal values.\n\n\n```java\nboolean realEq(Integer i, Integer j) {\n\treturn i.equals(j);\n}\n```\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 32. Addison-Wesley, 2005.\n* Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)), [Integer.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#equals(java.lang.Object)).\n* Common Weakness Enumeration: [CWE-595](https://cwe.mitre.org/data/definitions/595.html).\n"},"properties":{"tags":["reliability","correctness","external/cwe/cwe-595"],"description":"Comparing two boxed primitive values using the == or != operator\n              compares object identity, which may not be intended.","id":"java/reference-equality-of-boxed-types","kind":"problem","name":"Reference equality test of boxed types","precision":"very-high","problem.severity":"error"}},{"id":"java/unchecked-cast-in-equals","name":"java/unchecked-cast-in-equals","shortDescription":{"text":"Equals method does not inspect argument type"},"fullDescription":{"text":"An implementation of 'equals' that does not check the type of its argument may lead to failing casts."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Equals method does not inspect argument type\nAn implementation of `equals` must be able to handle an argument of any type, to avoid failing casts. Therefore, the implementation should inspect the type of its argument to see if the argument can be safely cast to the class in which the `equals` method is declared.\n\n\n## Recommendation\nUsually, an implementation of `equals` should check the type of its argument using `instanceof`, following the general pattern below.\n\n\n```java\nclass A {\n    // ...\n    public final boolean equals(Object obj) {\n        if (!(obj instanceof A)) {\n        \treturn false;\n        }\n        A a = (A)obj;\n        // ...further checks...\n    }\n    // ...\n}\n```\nUsing `instanceof` in this way has the added benefit that it includes a guard against null pointer exceptions: if `obj` is `null`, the check fails and `false` is returned. Therefore, after the check, it is guaranteed that `obj` is not `null`, and its fields can be safely accessed.\n\nWhenever you use `instanceof` to check the type of the argument, you should declare the `equals` method `final`, so that subclasses are unable to cause a violation of the symmetry requirement of the `equals` contract by further overriding `equals`.\n\nIf you want subclasses to redefine the notion of equality by overriding `equals`, use `getClass` instead of `instanceof` to check the type of the argument. However, note that the use of `getClass` prevents any equality relationship between instances of a class and its subclasses, even when no additional state is added in a subclass.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 8. Addison-Wesley, 2008.\n* Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n* Java Language Specification: [Type Comparison Operator instanceof](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.20.2).\n","markdown":"# Equals method does not inspect argument type\nAn implementation of `equals` must be able to handle an argument of any type, to avoid failing casts. Therefore, the implementation should inspect the type of its argument to see if the argument can be safely cast to the class in which the `equals` method is declared.\n\n\n## Recommendation\nUsually, an implementation of `equals` should check the type of its argument using `instanceof`, following the general pattern below.\n\n\n```java\nclass A {\n    // ...\n    public final boolean equals(Object obj) {\n        if (!(obj instanceof A)) {\n        \treturn false;\n        }\n        A a = (A)obj;\n        // ...further checks...\n    }\n    // ...\n}\n```\nUsing `instanceof` in this way has the added benefit that it includes a guard against null pointer exceptions: if `obj` is `null`, the check fails and `false` is returned. Therefore, after the check, it is guaranteed that `obj` is not `null`, and its fields can be safely accessed.\n\nWhenever you use `instanceof` to check the type of the argument, you should declare the `equals` method `final`, so that subclasses are unable to cause a violation of the symmetry requirement of the `equals` contract by further overriding `equals`.\n\nIf you want subclasses to redefine the notion of equality by overriding `equals`, use `getClass` instead of `instanceof` to check the type of the argument. However, note that the use of `getClass` prevents any equality relationship between instances of a class and its subclasses, even when no additional state is added in a subclass.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 8. Addison-Wesley, 2008.\n* Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n* Java Language Specification: [Type Comparison Operator instanceof](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.20.2).\n"},"properties":{"tags":["reliability","correctness"],"description":"An implementation of 'equals' that does not check the type\n              of its argument may lead to failing casts.","id":"java/unchecked-cast-in-equals","kind":"problem","name":"Equals method does not inspect argument type","precision":"high","problem.severity":"error"}},{"id":"java/equals-on-unrelated-types","name":"java/equals-on-unrelated-types","shortDescription":{"text":"Equals on incomparable types"},"fullDescription":{"text":"Calls of the form 'x.equals(y)', where the types of 'x' and 'y' are incomparable, should always return 'false'."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Equals on incomparable types\nCalls of the form `x.equals(y)`, where `x` and `y` have incomparable types, should always return `false` because the runtime types of `x` and `y` will be different. Two types are incomparable if they are distinct and do not have a common subtype.\n\n\n## Recommendation\nEnsure that such comparisons use comparable types.\n\n\n## Example\nIn the following example, the call to `equals` on line 5 refers to the whole array by mistake, instead of a specific element. Therefore, \"Value not found\" is returned.\n\n\n```java\nString[] anArray = new String[]{\"a\",\"b\",\"c\"}\nString valueToFind = \"b\";\n\nfor(int i=0; i<anArray.length; i++){\n  if(anArray.equals(valueToFind){    // anArray[i].equals(valueToFind) was intended\n    return \"Found value at index \" + i;\n  }\n}\n\nreturn \"Value not found\";\n```\n\n## References\n* Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n","markdown":"# Equals on incomparable types\nCalls of the form `x.equals(y)`, where `x` and `y` have incomparable types, should always return `false` because the runtime types of `x` and `y` will be different. Two types are incomparable if they are distinct and do not have a common subtype.\n\n\n## Recommendation\nEnsure that such comparisons use comparable types.\n\n\n## Example\nIn the following example, the call to `equals` on line 5 refers to the whole array by mistake, instead of a specific element. Therefore, \"Value not found\" is returned.\n\n\n```java\nString[] anArray = new String[]{\"a\",\"b\",\"c\"}\nString valueToFind = \"b\";\n\nfor(int i=0; i<anArray.length; i++){\n  if(anArray.equals(valueToFind){    // anArray[i].equals(valueToFind) was intended\n    return \"Found value at index \" + i;\n  }\n}\n\nreturn \"Value not found\";\n```\n\n## References\n* Java API Specification: [Object.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n"},"properties":{"tags":["reliability","correctness"],"description":"Calls of the form 'x.equals(y)', where the types of 'x' and 'y' are incomparable,\n              should always return 'false'.","id":"java/equals-on-unrelated-types","kind":"problem","name":"Equals on incomparable types","precision":"very-high","problem.severity":"error"}},{"id":"java/equals-on-arrays","name":"java/equals-on-arrays","shortDescription":{"text":"Equals or hashCode on arrays"},"fullDescription":{"text":"The 'equals' and 'hashCode' methods on arrays only consider object identity, not array contents, which is unlikely to be what is intended."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Equals or hashCode on arrays\nThe `equals` and `hashCode` methods on arrays only consider object identity, not array contents, which is unlikely to be what is intended.\n\n\n## Recommendation\nTo compare the lengths of the arrays and the corresponding pairs of elements in the arrays, use one of the comparison methods from `java.util.Arrays`:\n\n* The method `Arrays.equals` performs a shallow comparison. That is, array elements are compared using `equals`.\n* The method `Arrays.deepEquals` performs a deep comparison, which is appropriate for comparisons of nested arrays.\nSimilarly, `Arrays.hashCode` and `Arrays.deepHashCode` can be used to compute shallow and deep hash codes based on the hash codes of individual array elements.\n\n\n## Example\nIn the following example, the two arrays are first compared using the `Object.equals` method. Because this checks only reference equality and the two arrays are different objects, `Object.equals` returns `false`. The two arrays are then compared using the `Arrays.equals` method. Because this compares the length and contents of the arrays, `Arrays.equals` returns `true`.\n\n\n```java\npublic void arrayExample(){\n    String[] array1 = new String[]{\"a\", \"b\", \"c\"};\n    String[] array2 = new String[]{\"a\", \"b\", \"c\"};\n\n    // Reference equality tested: prints 'false'\n    System.out.println(array1.equals(array2));\n    \n    // Equality of array elements tested: prints 'true'\n    System.out.println(Arrays.equals(array1, array2));\n}\n```\n\n## References\n* Java API Specification: [Arrays.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#equals(java.lang.Object[],java.lang.Object[])), [Arrays.deepEquals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepEquals(java.lang.Object[],java.lang.Object[])), [Objects.deepEquals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#deepEquals(java.lang.Object,java.lang.Object)), [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)), [Arrays.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#hashCode(java.lang.Object[])), [Arrays.deepHashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepHashCode(java.lang.Object[])), [Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n","markdown":"# Equals or hashCode on arrays\nThe `equals` and `hashCode` methods on arrays only consider object identity, not array contents, which is unlikely to be what is intended.\n\n\n## Recommendation\nTo compare the lengths of the arrays and the corresponding pairs of elements in the arrays, use one of the comparison methods from `java.util.Arrays`:\n\n* The method `Arrays.equals` performs a shallow comparison. That is, array elements are compared using `equals`.\n* The method `Arrays.deepEquals` performs a deep comparison, which is appropriate for comparisons of nested arrays.\nSimilarly, `Arrays.hashCode` and `Arrays.deepHashCode` can be used to compute shallow and deep hash codes based on the hash codes of individual array elements.\n\n\n## Example\nIn the following example, the two arrays are first compared using the `Object.equals` method. Because this checks only reference equality and the two arrays are different objects, `Object.equals` returns `false`. The two arrays are then compared using the `Arrays.equals` method. Because this compares the length and contents of the arrays, `Arrays.equals` returns `true`.\n\n\n```java\npublic void arrayExample(){\n    String[] array1 = new String[]{\"a\", \"b\", \"c\"};\n    String[] array2 = new String[]{\"a\", \"b\", \"c\"};\n\n    // Reference equality tested: prints 'false'\n    System.out.println(array1.equals(array2));\n    \n    // Equality of array elements tested: prints 'true'\n    System.out.println(Arrays.equals(array1, array2));\n}\n```\n\n## References\n* Java API Specification: [Arrays.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#equals(java.lang.Object[],java.lang.Object[])), [Arrays.deepEquals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepEquals(java.lang.Object[],java.lang.Object[])), [Objects.deepEquals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#deepEquals(java.lang.Object,java.lang.Object)), [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)), [Arrays.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#hashCode(java.lang.Object[])), [Arrays.deepHashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepHashCode(java.lang.Object[])), [Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n"},"properties":{"tags":["reliability","correctness"],"description":"The 'equals' and 'hashCode' methods on arrays only consider object identity, not\n              array contents, which is unlikely to be what is intended.","id":"java/equals-on-arrays","kind":"problem","name":"Equals or hashCode on arrays","precision":"very-high","problem.severity":"error"}},{"id":"java/comparison-of-identical-expressions","name":"java/comparison-of-identical-expressions","shortDescription":{"text":"Comparison of identical values"},"fullDescription":{"text":"If the same expression occurs on both sides of a comparison operator, the operator is redundant, and probably indicates a mistake."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Comparison of identical values\nIf two identical expressions are compared (that is, checked for equality or inequality), this is typically an indication of a mistake, because the Boolean value of the comparison is always the same. Often, it indicates that the wrong qualifier has been used on a field access.\n\nAn exception applies to inequality (`!=`) and equality (`==`) tests of a floating point variable with itself: the special floating point value `NaN` (\"not-a-number\") is the only value that is not considered to be equal to itself. Thus, the test `x != x` where `x` is a `float` or `double` variable is equivalent to checking whether `x` is `NaN`, and similarly for `x == x`.\n\n\n## Recommendation\nIt is never good practice to compare a value with itself. If you require constant behavior, use the Boolean literals `true` and `false`, rather than encoding them obscurely as `1 == 1` or similar.\n\nIf an inequality test (using `!=`) of a floating point variable with itself is intentional, it should be replaced by `Double.isNaN(...)` or `Float.isNaN(...)` for readability. Similarly, if an equality test (using `==`) of a floating point variable with itself is intentional, it should be replaced by `!Double.isNaN(...)` or `!Float.isNaN(...)`.\n\n\n## Example\nIn the example below, the original version of `Customer` compares `id` with `id`, which always returns `true`. The corrected version of `Customer` includes the missing qualifier `o` in the comparison of `id` with `o.id`.\n\n\n```java\nclass Customer {\n\t...\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) return false;\n\t\tif (Customer.class != o.getClass()) return false;\n\t\tCustomer other = (Customer)o;\n\t\tif (!name.equals(o.name)) return false;\n\t\tif (id != id) return false;  // Comparison of identical values\n\t\treturn true;\n\t}\n}\n\nclass Customer {\n\t...\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) return false;\n\t\tif (Customer.class != o.getClass()) return false;\n\t\tCustomer other = (Customer)o;\n\t\tif (!name.equals(o.name)) return false;\n\t\tif (id != o.id) return false;  // Comparison corrected\n\t\treturn true;\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [15.21.1. Numerical Equality Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.1).\n","markdown":"# Comparison of identical values\nIf two identical expressions are compared (that is, checked for equality or inequality), this is typically an indication of a mistake, because the Boolean value of the comparison is always the same. Often, it indicates that the wrong qualifier has been used on a field access.\n\nAn exception applies to inequality (`!=`) and equality (`==`) tests of a floating point variable with itself: the special floating point value `NaN` (\"not-a-number\") is the only value that is not considered to be equal to itself. Thus, the test `x != x` where `x` is a `float` or `double` variable is equivalent to checking whether `x` is `NaN`, and similarly for `x == x`.\n\n\n## Recommendation\nIt is never good practice to compare a value with itself. If you require constant behavior, use the Boolean literals `true` and `false`, rather than encoding them obscurely as `1 == 1` or similar.\n\nIf an inequality test (using `!=`) of a floating point variable with itself is intentional, it should be replaced by `Double.isNaN(...)` or `Float.isNaN(...)` for readability. Similarly, if an equality test (using `==`) of a floating point variable with itself is intentional, it should be replaced by `!Double.isNaN(...)` or `!Float.isNaN(...)`.\n\n\n## Example\nIn the example below, the original version of `Customer` compares `id` with `id`, which always returns `true`. The corrected version of `Customer` includes the missing qualifier `o` in the comparison of `id` with `o.id`.\n\n\n```java\nclass Customer {\n\t...\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) return false;\n\t\tif (Customer.class != o.getClass()) return false;\n\t\tCustomer other = (Customer)o;\n\t\tif (!name.equals(o.name)) return false;\n\t\tif (id != id) return false;  // Comparison of identical values\n\t\treturn true;\n\t}\n}\n\nclass Customer {\n\t...\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) return false;\n\t\tif (Customer.class != o.getClass()) return false;\n\t\tCustomer other = (Customer)o;\n\t\tif (!name.equals(o.name)) return false;\n\t\tif (id != o.id) return false;  // Comparison corrected\n\t\treturn true;\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [15.21.1. Numerical Equality Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.1).\n"},"properties":{"tags":["reliability","correctness","logic"],"description":"If the same expression occurs on both sides of a comparison\n              operator, the operator is redundant, and probably indicates a mistake.","id":"java/comparison-of-identical-expressions","kind":"problem","name":"Comparison of identical values","precision":"very-high","problem.severity":"error"}},{"id":"java/comparison-with-nan","name":"java/comparison-with-nan","shortDescription":{"text":"Wrong NaN comparison"},"fullDescription":{"text":"A comparison with 'NaN' using '==' or '!=' will always yield the same result and is unlikely to be intended."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Wrong NaN comparison\nThe special floating-point number `NaN` is defined to be different from all other floating-point numbers, including itself, when compared using the equality operators, `==` and `!=`.\n\n\n## Recommendation\nTo check whether a variable `x` is `NaN` use the method `isNaN` that is defined on both `java.lang.Float` and `java.lang.Double`.\n\n\n## Example\nThe expression `x == Double.NaN` is always false. This expression should be replaced by `Double.isNaN(x)`, which accurately identifies whether `x` is equal to `Double.NaN`.\n\n\n## References\n* Java Language Specification: [Numerical Equality Operators == and !=](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.1).\n","markdown":"# Wrong NaN comparison\nThe special floating-point number `NaN` is defined to be different from all other floating-point numbers, including itself, when compared using the equality operators, `==` and `!=`.\n\n\n## Recommendation\nTo check whether a variable `x` is `NaN` use the method `isNaN` that is defined on both `java.lang.Float` and `java.lang.Double`.\n\n\n## Example\nThe expression `x == Double.NaN` is always false. This expression should be replaced by `Double.isNaN(x)`, which accurately identifies whether `x` is equal to `Double.NaN`.\n\n\n## References\n* Java Language Specification: [Numerical Equality Operators == and !=](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.1).\n"},"properties":{"tags":["correctness"],"description":"A comparison with 'NaN' using '==' or '!=' will always yield the same result\n              and is unlikely to be intended.","id":"java/comparison-with-nan","kind":"problem","name":"Wrong NaN comparison","precision":"very-high","problem.severity":"error"}},{"id":"java/constant-comparison","name":"java/constant-comparison","shortDescription":{"text":"Useless comparison test"},"fullDescription":{"text":"A comparison operation that always evaluates to true or always evaluates to false may indicate faulty logic and may result in dead code."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Useless comparison test\nThe result of certain comparison tests can sometimes be inferred from their context and the results of other comparisons. This can be an indication of faulty logic and may result in dead code or infinite loops if, for example, a loop condition never changes its value.\n\n\n## Recommendation\nInspect the code to check whether the logic is correct, and consider simplifying the logical expression.\n\n\n## Example\nIn the following example the final test on `x` will always be `true`, and thus the condition is redundant and potentially wrong. If the \"do more stuff\" part is intended to always execute after the loop then the condition should be removed to make this clear.\n\n\n```java\nvoid method(int x) {\n\twhile(x >= 0) {\n\t\t// do stuff\n\t\tx--;\n\t}\n\tif (x < 0) { // BAD: always true\n\t\t// do more stuff\n\t}\n}\n```\n\n## References\n* Java Language Specification: [The if Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.9).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n","markdown":"# Useless comparison test\nThe result of certain comparison tests can sometimes be inferred from their context and the results of other comparisons. This can be an indication of faulty logic and may result in dead code or infinite loops if, for example, a loop condition never changes its value.\n\n\n## Recommendation\nInspect the code to check whether the logic is correct, and consider simplifying the logical expression.\n\n\n## Example\nIn the following example the final test on `x` will always be `true`, and thus the condition is redundant and potentially wrong. If the \"do more stuff\" part is intended to always execute after the loop then the condition should be removed to make this clear.\n\n\n```java\nvoid method(int x) {\n\twhile(x >= 0) {\n\t\t// do stuff\n\t\tx--;\n\t}\n\tif (x < 0) { // BAD: always true\n\t\t// do more stuff\n\t}\n}\n```\n\n## References\n* Java Language Specification: [The if Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.9).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"},"properties":{"tags":["correctness","logic","external/cwe/cwe-570","external/cwe/cwe-571"],"description":"A comparison operation that always evaluates to true or always\n              evaluates to false may indicate faulty logic and may result in\n              dead code.","id":"java/constant-comparison","kind":"problem","name":"Useless comparison test","precision":"very-high","problem.severity":"warning"}},{"id":"java/inconsistent-equals-and-hashcode","name":"java/inconsistent-equals-and-hashcode","shortDescription":{"text":"Inconsistent equals and hashCode"},"fullDescription":{"text":"If a class overrides only one of 'equals' and 'hashCode', it may mean that 'equals' and 'hashCode' are inconsistent."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Inconsistent equals and hashCode\nA class that overrides only one of `equals` and `hashCode` is likely to violate the contract of the `hashCode` method. The contract requires that `hashCode` gives the same integer result for any two equal objects. Not enforcing this property may cause unexpected results when storing and retrieving objects of such a class in a hashing data structure.\n\n\n## Recommendation\nUsually, both methods should be overridden to ensure that they are consistent.\n\n\n## Example\nIn the following example, the class `InconsistentEqualsHashCode` overrides `hashCode` but not `equals`.\n\n\n```java\npublic class InconsistentEqualsHashCode {\n\tprivate int i = 0;\n\tpublic InconsistentEqualsHashCode(int i) {\n\t\tthis.i = i;\n\t}\n\n\tpublic int hashCode() {\n\t\treturn i;\n\t}\n}\n```\nIn the following example, the class `InconsistentEqualsHashCodeFix` overrides both `hashCode` and `equals`.\n\n\n```java\npublic class InconsistentEqualsHashCodeFix {\n\tprivate int i = 0;\n\tpublic InconsistentEqualsHashCodeFix(int i) {\n\t\tthis.i = i;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn i;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tInconsistentEqualsHashCodeFix that = (InconsistentEqualsHashCodeFix) obj;\n\t\treturn this.i == that.i;\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 9. Addison-Wesley, 2008.\n* Java API Specification: [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)), [Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n* IBM developerWorks: [Java theory and practice: Hashing it out](https://www.ibm.com/developerworks/java/library/j-jtp05273/index.html).\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-581](https://cwe.mitre.org/data/definitions/581.html).\n","markdown":"# Inconsistent equals and hashCode\nA class that overrides only one of `equals` and `hashCode` is likely to violate the contract of the `hashCode` method. The contract requires that `hashCode` gives the same integer result for any two equal objects. Not enforcing this property may cause unexpected results when storing and retrieving objects of such a class in a hashing data structure.\n\n\n## Recommendation\nUsually, both methods should be overridden to ensure that they are consistent.\n\n\n## Example\nIn the following example, the class `InconsistentEqualsHashCode` overrides `hashCode` but not `equals`.\n\n\n```java\npublic class InconsistentEqualsHashCode {\n\tprivate int i = 0;\n\tpublic InconsistentEqualsHashCode(int i) {\n\t\tthis.i = i;\n\t}\n\n\tpublic int hashCode() {\n\t\treturn i;\n\t}\n}\n```\nIn the following example, the class `InconsistentEqualsHashCodeFix` overrides both `hashCode` and `equals`.\n\n\n```java\npublic class InconsistentEqualsHashCodeFix {\n\tprivate int i = 0;\n\tpublic InconsistentEqualsHashCodeFix(int i) {\n\t\tthis.i = i;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn i;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tInconsistentEqualsHashCodeFix that = (InconsistentEqualsHashCodeFix) obj;\n\t\treturn this.i == that.i;\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 9. Addison-Wesley, 2008.\n* Java API Specification: [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)), [Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n* IBM developerWorks: [Java theory and practice: Hashing it out](https://www.ibm.com/developerworks/java/library/j-jtp05273/index.html).\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-581](https://cwe.mitre.org/data/definitions/581.html).\n"},"properties":{"tags":["reliability","correctness","external/cwe/cwe-581"],"description":"If a class overrides only one of 'equals' and 'hashCode', it may mean that\n              'equals' and 'hashCode' are inconsistent.","id":"java/inconsistent-equals-and-hashcode","kind":"problem","name":"Inconsistent equals and hashCode","precision":"very-high","problem.severity":"error"}},{"id":"java/hashing-without-hashcode","name":"java/hashing-without-hashcode","shortDescription":{"text":"Hashed value without hashCode definition"},"fullDescription":{"text":"Classes that define an 'equals' method but no 'hashCode' method, and whose instances are stored in a hashing data structure, can lead to unexpected results."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Hashed value without hashCode definition\nClasses that define an `equals` method but no `hashCode` method can lead to unexpected results if instances of those classes are stored in a hashing data structure. Hashing data structures expect that hash codes fulfill the contract that two objects that `equals` considers equal should have the same hash code. This contract is likely to be violated by such classes.\n\n\n## Recommendation\nEvery class that implements a custom `equals` method should also provide an implementation of `hashCode`.\n\n\n## Example\nIn the following example, class `Point` has no implementation of `hashCode`. Calling `hashCode` on two distinct `Point` objects with the same coordinates would probably result in different hash codes. This would violate the contract of the `hashCode` method, in which case objects of type `Point` should not be stored in hashing data structures.\n\n\n```java\nclass Point {\n    int x;\n    int y;\n\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public boolean equals(Object o) {\n    \tif (!(o instanceof Point)) return false;\n    \tPoint q = (Point)o;\n    \treturn x == q.x && y == q.y;\n    }\n}\n```\nIn the modification of the above example, the implementation of `hashCode` for class `Point` is suitable because the hash code is computed from exactly the same fields that are considered in the `equals` method. Therefore, the contract of the `hashCode` method is fulfilled.\n\n\n```java\nclass Point {\n    int x;\n    int y;\n\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public boolean equals(Object o) {\n        if (!(o instanceof Point)) return false;\n        Point q = (Point)o;\n        return x == q.x && y == q.y;\n    }\n\n    // Implement hashCode so that equivalent points (with the same values of x and y) have the\n    // same hash code\n    public int hashCode() {\n        int hash = 7;\n        hash = 31*hash + x;\n        hash = 31*hash + y;\n        return hash;\n    }\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 9. Addison-Wesley, 2008.\n* Java API Specification: [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)), [Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n* IBM developerWorks: [Java theory and practice: Hashing it out](https://www.ibm.com/developerworks/java/library/j-jtp05273/index.html).\n","markdown":"# Hashed value without hashCode definition\nClasses that define an `equals` method but no `hashCode` method can lead to unexpected results if instances of those classes are stored in a hashing data structure. Hashing data structures expect that hash codes fulfill the contract that two objects that `equals` considers equal should have the same hash code. This contract is likely to be violated by such classes.\n\n\n## Recommendation\nEvery class that implements a custom `equals` method should also provide an implementation of `hashCode`.\n\n\n## Example\nIn the following example, class `Point` has no implementation of `hashCode`. Calling `hashCode` on two distinct `Point` objects with the same coordinates would probably result in different hash codes. This would violate the contract of the `hashCode` method, in which case objects of type `Point` should not be stored in hashing data structures.\n\n\n```java\nclass Point {\n    int x;\n    int y;\n\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public boolean equals(Object o) {\n    \tif (!(o instanceof Point)) return false;\n    \tPoint q = (Point)o;\n    \treturn x == q.x && y == q.y;\n    }\n}\n```\nIn the modification of the above example, the implementation of `hashCode` for class `Point` is suitable because the hash code is computed from exactly the same fields that are considered in the `equals` method. Therefore, the contract of the `hashCode` method is fulfilled.\n\n\n```java\nclass Point {\n    int x;\n    int y;\n\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public boolean equals(Object o) {\n        if (!(o instanceof Point)) return false;\n        Point q = (Point)o;\n        return x == q.x && y == q.y;\n    }\n\n    // Implement hashCode so that equivalent points (with the same values of x and y) have the\n    // same hash code\n    public int hashCode() {\n        int hash = 7;\n        hash = 31*hash + x;\n        hash = 31*hash + y;\n        return hash;\n    }\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 9. Addison-Wesley, 2008.\n* Java API Specification: [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)), [Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n* IBM developerWorks: [Java theory and practice: Hashing it out](https://www.ibm.com/developerworks/java/library/j-jtp05273/index.html).\n"},"properties":{"tags":["reliability","correctness"],"description":"Classes that define an 'equals' method but no 'hashCode' method, and whose instances\n              are stored in a hashing data structure, can lead to unexpected results.","id":"java/hashing-without-hashcode","kind":"problem","name":"Hashed value without hashCode definition","precision":"very-high","problem.severity":"error"}},{"id":"java/misleading-indentation","name":"java/misleading-indentation","shortDescription":{"text":"Misleading indentation"},"fullDescription":{"text":"If a control structure does not use braces, misleading indentation makes it difficult to see which statements are within its scope."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Misleading indentation\nA control structure (an `if` statement or a loop) has a body that is either a block of statements surrounded by curly braces or a single statement.\n\nIf you omit braces, it is particularly important to ensure that the indentation of the code matches the control flow of the code.\n\n\n## Recommendation\nIt is usually considered good practice to include braces for all control structures in Java. This is because it makes it easier to maintain the code later. For example, it's easy to see at a glance which part of the code is in the scope of an `if` statement, and adding more statements to the body of the `if` statement is less error-prone.\n\nYou should also ensure that the indentation of the code is consistent with the actual flow of control, so that it does not confuse programmers.\n\n\n## Example\nIn the example below, the original version of `Cart` is missing braces. This means that the code triggers a `NullPointerException` at runtime if `i` is `null`.\n\n\n```java\nclass Cart {\n    Map<Integer, Integer> items = ...\n    public void addItem(Item i) {\n        // No braces and misleading indentation.\n        if (i != null)\n            log(\"Adding item: \" + i);\n            // Indentation suggests that the following statements\n            // are in the body of the 'if'.\n            Integer curQuantity = items.get(i.getID());\n            if (curQuantity == null) curQuantity = 0;\n            items.put(i.getID(), curQuantity+1);\n    }\n}\n```\nThe corrected version of `Cart` does include braces, so that the code executes as the indentation suggests.\n\n\n```java\nclass Cart {\n    Map<Integer, Integer> items = ...\n    public void addItem(Item i) {\n        // Braces included.\n        if (i != null) {\n            log(\"Adding item: \" + i);\n            Integer curQuantity = items.get(i.getID());\n            if (curQuantity == null) curQuantity = 0;\n            items.put(i.getID(), curQuantity+1);\n        }\n    }\n}\n```\nIn the following example the indentation may or may not be misleading depending on your tab width settings. As such, mixing tabs and spaces in this way is not recommended, since what looks fine in one context can be very misleading in another.\n\n\n```java\n// Tab width 8\n        if (b)       // Indentation: 1 tab\n                f(); // Indentation: 2 tabs\n        g();         // Indentation: 8 spaces\n\n// Tab width 4\n    if (b)   // Indentation: 1 tab\n        f(); // Indentation: 2 tabs\n        g(); // Indentation: 8 spaces\n```\nIf you mix tabs and spaces in this way, then you might get seemingly false positives, since your tab width settings cannot be taken into account.\n\n\n## References\n* Java SE Documentation: [Compound Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#15395).\n* Wikipedia: [Indentation style](https://en.wikipedia.org/wiki/Indentation_style).\n","markdown":"# Misleading indentation\nA control structure (an `if` statement or a loop) has a body that is either a block of statements surrounded by curly braces or a single statement.\n\nIf you omit braces, it is particularly important to ensure that the indentation of the code matches the control flow of the code.\n\n\n## Recommendation\nIt is usually considered good practice to include braces for all control structures in Java. This is because it makes it easier to maintain the code later. For example, it's easy to see at a glance which part of the code is in the scope of an `if` statement, and adding more statements to the body of the `if` statement is less error-prone.\n\nYou should also ensure that the indentation of the code is consistent with the actual flow of control, so that it does not confuse programmers.\n\n\n## Example\nIn the example below, the original version of `Cart` is missing braces. This means that the code triggers a `NullPointerException` at runtime if `i` is `null`.\n\n\n```java\nclass Cart {\n    Map<Integer, Integer> items = ...\n    public void addItem(Item i) {\n        // No braces and misleading indentation.\n        if (i != null)\n            log(\"Adding item: \" + i);\n            // Indentation suggests that the following statements\n            // are in the body of the 'if'.\n            Integer curQuantity = items.get(i.getID());\n            if (curQuantity == null) curQuantity = 0;\n            items.put(i.getID(), curQuantity+1);\n    }\n}\n```\nThe corrected version of `Cart` does include braces, so that the code executes as the indentation suggests.\n\n\n```java\nclass Cart {\n    Map<Integer, Integer> items = ...\n    public void addItem(Item i) {\n        // Braces included.\n        if (i != null) {\n            log(\"Adding item: \" + i);\n            Integer curQuantity = items.get(i.getID());\n            if (curQuantity == null) curQuantity = 0;\n            items.put(i.getID(), curQuantity+1);\n        }\n    }\n}\n```\nIn the following example the indentation may or may not be misleading depending on your tab width settings. As such, mixing tabs and spaces in this way is not recommended, since what looks fine in one context can be very misleading in another.\n\n\n```java\n// Tab width 8\n        if (b)       // Indentation: 1 tab\n                f(); // Indentation: 2 tabs\n        g();         // Indentation: 8 spaces\n\n// Tab width 4\n    if (b)   // Indentation: 1 tab\n        f(); // Indentation: 2 tabs\n        g(); // Indentation: 8 spaces\n```\nIf you mix tabs and spaces in this way, then you might get seemingly false positives, since your tab width settings cannot be taken into account.\n\n\n## References\n* Java SE Documentation: [Compound Statements](https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#15395).\n* Wikipedia: [Indentation style](https://en.wikipedia.org/wiki/Indentation_style).\n"},"properties":{"tags":["maintainability","correctness","logic"],"description":"If a control structure does not use braces, misleading indentation makes it\n              difficult to see which statements are within its scope.","id":"java/misleading-indentation","kind":"problem","name":"Misleading indentation","precision":"very-high","problem.severity":"warning"}},{"id":"java/unreachable-catch-clause","name":"java/unreachable-catch-clause","shortDescription":{"text":"Unreachable catch clause"},"fullDescription":{"text":"An unreachable 'catch' clause may indicate a mistake in exception handling or may be unnecessary."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unreachable catch clause\nAn unreachable `catch` clause may indicate a logical mistake in the exception handling code or may simply be unnecessary.\n\nAlthough certain unreachable `catch` clauses cause a compiler error, there are also unreachable `catch` clauses that do not cause a compiler error. A `catch` clause `C` is considered reachable by the compiler if both of the following conditions are true:\n\n* A checked exception that is thrown in the `try` block is assignable to the parameter of `C`.\n* There is no previous `catch` clause whose parameter type is equal to, or a supertype of, the parameter type of `C`.\nHowever, a `catch` clause that is considered reachable by the compiler can be unreachable if both of the following conditions are true:\n\n* The `catch` clause's parameter type `E` does not include any unchecked exceptions.\n* All exceptions that are thrown in the `try` block whose type is a (strict) subtype of `E` are already handled by previous `catch` clauses.\n\n## Recommendation\nEnsure that unreachable `catch` clauses are removed or that further corrections are made to make them reachable.\n\nNote that if a `try-catch` statement contains multiple `catch` clauses, and an exception that is thrown in the `try` block matches more than one of the `catch` clauses, only the first matching clause is executed.\n\n\n## Example\nIn the following example, the second `catch` clause is unreachable. The code is incomplete because a `FileOutputStream` is opened but no methods are called to write to the stream. Such methods typically throw `IOException`s, which would make the second `catch` clause reachable.\n\n\n```java\nFileOutputStream fos = null;\ntry {\n\tfos = new FileOutputStream(new File(\"may_not_exist.txt\"));\n} catch (FileNotFoundException e) {\n\t// ask the user and try again\n} catch (IOException e) {\n\t// more serious, abort\n} finally {\n\tif (fos!=null) { try { fos.close(); } catch (IOException e) { /*ignore*/ } }\n}\n```\n\n## References\n* Java Language Specification: [Execution of try-catch](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.1), [Unreachable Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.21).\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n","markdown":"# Unreachable catch clause\nAn unreachable `catch` clause may indicate a logical mistake in the exception handling code or may simply be unnecessary.\n\nAlthough certain unreachable `catch` clauses cause a compiler error, there are also unreachable `catch` clauses that do not cause a compiler error. A `catch` clause `C` is considered reachable by the compiler if both of the following conditions are true:\n\n* A checked exception that is thrown in the `try` block is assignable to the parameter of `C`.\n* There is no previous `catch` clause whose parameter type is equal to, or a supertype of, the parameter type of `C`.\nHowever, a `catch` clause that is considered reachable by the compiler can be unreachable if both of the following conditions are true:\n\n* The `catch` clause's parameter type `E` does not include any unchecked exceptions.\n* All exceptions that are thrown in the `try` block whose type is a (strict) subtype of `E` are already handled by previous `catch` clauses.\n\n## Recommendation\nEnsure that unreachable `catch` clauses are removed or that further corrections are made to make them reachable.\n\nNote that if a `try-catch` statement contains multiple `catch` clauses, and an exception that is thrown in the `try` block matches more than one of the `catch` clauses, only the first matching clause is executed.\n\n\n## Example\nIn the following example, the second `catch` clause is unreachable. The code is incomplete because a `FileOutputStream` is opened but no methods are called to write to the stream. Such methods typically throw `IOException`s, which would make the second `catch` clause reachable.\n\n\n```java\nFileOutputStream fos = null;\ntry {\n\tfos = new FileOutputStream(new File(\"may_not_exist.txt\"));\n} catch (FileNotFoundException e) {\n\t// ask the user and try again\n} catch (IOException e) {\n\t// more serious, abort\n} finally {\n\tif (fos!=null) { try { fos.close(); } catch (IOException e) { /*ignore*/ } }\n}\n```\n\n## References\n* Java Language Specification: [Execution of try-catch](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.1), [Unreachable Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.21).\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"},"properties":{"tags":["reliability","correctness","exceptions","external/cwe/cwe-561"],"description":"An unreachable 'catch' clause may indicate a mistake in exception handling or may\n              be unnecessary.","id":"java/unreachable-catch-clause","kind":"problem","name":"Unreachable catch clause","precision":"high","problem.severity":"warning"}},{"id":"java/continue-in-false-loop","name":"java/continue-in-false-loop","shortDescription":{"text":"Continue statement that does not continue"},"fullDescription":{"text":"A 'continue' statement only re-runs the loop if the loop-condition is true. Therefore using 'continue' in a loop with a constant false condition is misleading and usually a bug."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Continue statement that does not continue\nA `continue` statement only re-runs the loop if the loop condition is true. Therefore using `continue` in a loop with a constant false condition will never cause the loop body to be re-run, which is misleading.\n\n\n## Recommendation\nReplace the `continue` statement with a `break` statement if the intent is to break from the loop.\n\n\n## References\n* Java Language Specification: [14.13 The do Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.13).\n","markdown":"# Continue statement that does not continue\nA `continue` statement only re-runs the loop if the loop condition is true. Therefore using `continue` in a loop with a constant false condition will never cause the loop body to be re-run, which is misleading.\n\n\n## Recommendation\nReplace the `continue` statement with a `break` statement if the intent is to break from the loop.\n\n\n## References\n* Java Language Specification: [14.13 The do Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.13).\n"},"properties":{"tags":["correctness"],"description":"A 'continue' statement only re-runs the loop if the\n              loop-condition is true. Therefore using 'continue' in a loop\n              with a constant false condition is misleading and usually a\n              bug.","id":"java/continue-in-false-loop","kind":"problem","name":"Continue statement that does not continue","precision":"high","problem.severity":"warning"}},{"id":"java/constant-loop-condition","name":"java/constant-loop-condition","shortDescription":{"text":"Constant loop condition"},"fullDescription":{"text":"A loop condition that remains constant throughout the iteration indicates faulty logic and is likely to cause infinite looping."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Constant loop condition\nLoops can contain multiple exit conditions, either directly in the loop condition or as guards around `break` or `return` statements. If none of the exit conditions can ever be satisfied, then the loop will never terminate.\n\n\n## Recommendation\nWhen writing a loop that is intended to terminate, make sure that all the necessary exit conditions can be satisfied and that loop termination is clear.\n\n\n## Example\nThe following example searches for a field of a given name, and intends to throw an exception if the field cannot be found. However, if the field cannot be found, the double loop structure means that the exit conditions will never be met, resulting in an infinite loop.\n\n\n```java\nObject getField(Object obj, String name) throws NoSuchFieldError {\n  Class clazz = obj.getClass();\n  while (clazz != null) {\n    for (Field f : clazz.getDeclaredFields()) {\n      if (f.getName().equals(name)) {\n        f.setAccessible(true);\n        return f.get(obj);\n      }\n    }\n  }\n  throw new NoSuchFieldError(name);\n}\n\n```\nThe solution is to rewrite the code as follows using an `if`-statement.\n\n\n```java\nObject getField(Object obj, String name) throws NoSuchFieldError {\n  Class clazz = obj.getClass();\n  if (clazz != null) {\n    for (Field f : clazz.getDeclaredFields()) {\n      if (f.getName().equals(name)) {\n        f.setAccessible(true);\n        return f.get(obj);\n      }\n    }\n  }\n  throw new NoSuchFieldError(name);\n}\n\n```\n\n## References\n* Java Language Specification: [Blocks and Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html).\n* Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).\n","markdown":"# Constant loop condition\nLoops can contain multiple exit conditions, either directly in the loop condition or as guards around `break` or `return` statements. If none of the exit conditions can ever be satisfied, then the loop will never terminate.\n\n\n## Recommendation\nWhen writing a loop that is intended to terminate, make sure that all the necessary exit conditions can be satisfied and that loop termination is clear.\n\n\n## Example\nThe following example searches for a field of a given name, and intends to throw an exception if the field cannot be found. However, if the field cannot be found, the double loop structure means that the exit conditions will never be met, resulting in an infinite loop.\n\n\n```java\nObject getField(Object obj, String name) throws NoSuchFieldError {\n  Class clazz = obj.getClass();\n  while (clazz != null) {\n    for (Field f : clazz.getDeclaredFields()) {\n      if (f.getName().equals(name)) {\n        f.setAccessible(true);\n        return f.get(obj);\n      }\n    }\n  }\n  throw new NoSuchFieldError(name);\n}\n\n```\nThe solution is to rewrite the code as follows using an `if`-statement.\n\n\n```java\nObject getField(Object obj, String name) throws NoSuchFieldError {\n  Class clazz = obj.getClass();\n  if (clazz != null) {\n    for (Field f : clazz.getDeclaredFields()) {\n      if (f.getName().equals(name)) {\n        f.setAccessible(true);\n        return f.get(obj);\n      }\n    }\n  }\n  throw new NoSuchFieldError(name);\n}\n\n```\n\n## References\n* Java Language Specification: [Blocks and Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html).\n* Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).\n"},"properties":{"tags":["correctness","external/cwe/cwe-835"],"description":"A loop condition that remains constant throughout the iteration\n              indicates faulty logic and is likely to cause infinite\n              looping.","id":"java/constant-loop-condition","kind":"problem","name":"Constant loop condition","precision":"very-high","problem.severity":"warning"}},{"id":"java/whitespace-contradicts-precedence","name":"java/whitespace-contradicts-precedence","shortDescription":{"text":"Whitespace contradicts operator precedence"},"fullDescription":{"text":"Nested expressions where the formatting contradicts the grouping enforced by operator precedence are difficult to read and may even indicate a bug."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Whitespace contradicts operator precedence\nNested expressions where the spacing around operators suggests a different grouping than that imposed by the Java operator precedence rules are problematic: they could indicate a bug where the author of the code misunderstood the precedence rules. Even if there is no a bug, the spacing could be confusing to people who read the code.\n\n\n## Recommendation\nMake sure that the spacing around operators reflects operator precedence, or use parentheses to clarify grouping.\n\n\n## Example\nConsider the following piece of code for allocating an array:\n\n```\n\n    int[] buf = new int[capacity + capacity>>1];\n\n```\nHere, the spacing around `+` and `>>` suggests the grouping `capacity + (capacity>>1)`, that is, the allocated array should be 50% larger than the given capacity.\n\nIn fact, however, `+` has higher precedence than `>>`, so this code allocates an array of size `(capacity + capacity) >> 1`, which is the same as `capacity`.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.\n* Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).\n","markdown":"# Whitespace contradicts operator precedence\nNested expressions where the spacing around operators suggests a different grouping than that imposed by the Java operator precedence rules are problematic: they could indicate a bug where the author of the code misunderstood the precedence rules. Even if there is no a bug, the spacing could be confusing to people who read the code.\n\n\n## Recommendation\nMake sure that the spacing around operators reflects operator precedence, or use parentheses to clarify grouping.\n\n\n## Example\nConsider the following piece of code for allocating an array:\n\n```\n\n    int[] buf = new int[capacity + capacity>>1];\n\n```\nHere, the spacing around `+` and `>>` suggests the grouping `capacity + (capacity>>1)`, that is, the allocated array should be 50% larger than the given capacity.\n\nIn fact, however, `+` has higher precedence than `>>`, so this code allocates an array of size `(capacity + capacity) >> 1`, which is the same as `capacity`.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.\n* Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).\n"},"properties":{"tags":["maintainability","readability","external/cwe/cwe-783"],"description":"Nested expressions where the formatting contradicts the grouping enforced by operator precedence\n              are difficult to read and may even indicate a bug.","id":"java/whitespace-contradicts-precedence","kind":"problem","name":"Whitespace contradicts operator precedence","precision":"very-high","problem.severity":"warning"}},{"id":"java/implicit-cast-in-compound-assignment","name":"java/implicit-cast-in-compound-assignment","shortDescription":{"text":"Implicit narrowing conversion in compound assignment"},"fullDescription":{"text":"Compound assignment statements (for example 'intvar += longvar') that implicitly cast a value of a wider type to a narrower type may result in information loss and numeric errors such as overflows."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Implicit narrowing conversion in compound assignment\nCompound assignment statements of the form `x += y` or `x *= y` perform an implicit narrowing conversion if the type of `x` is narrower than the type of `y`. For example, `x += y` is equivalent to `x = (T)(x + y)`, where `T` is the type of `x`. This can result in information loss and numeric errors such as overflows.\n\n\n## Recommendation\nEnsure that the type of the left-hand side of the compound assignment statement is at least as wide as the type of the right-hand side.\n\n\n## Example\nIf `x` is of type `short` and `y` is of type `int`, the expression `x + y` is of type `int`. However, the expression `x += y` is equivalent to `x = (short) (x + y)`. The expression `x + y` is cast to the type of the left-hand side of the assignment: `short`, possibly leading to information loss.\n\nTo avoid implicitly narrowing the type of `x + y`, change the type of `x` to `int`. Then the types of `x` and `x + y` are both `int` and there is no need for an implicit cast.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 9. Addison-Wesley, 2005.\n* Java Language Specification: [Compound Assignment Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.26.2), [Narrowing Primitive Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.3).\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-192](https://cwe.mitre.org/data/definitions/192.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n","markdown":"# Implicit narrowing conversion in compound assignment\nCompound assignment statements of the form `x += y` or `x *= y` perform an implicit narrowing conversion if the type of `x` is narrower than the type of `y`. For example, `x += y` is equivalent to `x = (T)(x + y)`, where `T` is the type of `x`. This can result in information loss and numeric errors such as overflows.\n\n\n## Recommendation\nEnsure that the type of the left-hand side of the compound assignment statement is at least as wide as the type of the right-hand side.\n\n\n## Example\nIf `x` is of type `short` and `y` is of type `int`, the expression `x + y` is of type `int`. However, the expression `x += y` is equivalent to `x = (short) (x + y)`. The expression `x + y` is cast to the type of the left-hand side of the assignment: `short`, possibly leading to information loss.\n\nTo avoid implicitly narrowing the type of `x + y`, change the type of `x` to `int`. Then the types of `x` and `x + y` are both `int` and there is no need for an implicit cast.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 9. Addison-Wesley, 2005.\n* Java Language Specification: [Compound Assignment Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.26.2), [Narrowing Primitive Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.3).\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-192](https://cwe.mitre.org/data/definitions/192.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-190","external/cwe/cwe-192","external/cwe/cwe-197","external/cwe/cwe-681"],"description":"Compound assignment statements (for example 'intvar += longvar') that implicitly\n              cast a value of a wider type to a narrower type may result in information loss and\n              numeric errors such as overflows.","id":"java/implicit-cast-in-compound-assignment","kind":"problem","name":"Implicit narrowing conversion in compound assignment","precision":"very-high","problem.severity":"warning","security-severity":"8.1"}},{"id":"java/lshift-larger-than-type-width","name":"java/lshift-larger-than-type-width","shortDescription":{"text":"Left shift by more than the type width"},"fullDescription":{"text":"Left-shifting an integer by more than its type width indicates a mistake."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Left shift by more than the type width\nThe maximum shift distance used for left-shift operations is determined by the promoted type of its left-hand side. When the promoted type is `int` only the lowest 5 bits of the right-hand side are used as the shift distance. When the promoted type is `long` the lowest 6 bits of the right-hand side are used.\n\n\n## Recommendation\nRestrict the amount that you shift any `int` to the range 0-31, or cast it to `long` before applying the left shift.\n\n\n## Example\nThe following line tries to left-shift an `int` by 32 bits.\n\n\n```java\nlong longVal = intVal << 32; // BAD\n```\nHowever, left-shifting an `int` by 32 bits is equivalent to left-shifting it by 0 bits, that is, no shift is applied. Instead the value should be cast to `long` before the shift is applied. Then the left-shift of 32 bits will work.\n\n\n```java\nlong longVal = ((long)intVal) << 32; // GOOD\n```\n\n## References\n* Java Language Specification: [Shift Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.19).\n","markdown":"# Left shift by more than the type width\nThe maximum shift distance used for left-shift operations is determined by the promoted type of its left-hand side. When the promoted type is `int` only the lowest 5 bits of the right-hand side are used as the shift distance. When the promoted type is `long` the lowest 6 bits of the right-hand side are used.\n\n\n## Recommendation\nRestrict the amount that you shift any `int` to the range 0-31, or cast it to `long` before applying the left shift.\n\n\n## Example\nThe following line tries to left-shift an `int` by 32 bits.\n\n\n```java\nlong longVal = intVal << 32; // BAD\n```\nHowever, left-shifting an `int` by 32 bits is equivalent to left-shifting it by 0 bits, that is, no shift is applied. Instead the value should be cast to `long` before the shift is applied. Then the left-shift of 32 bits will work.\n\n\n```java\nlong longVal = ((long)intVal) << 32; // GOOD\n```\n\n## References\n* Java Language Specification: [Shift Operators](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.19).\n"},"properties":{"tags":["correctness"],"description":"Left-shifting an integer by more than its type width indicates a mistake.","id":"java/lshift-larger-than-type-width","kind":"problem","name":"Left shift by more than the type width","precision":"very-high","problem.severity":"warning"}},{"id":"java/evaluation-to-constant","name":"java/evaluation-to-constant","shortDescription":{"text":"Expression always evaluates to the same value"},"fullDescription":{"text":"An expression that always evaluates to the same value, but which has a non-constant subexpression, indicates a mistake."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Expression always evaluates to the same value\nSome expressions always evaluate to the same result, no matter what their subexpressions are:\n\n* `x * 0` always evaluates to `0`.\n* `x % 1` always evaluates to `0`.\n* `x & 0` always evaluates to `0`.\n* `x || true` always evaluates to `true`.\n* `x && false` always evaluates to `false`.\nWhenever `x` is not constant, such an expression is often a mistake.\n\n\n## Recommendation\nIf the expression is supposed to evaluate to the same result every time it is executed, consider replacing the entire expression with its result.\n\n\n## Example\nThe following method tries to determine whether `x` is even by checking whether `x % 1 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n\treturn x % 1 == 0; //Does not work\n}\n\n```\nHowever, `x % 1 == 0` is always true when `x` is an integer. The correct check is `x % 2 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n    return x % 2 == 0; //Does work\n}\n\n```\n\n## References\n* Java Language Specification: [Multiplication Operator \\*](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.1), [Remainder Operator %](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.3), [Integer Bitwise Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.1), [Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23) and [Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24).\n","markdown":"# Expression always evaluates to the same value\nSome expressions always evaluate to the same result, no matter what their subexpressions are:\n\n* `x * 0` always evaluates to `0`.\n* `x % 1` always evaluates to `0`.\n* `x & 0` always evaluates to `0`.\n* `x || true` always evaluates to `true`.\n* `x && false` always evaluates to `false`.\nWhenever `x` is not constant, such an expression is often a mistake.\n\n\n## Recommendation\nIf the expression is supposed to evaluate to the same result every time it is executed, consider replacing the entire expression with its result.\n\n\n## Example\nThe following method tries to determine whether `x` is even by checking whether `x % 1 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n\treturn x % 1 == 0; //Does not work\n}\n\n```\nHowever, `x % 1 == 0` is always true when `x` is an integer. The correct check is `x % 2 == 0`.\n\n\n```java\npublic boolean isEven(int x) {\n    return x % 2 == 0; //Does work\n}\n\n```\n\n## References\n* Java Language Specification: [Multiplication Operator \\*](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.1), [Remainder Operator %](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.3), [Integer Bitwise Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.1), [Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23) and [Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24).\n"},"properties":{"tags":["maintainability","useless-code"],"description":"An expression that always evaluates to the same value, but which has a non-constant subexpression, indicates a mistake.","id":"java/evaluation-to-constant","kind":"problem","name":"Expression always evaluates to the same value","precision":"very-high","problem.severity":"warning"}},{"id":"java/integer-multiplication-cast-to-long","name":"java/integer-multiplication-cast-to-long","shortDescription":{"text":"Result of multiplication cast to wider type"},"fullDescription":{"text":"Casting the result of a multiplication to a wider type instead of casting before the multiplication may cause overflow."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Result of multiplication cast to wider type\nAn integer multiplication that is assigned to a variable of type `long` or returned from a method with return type `long` may cause unexpected arithmetic overflow.\n\n\n## Recommendation\nCasting to type `long` before multiplying reduces the risk of arithmetic overflow.\n\n\n## Example\nIn the following example, the multiplication expression assigned to `j` causes overflow and results in the value `-1651507200` instead of `4000000000000000000`.\n\n\n```java\nint i = 2000000000;\nlong j = i*i; // causes overflow\n```\nIn the following example, the assignment to `k` correctly avoids overflow by casting one of the operands to type `long`.\n\n\n```java\nint i = 2000000000;\nlong k = i*(long)i; // avoids overflow\n```\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 3. Addison-Wesley, 2005.\n* Java Language Specification: [Multiplication Operator](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.1).\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-192](https://cwe.mitre.org/data/definitions/192.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n","markdown":"# Result of multiplication cast to wider type\nAn integer multiplication that is assigned to a variable of type `long` or returned from a method with return type `long` may cause unexpected arithmetic overflow.\n\n\n## Recommendation\nCasting to type `long` before multiplying reduces the risk of arithmetic overflow.\n\n\n## Example\nIn the following example, the multiplication expression assigned to `j` causes overflow and results in the value `-1651507200` instead of `4000000000000000000`.\n\n\n```java\nint i = 2000000000;\nlong j = i*i; // causes overflow\n```\nIn the following example, the assignment to `k` correctly avoids overflow by casting one of the operands to type `long`.\n\n\n```java\nint i = 2000000000;\nlong k = i*(long)i; // avoids overflow\n```\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 3. Addison-Wesley, 2005.\n* Java Language Specification: [Multiplication Operator](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.17.1).\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-192](https://cwe.mitre.org/data/definitions/192.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n"},"properties":{"tags":["reliability","correctness","types","external/cwe/cwe-190","external/cwe/cwe-192","external/cwe/cwe-197","external/cwe/cwe-681"],"description":"Casting the result of a multiplication to a wider type instead of casting\n              before the multiplication may cause overflow.","id":"java/integer-multiplication-cast-to-long","kind":"problem","name":"Result of multiplication cast to wider type","precision":"very-high","problem.severity":"warning"}},{"id":"java/dereferenced-expr-may-be-null","name":"java/dereferenced-expr-may-be-null","shortDescription":{"text":"Dereferenced expression may be null"},"fullDescription":{"text":"Dereferencing an expression whose value may be 'null' may cause a 'NullPointerException'."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Dereferenced expression may be null\nDereferencing a `null` value leads to a `NullPointerException`.\n\nAn expression may be implicitly dereferenced if its type is a boxed primitive type, and it occurs in a context in which implicit unboxing occurs.\n\n\n## Recommendation\nEnsure that the expression does not have a `null` value when it is dereferenced. Use boxed types as appropriate to hold values that are potentially `null`.\n\n\n## Example\nIn the following example implicit unboxing can cause a `NullPointerException` if `helper` is `null`.\n\n\n```java\npublic int getID() {\n    return helper == null ? null : helper.getID();\n}\n\n```\nIf the method is intended to return `null`, the return type should be changed to `Integer`.\n\n\n## References\n* The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n* Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n","markdown":"# Dereferenced expression may be null\nDereferencing a `null` value leads to a `NullPointerException`.\n\nAn expression may be implicitly dereferenced if its type is a boxed primitive type, and it occurs in a context in which implicit unboxing occurs.\n\n\n## Recommendation\nEnsure that the expression does not have a `null` value when it is dereferenced. Use boxed types as appropriate to hold values that are potentially `null`.\n\n\n## Example\nIn the following example implicit unboxing can cause a `NullPointerException` if `helper` is `null`.\n\n\n```java\npublic int getID() {\n    return helper == null ? null : helper.getID();\n}\n\n```\nIf the method is intended to return `null`, the return type should be changed to `Integer`.\n\n\n## References\n* The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n* Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n"},"properties":{"tags":["reliability","correctness","exceptions","external/cwe/cwe-476"],"description":"Dereferencing an expression whose value may be 'null' may cause a\n              'NullPointerException'.","id":"java/dereferenced-expr-may-be-null","kind":"problem","name":"Dereferenced expression may be null","precision":"high","problem.severity":"warning"}},{"id":"java/dereferenced-value-is-always-null","name":"java/dereferenced-value-is-always-null","shortDescription":{"text":"Dereferenced variable is always null"},"fullDescription":{"text":"Dereferencing a variable whose value is 'null' causes a 'NullPointerException'."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Dereferenced variable is always null\nIf a variable is dereferenced, and the variable has a `null` value on all possible execution paths leading to the dereferencing, the dereferencing is guaranteed to result in a `NullPointerException`.\n\nA variable may also be implicitly dereferenced if its type is a boxed primitive type, and the variable occurs in a context in which implicit unboxing occurs. Note that the conditional operator unboxes its second and third operands when one of them is a primitive type and the other is the corresponding boxed type.\n\n\n## Recommendation\nEnsure that the variable does not have a `null` value when it is dereferenced.\n\n\n## Example\nIn the following examples, the condition `!dir.exists()` is only executed if `dir` is `null`. The second example guards the expression correctly by using `&&` instead of `||`.\n\n\n```java\npublic void createDir(File dir) {\n\tif (dir != null || !dir.exists()) // BAD\n\t\tdir.mkdir();\n}\n\npublic void createDir(File dir) {\n\tif (dir != null && !dir.exists()) // GOOD\n\t\tdir.mkdir();\n}\n\n```\n\n## References\n* The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n* Java Language Specification: [Conditional Operator ? :](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.25).\n* Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n","markdown":"# Dereferenced variable is always null\nIf a variable is dereferenced, and the variable has a `null` value on all possible execution paths leading to the dereferencing, the dereferencing is guaranteed to result in a `NullPointerException`.\n\nA variable may also be implicitly dereferenced if its type is a boxed primitive type, and the variable occurs in a context in which implicit unboxing occurs. Note that the conditional operator unboxes its second and third operands when one of them is a primitive type and the other is the corresponding boxed type.\n\n\n## Recommendation\nEnsure that the variable does not have a `null` value when it is dereferenced.\n\n\n## Example\nIn the following examples, the condition `!dir.exists()` is only executed if `dir` is `null`. The second example guards the expression correctly by using `&&` instead of `||`.\n\n\n```java\npublic void createDir(File dir) {\n\tif (dir != null || !dir.exists()) // BAD\n\t\tdir.mkdir();\n}\n\npublic void createDir(File dir) {\n\tif (dir != null && !dir.exists()) // GOOD\n\t\tdir.mkdir();\n}\n\n```\n\n## References\n* The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n* Java Language Specification: [Conditional Operator ? :](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.25).\n* Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n"},"properties":{"tags":["reliability","correctness","exceptions","external/cwe/cwe-476"],"description":"Dereferencing a variable whose value is 'null' causes a 'NullPointerException'.","id":"java/dereferenced-value-is-always-null","kind":"problem","name":"Dereferenced variable is always null","precision":"very-high","problem.severity":"error"}},{"id":"java/dereferenced-value-may-be-null","name":"java/dereferenced-value-may-be-null","shortDescription":{"text":"Dereferenced variable may be null"},"fullDescription":{"text":"Dereferencing a variable whose value may be 'null' may cause a 'NullPointerException'."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Dereferenced variable may be null\nIf a variable is dereferenced, and the variable may have a `null` value on some execution paths leading to the dereferencing, the dereferencing may result in a `NullPointerException`.\n\nA variable may also be implicitly dereferenced if its type is a boxed primitive type, and the variable occurs in a context in which implicit unboxing occurs. Note that the conditional operator unboxes its second and third operands when one of them is a primitive type and the other is the corresponding boxed type.\n\n\n## Recommendation\nEnsure that the variable does not have a `null` value when it is dereferenced.\n\n\n## Example\nIn the following example, the use of the conditional operator causes implicit unboxing, since the integer literal has type `int`. If the parameter `p` is ever `null` then a `NullPointerException` will occur.\n\n\n```java\npublic Integer f(Integer p) {\n\treturn true ? p : 5;\n}\n\n```\nIf the implicit unboxing is unintentional, it can be prevented by making sure that both branches of the conditional operator have the same type.\n\n\n## References\n* The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n* Java Language Specification: [Conditional Operator ? :](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.25).\n* Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n","markdown":"# Dereferenced variable may be null\nIf a variable is dereferenced, and the variable may have a `null` value on some execution paths leading to the dereferencing, the dereferencing may result in a `NullPointerException`.\n\nA variable may also be implicitly dereferenced if its type is a boxed primitive type, and the variable occurs in a context in which implicit unboxing occurs. Note that the conditional operator unboxes its second and third operands when one of them is a primitive type and the other is the corresponding boxed type.\n\n\n## Recommendation\nEnsure that the variable does not have a `null` value when it is dereferenced.\n\n\n## Example\nIn the following example, the use of the conditional operator causes implicit unboxing, since the integer literal has type `int`. If the parameter `p` is ever `null` then a `NullPointerException` will occur.\n\n\n```java\npublic Integer f(Integer p) {\n\treturn true ? p : 5;\n}\n\n```\nIf the implicit unboxing is unintentional, it can be prevented by making sure that both branches of the conditional operator have the same type.\n\n\n## References\n* The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n* Java Language Specification: [Conditional Operator ? :](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.25).\n* Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n"},"properties":{"tags":["reliability","correctness","exceptions","external/cwe/cwe-476","non-local"],"description":"Dereferencing a variable whose value may be 'null' may cause a\n              'NullPointerException'.","id":"java/dereferenced-value-may-be-null","kind":"problem","name":"Dereferenced variable may be null","precision":"high","problem.severity":"warning"}},{"id":"java/missing-space-in-concatenation","name":"java/missing-space-in-concatenation","shortDescription":{"text":"Missing space in string literal"},"fullDescription":{"text":"Joining strings at compile-time to construct a string literal so that two words are concatenated without a separating space usually indicates a text error."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Missing space in string literal\nSplitting a long string literal over multiple lines can often aid readability, but this also makes it difficult to notice whether a space is missing where the strings are concatenated.\n\n\n## Recommendation\nCheck the string literal to see whether it has the intended text. In particular, look for missing spaces near line breaks.\n\n\n## Example\nThe following example shows a text literal that is split over two lines and omits a space character between the two words at the line break.\n\n\n```java\nString s = \"This text is\" +\n  \"missing a space.\";\n\n```\n\n## References\n* Java Language Specification: [String Literals](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.5).\n","markdown":"# Missing space in string literal\nSplitting a long string literal over multiple lines can often aid readability, but this also makes it difficult to notice whether a space is missing where the strings are concatenated.\n\n\n## Recommendation\nCheck the string literal to see whether it has the intended text. In particular, look for missing spaces near line breaks.\n\n\n## Example\nThe following example shows a text literal that is split over two lines and omits a space character between the two words at the line break.\n\n\n```java\nString s = \"This text is\" +\n  \"missing a space.\";\n\n```\n\n## References\n* Java Language Specification: [String Literals](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.5).\n"},"properties":{"tags":["readability"],"description":"Joining strings at compile-time to construct a string literal\n              so that two words are concatenated without a separating space\n              usually indicates a text error.","id":"java/missing-space-in-concatenation","kind":"problem","name":"Missing space in string literal","precision":"very-high","problem.severity":"recommendation"}},{"id":"java/contradictory-type-checks","name":"java/contradictory-type-checks","shortDescription":{"text":"Contradictory type checks"},"fullDescription":{"text":"Contradictory dynamic type checks in `instanceof` expressions and casts may cause dead code or even runtime errors, and usually indicate a logic error."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Contradictory type checks\nIf an `instanceof` expression occurs in a position where the type test is guaranteed to return `false`, this is often due to a typo or logical mistake. It also suggests that the surrounding code is not well tested, or possibly even dead.\n\nSimilarly, a cast that is guaranteed to fail usually indicates badly tested or dead code.\n\n\n## Recommendation\nInspect the surrounding code for logical errors.\n\n\n## Example\nIn the following example, method `getKind` first checks whether its argument `x` is an instance of class `Mammal`, and then whether it is an instance of class `Tiger`.\n\n\n```java\nString getKind(Animal a) {\n\tif (a instanceof Mammal) {\n\t\treturn \"Mammal\";\n\t} else if (a instanceof Tiger) {\n\t\treturn \"Tiger!\";\n\t} else {\n\t\treturn \"unknown\";\n\t}\n}\n```\nIf `Tiger` is a subclass of `Mammal`, then the second `instanceof` check can never evaluate to `true`. Clearly, the two conditions should be swapped:\n\n\n```java\nString getKind(Animal a) {\n\tif (a instanceof Tiger) {\n\t\treturn \"Tiger!\";\n\t} else if (a instanceof Mammal) {\n\t\treturn \"Mammal\";\n\t} else {\n\t\treturn \"unknown\";\n\t}\n}\n```\n\n## References\n* Java Language Specification: [Type Comparison Operator instanceof](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.20.2).\n","markdown":"# Contradictory type checks\nIf an `instanceof` expression occurs in a position where the type test is guaranteed to return `false`, this is often due to a typo or logical mistake. It also suggests that the surrounding code is not well tested, or possibly even dead.\n\nSimilarly, a cast that is guaranteed to fail usually indicates badly tested or dead code.\n\n\n## Recommendation\nInspect the surrounding code for logical errors.\n\n\n## Example\nIn the following example, method `getKind` first checks whether its argument `x` is an instance of class `Mammal`, and then whether it is an instance of class `Tiger`.\n\n\n```java\nString getKind(Animal a) {\n\tif (a instanceof Mammal) {\n\t\treturn \"Mammal\";\n\t} else if (a instanceof Tiger) {\n\t\treturn \"Tiger!\";\n\t} else {\n\t\treturn \"unknown\";\n\t}\n}\n```\nIf `Tiger` is a subclass of `Mammal`, then the second `instanceof` check can never evaluate to `true`. Clearly, the two conditions should be swapped:\n\n\n```java\nString getKind(Animal a) {\n\tif (a instanceof Tiger) {\n\t\treturn \"Tiger!\";\n\t} else if (a instanceof Mammal) {\n\t\treturn \"Mammal\";\n\t} else {\n\t\treturn \"unknown\";\n\t}\n}\n```\n\n## References\n* Java Language Specification: [Type Comparison Operator instanceof](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.20.2).\n"},"properties":{"tags":["correctness","logic"],"description":"Contradictory dynamic type checks in `instanceof` expressions\n              and casts may cause dead code or even runtime errors, and usually\n              indicate a logic error.","id":"java/contradictory-type-checks","kind":"problem","name":"Contradictory type checks","precision":"very-high","problem.severity":"error"}},{"id":"java/unused-format-argument","name":"java/unused-format-argument","shortDescription":{"text":"Unused format argument"},"fullDescription":{"text":"A format call with a format string that refers to fewer arguments than the number of supplied arguments will silently ignore the additional arguments."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unused format argument\nWhen formatting strings using `printf`-style format strings, one must ensure that the number of supplied arguments matches the number of arguments referenced by the format string. Additional arguments will be thrown away silently, which may not be the intended behavior, and too few arguments will cause an `IllegalFormatException`.\n\nFormat strings are used by the `format` method on the classes `String`, `Formatter`, `Console`, `PrintWriter`, and `PrintStream`. Several of these classes also supply the method alias `printf`. The class `Console` has two additional methods, `readLine` and `readPassword`, that also use format strings.\n\n\n## Recommendation\nChange the format string to use all the arguments, or remove the unnecessary arguments.\n\n\n## Example\nThe following example supplies three arguments to be formatted, but the format string only refers to two arguments, so this will silently ignore the third argument.\n\n\n```java\nSystem.out.format(\"First string: %s Second string: %s\", \"Hello\", \"world\", \"!\");\n\n```\n\n## References\n* Java API Specification: [Format string syntax](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax), [Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html), [Class Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html), [Class Console](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Console.html), [Class PrintWriter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html), [Class PrintStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html).\n* SLF4J library: [org.slf4j.Logger](https://www.slf4j.org/apidocs/org/slf4j/Logger.html).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n","markdown":"# Unused format argument\nWhen formatting strings using `printf`-style format strings, one must ensure that the number of supplied arguments matches the number of arguments referenced by the format string. Additional arguments will be thrown away silently, which may not be the intended behavior, and too few arguments will cause an `IllegalFormatException`.\n\nFormat strings are used by the `format` method on the classes `String`, `Formatter`, `Console`, `PrintWriter`, and `PrintStream`. Several of these classes also supply the method alias `printf`. The class `Console` has two additional methods, `readLine` and `readPassword`, that also use format strings.\n\n\n## Recommendation\nChange the format string to use all the arguments, or remove the unnecessary arguments.\n\n\n## Example\nThe following example supplies three arguments to be formatted, but the format string only refers to two arguments, so this will silently ignore the third argument.\n\n\n```java\nSystem.out.format(\"First string: %s Second string: %s\", \"Hello\", \"world\", \"!\");\n\n```\n\n## References\n* Java API Specification: [Format string syntax](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax), [Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html), [Class Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html), [Class Console](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Console.html), [Class PrintWriter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html), [Class PrintStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html).\n* SLF4J library: [org.slf4j.Logger](https://www.slf4j.org/apidocs/org/slf4j/Logger.html).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n"},"properties":{"tags":["maintainability","useless-code","external/cwe/cwe-685"],"description":"A format call with a format string that refers to fewer\n              arguments than the number of supplied arguments will silently\n              ignore the additional arguments.","id":"java/unused-format-argument","kind":"problem","name":"Unused format argument","precision":"very-high","problem.severity":"warning"}},{"id":"java/string-buffer-char-init","name":"java/string-buffer-char-init","shortDescription":{"text":"Character passed to StringBuffer or StringBuilder constructor"},"fullDescription":{"text":"A character value is passed to the constructor of 'StringBuffer' or 'StringBuilder'. This value will be converted to an integer and interpreted as the buffer's initial capacity, which is probably not intended."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Character passed to StringBuffer or StringBuilder constructor\nPassing a character to the constructor of `StringBuffer` or `StringBuilder` is probably intended to insert the character into the newly created buffer. In fact, however, the character value is converted to an integer and interpreted as the buffer's initial capacity, which may yield unexpected results.\n\n\n## Example\nThe following example shows a class representing points in two-dimensional Cartesian coordinates. The `toString` method uses a `StringBuffer` to construct a human-readable representation of the form `(x, y)`, where `x` and `y` are the point's coordinates.\n\nHowever, the opening parenthesis is passed to the `StringBuffer` constructor as character literal. Instead of being used to initialise the buffer's contents, the character is converted to the integer value 40 and interpreted as the buffer's initial capacity. Thus, the string representation returned by `toString` will be missing the opening parenthesis. (Note that passing a character to `append`, on the other hand, is unproblematic.)\n\n\n```java\nclass Point {\n\tprivate double x, y;\n\t\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer res = new StringBuffer('(');\n\t\tres.append(x);\n\t\tres.append(\", \");\n\t\tres.append(y);\n\t\tres.append(')');\n\t\treturn res.toString();\n\t}\n}\n\n```\n\n## Recommendation\nIf the character used to initialize the buffer is a character literal, simply replace it with the corresponding string literal. So, in our example, replace `new StringBuffer('(')` with `new StringBuffer(\"(\")`. If the character is not a literal value, use method `String.valueOf` to convert it to a string.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 23. Addison-Wesley, 2005.\n* NetBeans IDE: [Java Hints](https://web.archive.org/web/20210117160808/http://wiki.netbeans.org/Java_Hints)\n* PMD: [Rule StringBufferInstantiationWithChar](https://pmd.github.io/latest/pmd_rules_java_errorprone.html#stringbufferinstantiationwithchar)\n* Java API: [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html), [java.lang.StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n","markdown":"# Character passed to StringBuffer or StringBuilder constructor\nPassing a character to the constructor of `StringBuffer` or `StringBuilder` is probably intended to insert the character into the newly created buffer. In fact, however, the character value is converted to an integer and interpreted as the buffer's initial capacity, which may yield unexpected results.\n\n\n## Example\nThe following example shows a class representing points in two-dimensional Cartesian coordinates. The `toString` method uses a `StringBuffer` to construct a human-readable representation of the form `(x, y)`, where `x` and `y` are the point's coordinates.\n\nHowever, the opening parenthesis is passed to the `StringBuffer` constructor as character literal. Instead of being used to initialise the buffer's contents, the character is converted to the integer value 40 and interpreted as the buffer's initial capacity. Thus, the string representation returned by `toString` will be missing the opening parenthesis. (Note that passing a character to `append`, on the other hand, is unproblematic.)\n\n\n```java\nclass Point {\n\tprivate double x, y;\n\t\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer res = new StringBuffer('(');\n\t\tres.append(x);\n\t\tres.append(\", \");\n\t\tres.append(y);\n\t\tres.append(')');\n\t\treturn res.toString();\n\t}\n}\n\n```\n\n## Recommendation\nIf the character used to initialize the buffer is a character literal, simply replace it with the corresponding string literal. So, in our example, replace `new StringBuffer('(')` with `new StringBuffer(\"(\")`. If the character is not a literal value, use method `String.valueOf` to convert it to a string.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 23. Addison-Wesley, 2005.\n* NetBeans IDE: [Java Hints](https://web.archive.org/web/20210117160808/http://wiki.netbeans.org/Java_Hints)\n* PMD: [Rule StringBufferInstantiationWithChar](https://pmd.github.io/latest/pmd_rules_java_errorprone.html#stringbufferinstantiationwithchar)\n* Java API: [StringBuffer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html), [java.lang.StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html).\n"},"properties":{"tags":["reliability","maintainability"],"description":"A character value is passed to the constructor of 'StringBuffer' or 'StringBuilder'. This value will\n              be converted to an integer and interpreted as the buffer's initial capacity, which is probably not intended.","id":"java/string-buffer-char-init","kind":"problem","name":"Character passed to StringBuffer or StringBuilder constructor","precision":"very-high","problem.severity":"error"}},{"id":"java/suspicious-date-format","name":"java/suspicious-date-format","shortDescription":{"text":"Suspicious date format"},"fullDescription":{"text":"Using a data format that includes both 'M' and 'Y' is likely to give unexpected results."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Suspicious date format\nThe Java `SimpleDateFormat` class provides many placeholders so that you can define precisely the date format required. However, this also makes it easy to define a pattern that doesn't behave exactly as you intended. The most common mistake is to use the `Y` placeholder (which represents the ISO 8601 week year), rather than `y` (which represents the actual year). In this case, the date reported will appear correct until the end of the year, when the \"week year\" may differ from the actual year.\n\n\n## Recommendation\nEnsure the format pattern's use of `Y` is correct, and if not replace it with `y`.\n\n\n## Example\nThe following example uses the date format `YYYY-MM-dd`. On the 30th of December 2019, this code will output \"2020-12-30\", rather than the intended \"2019-12-30\".\n\n\n```java\nSystem.out.println(new SimpleDateFormat(\"YYYY-MM-dd\").format(new Date()));\n\n```\nThe correct pattern in this case would be `yyyy-MM-dd` instead of `YYYY-MM-dd`.\n\n\n## References\n* Java API Specification: [SimpleDateFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/SimpleDateFormat.html).\n","markdown":"# Suspicious date format\nThe Java `SimpleDateFormat` class provides many placeholders so that you can define precisely the date format required. However, this also makes it easy to define a pattern that doesn't behave exactly as you intended. The most common mistake is to use the `Y` placeholder (which represents the ISO 8601 week year), rather than `y` (which represents the actual year). In this case, the date reported will appear correct until the end of the year, when the \"week year\" may differ from the actual year.\n\n\n## Recommendation\nEnsure the format pattern's use of `Y` is correct, and if not replace it with `y`.\n\n\n## Example\nThe following example uses the date format `YYYY-MM-dd`. On the 30th of December 2019, this code will output \"2020-12-30\", rather than the intended \"2019-12-30\".\n\n\n```java\nSystem.out.println(new SimpleDateFormat(\"YYYY-MM-dd\").format(new Date()));\n\n```\nThe correct pattern in this case would be `yyyy-MM-dd` instead of `YYYY-MM-dd`.\n\n\n## References\n* Java API Specification: [SimpleDateFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/SimpleDateFormat.html).\n"},"properties":{"tags":["correctness"],"description":"Using a data format that includes both 'M' and 'Y' is likely to give unexpected results.","id":"java/suspicious-date-format","kind":"problem","name":"Suspicious date format","precision":"high","problem.severity":"warning"}},{"id":"java/missing-format-argument","name":"java/missing-format-argument","shortDescription":{"text":"Missing format argument"},"fullDescription":{"text":"A format call with an insufficient number of arguments causes an 'IllegalFormatException'."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Missing format argument\nWhen formatting strings using `printf`-style format strings, one must ensure that the number of supplied arguments matches the number of arguments referenced by the format string. Additional arguments will be thrown away silently, which may not be the intended behavior, and too few arguments will cause an `IllegalFormatException`.\n\nFormat strings are used by the `format` method on the classes `String`, `Formatter`, `Console`, `PrintWriter`, and `PrintStream`. Several of these classes also supply the method alias `printf`. The class `Console` has two additional methods, `readLine` and `readPassword`, that also use format strings.\n\n\n## Recommendation\nSupply the correct number of arguments to the format method, or change the format string to use the correct arguments.\n\n\n## Example\nThe following example supplies only one argument to be formatted, but the format string refers to two arguments, so this will throw an `IllegalFormatException`.\n\n\n```java\nSystem.out.format(\"First string: %s Second string: %s\", \"Hello world\");\n\n```\n\n## References\n* Java API Specification: [Format string syntax](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax), [Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html), [Class Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html), [Class Console](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Console.html), [Class PrintWriter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html), [Class PrintStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html).\n* SLF4J library: [org.slf4j.Logger](https://www.slf4j.org/apidocs/org/slf4j/Logger.html).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n","markdown":"# Missing format argument\nWhen formatting strings using `printf`-style format strings, one must ensure that the number of supplied arguments matches the number of arguments referenced by the format string. Additional arguments will be thrown away silently, which may not be the intended behavior, and too few arguments will cause an `IllegalFormatException`.\n\nFormat strings are used by the `format` method on the classes `String`, `Formatter`, `Console`, `PrintWriter`, and `PrintStream`. Several of these classes also supply the method alias `printf`. The class `Console` has two additional methods, `readLine` and `readPassword`, that also use format strings.\n\n\n## Recommendation\nSupply the correct number of arguments to the format method, or change the format string to use the correct arguments.\n\n\n## Example\nThe following example supplies only one argument to be formatted, but the format string refers to two arguments, so this will throw an `IllegalFormatException`.\n\n\n```java\nSystem.out.format(\"First string: %s Second string: %s\", \"Hello world\");\n\n```\n\n## References\n* Java API Specification: [Format string syntax](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax), [Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html), [Class Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html), [Class Console](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Console.html), [Class PrintWriter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintWriter.html), [Class PrintStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html).\n* SLF4J library: [org.slf4j.Logger](https://www.slf4j.org/apidocs/org/slf4j/Logger.html).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n"},"properties":{"tags":["correctness","external/cwe/cwe-685"],"description":"A format call with an insufficient number of arguments causes\n              an 'IllegalFormatException'.","id":"java/missing-format-argument","kind":"problem","name":"Missing format argument","precision":"very-high","problem.severity":"error"}},{"id":"java/test-for-negative-container-size","name":"java/test-for-negative-container-size","shortDescription":{"text":"Container size compared to zero"},"fullDescription":{"text":"Comparing the size of a container to zero with this operator will always return the same value."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Container size compared to zero\nA map, collection, string or array will always have size of at least zero. Checking that an object of one of these types has size greater than or equal to zero will always be true, while checking that it has size less than zero will always be false.\n\n\n## Recommendation\nFor collections, maps and strings, if the intention was to check whether the object was empty, is it preferred to use the `isEmpty()` method. For arrays, check that the `length` field is greater than (**not** equal to) zero.\n\n\n## Example\nThe following example shows creation of a file guarded by comparison of a string length with zero. This can result in the attempted creation of a file with an empty name.\n\n\n```java\nimport java.io.File;\n\nclass ContainerSizeCmpZero\n{\n    private static File MakeFile(String filename) {\n    if(filename != null && filename.length() >= 0) {\n        return new File(filename);\n    }\n    return new File(\"default.name\");\n    }\n}\n\n```\nIn the following revised example, the check against zero has been replaced with a call to `isEmpty()`. This correctly guards against the attempted creation of a file with an empty name.\n\n\n```java\nimport java.io.File;\n\nclass ContainerSizeCmpZero\n{\n    private static File MakeFile(String filename) {\n    if(filename != null && !filename.isEmpty()) {\n        return new File(filename);\n    }\n    return new File(\"default.name\");\n    }\n}\n\n```\n\n## References\n* Java API Specification: [ Collection.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#isEmpty()), [ Map.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#isEmpty()), [ String.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isEmpty()).\n","markdown":"# Container size compared to zero\nA map, collection, string or array will always have size of at least zero. Checking that an object of one of these types has size greater than or equal to zero will always be true, while checking that it has size less than zero will always be false.\n\n\n## Recommendation\nFor collections, maps and strings, if the intention was to check whether the object was empty, is it preferred to use the `isEmpty()` method. For arrays, check that the `length` field is greater than (**not** equal to) zero.\n\n\n## Example\nThe following example shows creation of a file guarded by comparison of a string length with zero. This can result in the attempted creation of a file with an empty name.\n\n\n```java\nimport java.io.File;\n\nclass ContainerSizeCmpZero\n{\n    private static File MakeFile(String filename) {\n    if(filename != null && filename.length() >= 0) {\n        return new File(filename);\n    }\n    return new File(\"default.name\");\n    }\n}\n\n```\nIn the following revised example, the check against zero has been replaced with a call to `isEmpty()`. This correctly guards against the attempted creation of a file with an empty name.\n\n\n```java\nimport java.io.File;\n\nclass ContainerSizeCmpZero\n{\n    private static File MakeFile(String filename) {\n    if(filename != null && !filename.isEmpty()) {\n        return new File(filename);\n    }\n    return new File(\"default.name\");\n    }\n}\n\n```\n\n## References\n* Java API Specification: [ Collection.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#isEmpty()), [ Map.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#isEmpty()), [ String.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isEmpty()).\n"},"properties":{"tags":["reliability","correctness","logic"],"description":"Comparing the size of a container to zero with this operator will always return the same value.","id":"java/test-for-negative-container-size","kind":"problem","name":"Container size compared to zero","precision":"very-high","problem.severity":"warning"}},{"id":"java/redundant-assignment","name":"java/redundant-assignment","shortDescription":{"text":"Self assignment"},"fullDescription":{"text":"Assigning a variable to itself has no effect."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Self assignment\nAssigning a variable to itself does not have any effect. Therefore, such an assignment is either completely unnecessary, or it indicates a typo or a similar mistake.\n\n\n## Recommendation\nIf the assignment is unnecessary, remove it. If the assignment indicates a typo or a similar mistake, correct the mistake.\n\n\n## Example\nThe following example shows part of a method that is intended to make a copy of an existing `MotionEvent` without preserving its history. On line 8, `o.mFlags` is assigned to itself. Given that the statement is surrounded by statements that transfer information from the fields of `o` to the fields of the new event, `ev`, the statement is clearly a mistake. To correct this, the `mFlags` value should be assigned to `ev.mFlags` instead, as shown in the corrected method.\n\n\n```java\nstatic public MotionEvent obtainNoHistory(MotionEvent o) {\n    MotionEvent ev = obtain(o.mNumPointers, 1);\n    ev.mDeviceId = o.mDeviceId;\n    o.mFlags = o.mFlags;  // Variable is assigned to itself\n    ...\n}\n\nstatic public MotionEvent obtainNoHistory(MotionEvent o) {\n    MotionEvent ev = obtain(o.mNumPointers, 1);\n    ev.mDeviceId = o.mDeviceId;\n    ev.mFlags = o.mFlags;  // Variable is assigned correctly\n    ...\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n","markdown":"# Self assignment\nAssigning a variable to itself does not have any effect. Therefore, such an assignment is either completely unnecessary, or it indicates a typo or a similar mistake.\n\n\n## Recommendation\nIf the assignment is unnecessary, remove it. If the assignment indicates a typo or a similar mistake, correct the mistake.\n\n\n## Example\nThe following example shows part of a method that is intended to make a copy of an existing `MotionEvent` without preserving its history. On line 8, `o.mFlags` is assigned to itself. Given that the statement is surrounded by statements that transfer information from the fields of `o` to the fields of the new event, `ev`, the statement is clearly a mistake. To correct this, the `mFlags` value should be assigned to `ev.mFlags` instead, as shown in the corrected method.\n\n\n```java\nstatic public MotionEvent obtainNoHistory(MotionEvent o) {\n    MotionEvent ev = obtain(o.mNumPointers, 1);\n    ev.mDeviceId = o.mDeviceId;\n    o.mFlags = o.mFlags;  // Variable is assigned to itself\n    ...\n}\n\nstatic public MotionEvent obtainNoHistory(MotionEvent o) {\n    MotionEvent ev = obtain(o.mNumPointers, 1);\n    ev.mDeviceId = o.mDeviceId;\n    ev.mFlags = o.mFlags;  // Variable is assigned correctly\n    ...\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n"},"properties":{"tags":["reliability","correctness","logic"],"description":"Assigning a variable to itself has no effect.","id":"java/redundant-assignment","kind":"problem","name":"Self assignment","precision":"very-high","problem.severity":"error"}},{"id":"java/type-mismatch-access","name":"java/type-mismatch-access","shortDescription":{"text":"Type mismatch on container access"},"fullDescription":{"text":"Calling container access methods such as 'Collection.contains' or 'Map.get' with an object of a type that is incompatible with the corresponding container element type is unlikely to return 'true'."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Type mismatch on container access\nThe `contains` method of the `Collection` interface has an argument of type `Object`. Therefore, you can try to check if an object of any type is a member of a collection, regardless of the collection's element type. However, although you can call `contains` with an argument of a different type than that of the collection, it is unlikely that the collection actually contains an object of this type.\n\nSimilar considerations apply to other container access methods, such as `Map.get`, where the argument may also have type `Object`.\n\n\n## Recommendation\nEnsure that you use the correct argument with a call to `contains`.\n\n\n## Example\nIn the following example, although the argument to `contains` is an integer, the code does not result in a type error because the argument does not have to match the type of the elements of `list`. However, the argument is unlikely to be found (and the body of the `if` statement is therefore not executed), so it is probably a typographical error: the argument should be enclosed in quotation marks.\n\n\n```java\nvoid m(List<String> list) {\n\tif (list.contains(123)) {  // Call 'contains' with non-string argument (without quotation marks)\n\t\t// ...\n\t}\n}\n```\nNote that you must take particular care when working with collections over boxed types, as illustrated in the following example. The first call to `contains` returns `false` because you cannot compare two boxed numeric primitives of different types, in this case `Short(1)` (in `set`) and `Integer(1)` (the argument). The second call to `contains` returns `true` because you can compare `Short(1)` and `Short(1)`.\n\n\n```java\nHashSet<Short> set = new HashSet<Short>();\nshort s = 1;\nset.add(s);\n// Following statement prints 'false', because the argument is a literal int, which is auto-boxed\n// to an Integer\nSystem.out.println(set.contains(1));\n// Following statement prints 'true', because the argument is a literal int that is cast to a short, \n// which is auto-boxed to a Short\nSystem.out.println(set.contains((short)1));\n\n```\n\n## References\n* Java API Specification: [Collection.contains](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#contains(java.lang.Object)).\n","markdown":"# Type mismatch on container access\nThe `contains` method of the `Collection` interface has an argument of type `Object`. Therefore, you can try to check if an object of any type is a member of a collection, regardless of the collection's element type. However, although you can call `contains` with an argument of a different type than that of the collection, it is unlikely that the collection actually contains an object of this type.\n\nSimilar considerations apply to other container access methods, such as `Map.get`, where the argument may also have type `Object`.\n\n\n## Recommendation\nEnsure that you use the correct argument with a call to `contains`.\n\n\n## Example\nIn the following example, although the argument to `contains` is an integer, the code does not result in a type error because the argument does not have to match the type of the elements of `list`. However, the argument is unlikely to be found (and the body of the `if` statement is therefore not executed), so it is probably a typographical error: the argument should be enclosed in quotation marks.\n\n\n```java\nvoid m(List<String> list) {\n\tif (list.contains(123)) {  // Call 'contains' with non-string argument (without quotation marks)\n\t\t// ...\n\t}\n}\n```\nNote that you must take particular care when working with collections over boxed types, as illustrated in the following example. The first call to `contains` returns `false` because you cannot compare two boxed numeric primitives of different types, in this case `Short(1)` (in `set`) and `Integer(1)` (the argument). The second call to `contains` returns `true` because you can compare `Short(1)` and `Short(1)`.\n\n\n```java\nHashSet<Short> set = new HashSet<Short>();\nshort s = 1;\nset.add(s);\n// Following statement prints 'false', because the argument is a literal int, which is auto-boxed\n// to an Integer\nSystem.out.println(set.contains(1));\n// Following statement prints 'true', because the argument is a literal int that is cast to a short, \n// which is auto-boxed to a Short\nSystem.out.println(set.contains((short)1));\n\n```\n\n## References\n* Java API Specification: [Collection.contains](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#contains(java.lang.Object)).\n"},"properties":{"tags":["reliability","correctness","logic"],"description":"Calling container access methods such as 'Collection.contains'\n              or 'Map.get' with an object of a type that is incompatible with\n              the corresponding container element type is unlikely to return 'true'.","id":"java/type-mismatch-access","kind":"problem","name":"Type mismatch on container access","precision":"very-high","problem.severity":"error"}},{"id":"java/index-out-of-bounds","name":"java/index-out-of-bounds","shortDescription":{"text":"Array index out of bounds"},"fullDescription":{"text":"Accessing an array with an index that is greater than or equal to the length of the array causes an 'ArrayIndexOutOfBoundsException'."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Array index out of bounds\nWhen accessing an array element, one must ensure that the index is less than the length of the array. Using an index that is greater than or equal to the array length causes an `ArrayIndexOutOfBoundsException`.\n\n\n## Recommendation\nEnsure that the index is less than the array length.\n\n\n## Example\nThe following example causes an `ArrayIndexOutOfBoundsException` in the final loop iteration.\n\n\n```java\nfor (int i = 0; i <= a.length; i++) { // BAD\n  sum += a[i];\n}\n\n```\nThe condition should be changed as follows to correctly guard the array access.\n\n\n```java\nfor (int i = 0; i < a.length; i++) { // GOOD\n  sum += a[i];\n}\n\n```\n\n## References\n* Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).\n* Common Weakness Enumeration: [CWE-193](https://cwe.mitre.org/data/definitions/193.html).\n","markdown":"# Array index out of bounds\nWhen accessing an array element, one must ensure that the index is less than the length of the array. Using an index that is greater than or equal to the array length causes an `ArrayIndexOutOfBoundsException`.\n\n\n## Recommendation\nEnsure that the index is less than the array length.\n\n\n## Example\nThe following example causes an `ArrayIndexOutOfBoundsException` in the final loop iteration.\n\n\n```java\nfor (int i = 0; i <= a.length; i++) { // BAD\n  sum += a[i];\n}\n\n```\nThe condition should be changed as follows to correctly guard the array access.\n\n\n```java\nfor (int i = 0; i < a.length; i++) { // GOOD\n  sum += a[i];\n}\n\n```\n\n## References\n* Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).\n* Common Weakness Enumeration: [CWE-193](https://cwe.mitre.org/data/definitions/193.html).\n"},"properties":{"tags":["reliability","correctness","exceptions","external/cwe/cwe-193"],"description":"Accessing an array with an index that is greater than or equal to the\n              length of the array causes an 'ArrayIndexOutOfBoundsException'.","id":"java/index-out-of-bounds","kind":"problem","name":"Array index out of bounds","precision":"high","problem.severity":"error"}},{"id":"java/unused-container","name":"java/unused-container","shortDescription":{"text":"Container contents are never accessed"},"fullDescription":{"text":"A collection or map whose contents are never queried or accessed is useless."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Container contents are never accessed\nIf the contents of a collection or map are never accessed in any way, then it is useless and the code that updates it is effectively dead code. Often, such objects are left over from an incomplete refactoring, or they indicate an underlying logic error.\n\n\n## Recommendation\nEither remove the collection/map if it is genuinely unnecessary, or ensure that its elements are accessed.\n\n\n## Example\nIn the following example code, the `reachable` method determines whether a node in a tree is reachable from `ROOT`. It maintains a set `reachableNodes`, which contains all nodes that have previously been found to be reachable. Most likely, this set is meant to act as a cache to avoid spurious recomputation, but as it stands the code never checks whether any node is contained in the set.\n\n\n```java\nprivate Set<Node> reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\nIn the following modification of the above example, `reachable` checks the cache to see whether the node has already been considered.\n\n\n```java\nprivate Set<Node> reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tif (reachableNodes.contains(n))\n\t\t  return true;\n\t\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html), [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n","markdown":"# Container contents are never accessed\nIf the contents of a collection or map are never accessed in any way, then it is useless and the code that updates it is effectively dead code. Often, such objects are left over from an incomplete refactoring, or they indicate an underlying logic error.\n\n\n## Recommendation\nEither remove the collection/map if it is genuinely unnecessary, or ensure that its elements are accessed.\n\n\n## Example\nIn the following example code, the `reachable` method determines whether a node in a tree is reachable from `ROOT`. It maintains a set `reachableNodes`, which contains all nodes that have previously been found to be reachable. Most likely, this set is meant to act as a cache to avoid spurious recomputation, but as it stands the code never checks whether any node is contained in the set.\n\n\n```java\nprivate Set<Node> reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\nIn the following modification of the above example, `reachable` checks the cache to see whether the node has already been considered.\n\n\n```java\nprivate Set<Node> reachableNodes = new HashSet<Node>();\n\nboolean reachable(Node n) {\n\tif (reachableNodes.contains(n))\n\t\t  return true;\n\t\n\tboolean reachable;\n\tif (n == ROOT)\n\t\treachable = true;\n\telse\n\t\treachable = reachable(n.getParent());\n\tif (reachable)\n\t\treachableNodes.add(n);\n\treturn reachable;\n}\n```\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html), [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"},"properties":{"tags":["maintainability","useless-code","external/cwe/cwe-561"],"description":"A collection or map whose contents are never queried or accessed is useless.","id":"java/unused-container","kind":"problem","name":"Container contents are never accessed","precision":"very-high","problem.severity":"error"}},{"id":"java/type-mismatch-modification","name":"java/type-mismatch-modification","shortDescription":{"text":"Type mismatch on container modification"},"fullDescription":{"text":"Calling container modification methods such as 'Collection.remove' or 'Map.remove' with an object of a type that is incompatible with the corresponding container element type is unlikely to have any effect."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Type mismatch on container modification\nThe `remove` method of the `Collection` interface has an argument of type `Object`. Therefore, you can try to remove an object of any type from a collection, regardless of the collection's element type. However, although you can call `remove` with an argument of a different type than that of the collection, it is unlikely that the collection actually contains an object of this type.\n\nSimilar considerations apply to other container modification methods, such as `Map.remove`, where the argument may also have type `Object`.\n\n\n## Recommendation\nEnsure that you use the correct argument with a call to `remove`.\n\n\n## Example\nIn the following example, although the argument to `contains` is an integer, the code does not result in a type error because the argument to `remove` does not have to match the type of the elements of `list`. However, the argument is unlikely to be found and removed (and the body of the `if` statement is therefore not executed), so it is probably a typographical error: the argument should be enclosed in quotation marks.\n\n\n```java\nvoid m(List<String> list) {\n\tif (list.remove(123)) {  // Call 'remove' with non-string argument (without quotation marks)\n\t\t// ...\n\t}\n}\n```\nNote that you must take particular care when working with collections over boxed types, as illustrated in the following example. The first call to `remove` fails because you cannot compare two boxed numeric primitives of different types, in this case `Short(1)` (in `set`) and `Integer(1)` (the argument). Therefore, `remove` cannot find the item to remove. The second call to `remove` succeeds because you can compare `Short(1)` and `Short(1)`. Therefore, `remove` can find the item to remove.\n\n\n```java\nHashSet<Short> set = new HashSet<Short>();\nshort s = 1;\nset.add(s);\n// Following statement fails, because the argument is a literal int, which is auto-boxed \n// to an Integer\nset.remove(1);\nSystem.out.println(set); // Prints [1]\n// Following statement succeeds, because the argument is a literal int that is cast to a short, \n// which is auto-boxed to a Short\nset.remove((short)1);\nSystem.out.println(set); // Prints []\n```\n\n## References\n* Java API Specification: [Collection.remove](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#remove(java.lang.Object)).\n","markdown":"# Type mismatch on container modification\nThe `remove` method of the `Collection` interface has an argument of type `Object`. Therefore, you can try to remove an object of any type from a collection, regardless of the collection's element type. However, although you can call `remove` with an argument of a different type than that of the collection, it is unlikely that the collection actually contains an object of this type.\n\nSimilar considerations apply to other container modification methods, such as `Map.remove`, where the argument may also have type `Object`.\n\n\n## Recommendation\nEnsure that you use the correct argument with a call to `remove`.\n\n\n## Example\nIn the following example, although the argument to `contains` is an integer, the code does not result in a type error because the argument to `remove` does not have to match the type of the elements of `list`. However, the argument is unlikely to be found and removed (and the body of the `if` statement is therefore not executed), so it is probably a typographical error: the argument should be enclosed in quotation marks.\n\n\n```java\nvoid m(List<String> list) {\n\tif (list.remove(123)) {  // Call 'remove' with non-string argument (without quotation marks)\n\t\t// ...\n\t}\n}\n```\nNote that you must take particular care when working with collections over boxed types, as illustrated in the following example. The first call to `remove` fails because you cannot compare two boxed numeric primitives of different types, in this case `Short(1)` (in `set`) and `Integer(1)` (the argument). Therefore, `remove` cannot find the item to remove. The second call to `remove` succeeds because you can compare `Short(1)` and `Short(1)`. Therefore, `remove` can find the item to remove.\n\n\n```java\nHashSet<Short> set = new HashSet<Short>();\nshort s = 1;\nset.add(s);\n// Following statement fails, because the argument is a literal int, which is auto-boxed \n// to an Integer\nset.remove(1);\nSystem.out.println(set); // Prints [1]\n// Following statement succeeds, because the argument is a literal int that is cast to a short, \n// which is auto-boxed to a Short\nset.remove((short)1);\nSystem.out.println(set); // Prints []\n```\n\n## References\n* Java API Specification: [Collection.remove](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html#remove(java.lang.Object)).\n"},"properties":{"tags":["reliability","correctness","logic"],"description":"Calling container modification methods such as 'Collection.remove'\n              or 'Map.remove' with an object of a type that is incompatible with\n              the corresponding container element type is unlikely to have any effect.","id":"java/type-mismatch-modification","kind":"problem","name":"Type mismatch on container modification","precision":"very-high","problem.severity":"error"}},{"id":"java/empty-container","name":"java/empty-container","shortDescription":{"text":"Container contents are never initialized"},"fullDescription":{"text":"Querying the contents of a collection or map that is never initialized is not normally useful."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Container contents are never initialized\nA method that queries the contents of a collection or map (such as `containsKey` or `isEmpty`) is invoked on an object that is known to be empty. Such method calls do not return interesting results, and may indicate missing code or a logic error.\n\n\n## Recommendation\nEither remove the collection/map if it is unnecessary, or ensure that it contains the elements it was meant to contain.\n\n\n## Example\nThe following example code iterates over an array of objects to determine whether it contains duplicate elements. It maintains a collection `seen`, which is intended to contain all the elements seen so far in traversing the array. If the current element is already contained in that collection then the method returns `true`, indicating that a duplicate has been found.\n\nNote, however, that no elements are ever actually added to `seen`, so the method always returns `false`.\n\n\n```java\nboolean containsDuplicates(Object[] array) {\n\tjava.util.Set<Object> seen = new java.util.HashSet<Object>();\n\tfor (Object o : array) {\n\t\tif (seen.contains(o))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n```\nTo fix this problem, a statement `seen.add(o);` should be added to the end of the loop body to ensure that `seen` is correctly maintained.\n\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html), [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n","markdown":"# Container contents are never initialized\nA method that queries the contents of a collection or map (such as `containsKey` or `isEmpty`) is invoked on an object that is known to be empty. Such method calls do not return interesting results, and may indicate missing code or a logic error.\n\n\n## Recommendation\nEither remove the collection/map if it is unnecessary, or ensure that it contains the elements it was meant to contain.\n\n\n## Example\nThe following example code iterates over an array of objects to determine whether it contains duplicate elements. It maintains a collection `seen`, which is intended to contain all the elements seen so far in traversing the array. If the current element is already contained in that collection then the method returns `true`, indicating that a duplicate has been found.\n\nNote, however, that no elements are ever actually added to `seen`, so the method always returns `false`.\n\n\n```java\nboolean containsDuplicates(Object[] array) {\n\tjava.util.Set<Object> seen = new java.util.HashSet<Object>();\n\tfor (Object o : array) {\n\t\tif (seen.contains(o))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n```\nTo fix this problem, a statement `seen.add(o);` should be added to the end of the loop body to ensure that `seen` is correctly maintained.\n\n\n## References\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html), [Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"},"properties":{"tags":["reliability","maintainability","useless-code","external/cwe/cwe-561"],"description":"Querying the contents of a collection or map that is never initialized is not normally useful.","id":"java/empty-container","kind":"problem","name":"Container contents are never initialized","precision":"very-high","problem.severity":"error"}},{"id":"java/inefficient-boxed-constructor","name":"java/inefficient-boxed-constructor","shortDescription":{"text":"Inefficient primitive constructor"},"fullDescription":{"text":"Calling the constructor of a boxed type is inefficient."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Inefficient primitive constructor\nPrimitive values (for example `int`, `float`, `boolean`) all have corresponding reference types known as *boxed types* (for example `Integer`, `Float`, `Boolean`). These boxed types can be used when an actual object is required. While they all provide constructors that take a primitive value of the appropriate type, it is usually considered bad practice to call those constructors directly.\n\nEach boxed type provides a static `valueOf` method that takes an argument of the appropriate primitive type and returns an object representing it. The advantage of calling `valueOf` over calling a constructor is that it allows for some caching of instances. By reusing these cached instances instead of constructing new heap objects all the time, a significant amount of garbage collector effort can be saved.\n\n\n## Recommendation\nIn almost all circumstances, a call of, for example, `Integer.valueOf(42)` can be used instead of `new Integer(42)`.\n\nNote that sometimes you can rely on Java's *autoboxing* feature, which implicitly calls `valueOf`. For details, see the example.\n\n\n## Example\nThe following example shows the three ways of creating a new integer. In the autoboxing example, the zero is autoboxed to an `Integer` because the constructor `Account` takes an argument of this type.\n\n\n```java\npublic class Account {\n\tprivate Integer balance;\n\tpublic Account(Integer startingBalance) {\n\t\tthis.balance = startingBalance;\n\t}\n}\n\npublic class BankManager {\n\tpublic void openAccount(Customer c) {\n\t\t...\n\t\t// AVOID: Inefficient primitive constructor\n\t\taccounts.add(new Account(new Integer(0)));\n\t\t// GOOD: Use 'valueOf'\n\t\taccounts.add(new Account(Integer.valueOf(0)));\n\t\t// GOOD: Rely on autoboxing\n\t\taccounts.add(new Account(0));\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 1 and 5. Addison-Wesley, 2008.\n* Java API Specification: [Boolean.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Boolean.html#valueOf(boolean)), [Byte.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Byte.html#valueOf(byte)), [Short.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Short.html#valueOf(short)), [Character.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#valueOf(char)), [Integer.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#valueOf(int)), [Long.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html#valueOf(long)), [Float.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Float.html#valueOf(float)), [Double.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#valueOf(double)).\n","markdown":"# Inefficient primitive constructor\nPrimitive values (for example `int`, `float`, `boolean`) all have corresponding reference types known as *boxed types* (for example `Integer`, `Float`, `Boolean`). These boxed types can be used when an actual object is required. While they all provide constructors that take a primitive value of the appropriate type, it is usually considered bad practice to call those constructors directly.\n\nEach boxed type provides a static `valueOf` method that takes an argument of the appropriate primitive type and returns an object representing it. The advantage of calling `valueOf` over calling a constructor is that it allows for some caching of instances. By reusing these cached instances instead of constructing new heap objects all the time, a significant amount of garbage collector effort can be saved.\n\n\n## Recommendation\nIn almost all circumstances, a call of, for example, `Integer.valueOf(42)` can be used instead of `new Integer(42)`.\n\nNote that sometimes you can rely on Java's *autoboxing* feature, which implicitly calls `valueOf`. For details, see the example.\n\n\n## Example\nThe following example shows the three ways of creating a new integer. In the autoboxing example, the zero is autoboxed to an `Integer` because the constructor `Account` takes an argument of this type.\n\n\n```java\npublic class Account {\n\tprivate Integer balance;\n\tpublic Account(Integer startingBalance) {\n\t\tthis.balance = startingBalance;\n\t}\n}\n\npublic class BankManager {\n\tpublic void openAccount(Customer c) {\n\t\t...\n\t\t// AVOID: Inefficient primitive constructor\n\t\taccounts.add(new Account(new Integer(0)));\n\t\t// GOOD: Use 'valueOf'\n\t\taccounts.add(new Account(Integer.valueOf(0)));\n\t\t// GOOD: Rely on autoboxing\n\t\taccounts.add(new Account(0));\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 1 and 5. Addison-Wesley, 2008.\n* Java API Specification: [Boolean.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Boolean.html#valueOf(boolean)), [Byte.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Byte.html#valueOf(byte)), [Short.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Short.html#valueOf(short)), [Character.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#valueOf(char)), [Integer.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#valueOf(int)), [Long.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html#valueOf(long)), [Float.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Float.html#valueOf(float)), [Double.valueOf()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#valueOf(double)).\n"},"properties":{"tags":["efficiency","maintainability"],"description":"Calling the constructor of a boxed type is inefficient.","id":"java/inefficient-boxed-constructor","kind":"problem","name":"Inefficient primitive constructor","precision":"high","problem.severity":"recommendation"}},{"id":"java/inefficient-key-set-iterator","name":"java/inefficient-key-set-iterator","shortDescription":{"text":"Inefficient use of key set iterator"},"fullDescription":{"text":"Iterating through the values of a map using the key set is inefficient."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Inefficient use of key set iterator\nJava's Collections Framework provides several different ways of iterating the contents of a map. You can retrieve the set of keys, the collection of values, or the set of \"entries\" (which are, in effect, key/value pairs).\n\nThe choice of iterator can affect performance. For example, it is considered bad practice to iterate the key set of a map if the body of the loop performs a map lookup on each retrieved key anyway.\n\n\n## Recommendation\nEvaluate the requirements of the loop body. If it does not actually need the key apart from looking it up in the map, iterate the map's values (obtained by a call to `values`) instead. If the loop genuinely needs both key and value for each mapping in the map, iterate the entry set (obtained by a call to `entrySet`) and retrieve the key and value from each entry. This saves a more expensive map lookup each time.\n\n\n## Example\nIn the following example, the first version of the method `findId` iterates the map `people` using the key set. This is inefficient because the body of the loop needs to access the value for each key. In contrast, the second version iterates the map using the entry set because the loop body needs both the key and the value for each mapping.\n\n\n```java\n// AVOID: Iterate the map using the key set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\tpublic String findId(String first, String last) {\n\t\tfor (String id : people.keySet()) {\n\t\t\tPerson p = people.get(id);\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\t\t\t\treturn id;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n// GOOD: Iterate the map using the entry set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\tpublic String findId(String first, String last) {\n\t\tfor (Entry<String, Person> entry: people.entrySet()) {\n\t\t\tPerson p = entry.getValue();\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\t\t\t\treturn entry.getKey();\n\t\t}\n\t\treturn null;\n\t}\n}\n```\n\n## References\n* Java API Specification: [Map.entrySet()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#entrySet()).\n","markdown":"# Inefficient use of key set iterator\nJava's Collections Framework provides several different ways of iterating the contents of a map. You can retrieve the set of keys, the collection of values, or the set of \"entries\" (which are, in effect, key/value pairs).\n\nThe choice of iterator can affect performance. For example, it is considered bad practice to iterate the key set of a map if the body of the loop performs a map lookup on each retrieved key anyway.\n\n\n## Recommendation\nEvaluate the requirements of the loop body. If it does not actually need the key apart from looking it up in the map, iterate the map's values (obtained by a call to `values`) instead. If the loop genuinely needs both key and value for each mapping in the map, iterate the entry set (obtained by a call to `entrySet`) and retrieve the key and value from each entry. This saves a more expensive map lookup each time.\n\n\n## Example\nIn the following example, the first version of the method `findId` iterates the map `people` using the key set. This is inefficient because the body of the loop needs to access the value for each key. In contrast, the second version iterates the map using the entry set because the loop body needs both the key and the value for each mapping.\n\n\n```java\n// AVOID: Iterate the map using the key set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\tpublic String findId(String first, String last) {\n\t\tfor (String id : people.keySet()) {\n\t\t\tPerson p = people.get(id);\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\t\t\t\treturn id;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n// GOOD: Iterate the map using the entry set.\nclass AddressBook {\n\tprivate Map<String, Person> people = ...;\n\tpublic String findId(String first, String last) {\n\t\tfor (Entry<String, Person> entry: people.entrySet()) {\n\t\t\tPerson p = entry.getValue();\n\t\t\tif (first.equals(p.firstName()) && last.equals(p.lastName()))\n\t\t\t\treturn entry.getKey();\n\t\t}\n\t\treturn null;\n\t}\n}\n```\n\n## References\n* Java API Specification: [Map.entrySet()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#entrySet()).\n"},"properties":{"tags":["efficiency","maintainability"],"description":"Iterating through the values of a map using the key set is inefficient.","id":"java/inefficient-key-set-iterator","kind":"problem","name":"Inefficient use of key set iterator","precision":"high","problem.severity":"recommendation"}},{"id":"java/inefficient-empty-string-test","name":"java/inefficient-empty-string-test","shortDescription":{"text":"Inefficient empty string test"},"fullDescription":{"text":"Checking a string for equality with an empty string is inefficient."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Inefficient empty string test\nWhen checking whether a string `s` is empty, perhaps the most obvious solution is to write something like `s.equals(\"\")` (or `\"\".equals(s)`). However, this actually carries a fairly significant overhead, because `String.equals` performs a number of type tests and conversions before starting to compare the content of the strings.\n\n\n## Recommendation\nThe preferred way of checking whether a string `s` is empty is to check if its length is equal to zero. Thus, the condition is `s.length() == 0`. The `length` method is implemented as a simple field access, and so should be noticeably faster than calling `equals`.\n\nNote that in Java 6 and later, the `String` class has an `isEmpty` method that checks whether a string is empty. If the codebase does not need to support Java 5, it may be better to use that method instead.\n\n\n## Example\nIn the following example, class `InefficientDBClient` uses `equals` to test whether the strings `user` and `pw` are empty. Note that the test `\"\".equals(pw)` guards against `NullPointerException`, but the test `user.equals(\"\")` throws a `NullPointerException` if `user` is `null`.\n\nIn contrast, the class `EfficientDBClient` uses `length` instead of `equals`. The class preserves the behavior of `InefficientDBClient` by guarding `pw.length() == 0` but not `user.length() == 0` with an explicit test for `null`. Whether or not this guard is desirable depends on the intended behavior of the program.\n\n\n```java\n// Inefficient version\nclass InefficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\tif (user.equals(\"\") || \"\".equals(pw))\n\t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n// More efficient version\nclass EfficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\tif (user.length() == 0 || (pw != null && pw.length() == 0))\n\t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n```\n\n## References\n* Java API Specification: [String.length()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#length()), [String.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isEmpty()), [String.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#equals(java.lang.Object)).\n","markdown":"# Inefficient empty string test\nWhen checking whether a string `s` is empty, perhaps the most obvious solution is to write something like `s.equals(\"\")` (or `\"\".equals(s)`). However, this actually carries a fairly significant overhead, because `String.equals` performs a number of type tests and conversions before starting to compare the content of the strings.\n\n\n## Recommendation\nThe preferred way of checking whether a string `s` is empty is to check if its length is equal to zero. Thus, the condition is `s.length() == 0`. The `length` method is implemented as a simple field access, and so should be noticeably faster than calling `equals`.\n\nNote that in Java 6 and later, the `String` class has an `isEmpty` method that checks whether a string is empty. If the codebase does not need to support Java 5, it may be better to use that method instead.\n\n\n## Example\nIn the following example, class `InefficientDBClient` uses `equals` to test whether the strings `user` and `pw` are empty. Note that the test `\"\".equals(pw)` guards against `NullPointerException`, but the test `user.equals(\"\")` throws a `NullPointerException` if `user` is `null`.\n\nIn contrast, the class `EfficientDBClient` uses `length` instead of `equals`. The class preserves the behavior of `InefficientDBClient` by guarding `pw.length() == 0` but not `user.length() == 0` with an explicit test for `null`. Whether or not this guard is desirable depends on the intended behavior of the program.\n\n\n```java\n// Inefficient version\nclass InefficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\tif (user.equals(\"\") || \"\".equals(pw))\n\t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n// More efficient version\nclass EfficientDBClient {\n\tpublic void connect(String user, String pw) {\n\t\tif (user.length() == 0 || (pw != null && pw.length() == 0))\n\t\t\tthrow new RuntimeException();\n\t\t...\n\t}\n}\n\n```\n\n## References\n* Java API Specification: [String.length()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#length()), [String.isEmpty()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#isEmpty()), [String.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#equals(java.lang.Object)).\n"},"properties":{"tags":["efficiency","maintainability"],"description":"Checking a string for equality with an empty string is inefficient.","id":"java/inefficient-empty-string-test","kind":"problem","name":"Inefficient empty string test","precision":"high","problem.severity":"recommendation"}},{"id":"java/inefficient-output-stream","name":"java/inefficient-output-stream","shortDescription":{"text":"Inefficient output stream"},"fullDescription":{"text":"Using the default implementation of 'write(byte[],int,int)' provided by 'java.io.OutputStream' is very inefficient."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Inefficient output stream\nThe classes `java.io.OutputStream` and `java.io.FilterOutputStream` only require subclasses to implement the method `write(byte b)`. Typically, uses of `OutputStream`s will not write single bytes, but an array via the `write(byte[] b, int off, int len)` method. The default implementation of this method, which you are not required to override, calls `write(byte b)` for each byte in the array. If this method involves I/O, such as accessing the network or disk, this is likely to incur significant overhead.\n\n\n## Recommendation\nAlways provide an implementation of the `write(byte[] b, int off, int len)` method.\n\n\n## Example\nThe following example shows a subclass of `OutputStream` that simply wraps a `DigestOutputStream` to confirm that the data it writes to a file has the expected MD5 hash. Without an implementation of `write(byte[] b, int off, int len)` this will be very slow, because it makes a call to `DigestOutputStream.write(byte b)` and `FileOutputStream.write(byte b)` for each byte written.\n\n\n```java\npublic class DigestCheckingFileOutputStream extends OutputStream {\n\tprivate DigestOutputStream digest;\n\tprivate byte[] expectedMD5;\n\n\tpublic DigestCheckingFileOutputStream(File file, byte[] expectedMD5)\n\t\tthrows IOException, NoSuchAlgorithmException {\n\t\t\tthis.expectedMD5 = expectedMD5;\n\t\t\tdigest = new DigestOutputStream(new FileOutputStream(file),\n\t\t\t\t\t\t\t\t\t\t\tMessageDigest.getInstance(\"MD5\"));\n\t\t}\n\n\t@Override\n\tpublic void write(int b) throws IOException {\n\t\tdigest.write(b);\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\tsuper.close();\n\n\t\tdigest.close();\n\t\tbyte[] md5 = digest.getMessageDigest().digest();\n\t\tif (expectedMD5 != null && !Arrays.equals(expectedMD5, md5)) {\n\t\t\tthrow new InternalError();\n\t\t}\n\t}\n}\n\n```\nThe example can be updated to use a more efficient method. In this case, calls to `write(byte[] b, int off, int len)` are simply forwarded to `DigestOutputStream.write(byte[] b, int off, int len)`.\n\n\n```java\npublic class DigestCheckingFileOutputStream extends OutputStream {\n\tprivate DigestOutputStream digest;\n\tprivate byte[] expectedMD5;\n\n\tpublic DigestCheckingFileOutputStream(File file, byte[] expectedMD5)\n\t\tthrows IOException, NoSuchAlgorithmException {\n\t\t\tthis.expectedMD5 = expectedMD5;\n\t\t\tdigest = new DigestOutputStream(new FileOutputStream(file),\n\t\t\t\t\t\t\t\t\t\t\tMessageDigest.getInstance(\"MD5\"));\n\t\t}\n\n\t@Override\n\tpublic void write(int b) throws IOException {\n\t\tdigest.write(b);\n\t}\n\n\t@Override\n\tpublic void write(byte[] b, int off, int len) throws IOException {\n\t\tdigest.write(b, off, len);\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\tsuper.close();\n\n\t\tdigest.close();\n\t\tbyte[] md5 = digest.getMessageDigest().digest();\n\t\tif (expectedMD5 != null && !Arrays.equals(expectedMD5, md5)) {\n\t\t\tthrow new InternalError();\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Java API Specification: [OutputStream.write(byte\\[\\] b, int off, int len)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/OutputStream.html#write(byte[],int,int)), [FilterOutputStream.write(byte\\[\\] b, int off, int len)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FilterOutputStream.html#write(byte[],int,int)).\n","markdown":"# Inefficient output stream\nThe classes `java.io.OutputStream` and `java.io.FilterOutputStream` only require subclasses to implement the method `write(byte b)`. Typically, uses of `OutputStream`s will not write single bytes, but an array via the `write(byte[] b, int off, int len)` method. The default implementation of this method, which you are not required to override, calls `write(byte b)` for each byte in the array. If this method involves I/O, such as accessing the network or disk, this is likely to incur significant overhead.\n\n\n## Recommendation\nAlways provide an implementation of the `write(byte[] b, int off, int len)` method.\n\n\n## Example\nThe following example shows a subclass of `OutputStream` that simply wraps a `DigestOutputStream` to confirm that the data it writes to a file has the expected MD5 hash. Without an implementation of `write(byte[] b, int off, int len)` this will be very slow, because it makes a call to `DigestOutputStream.write(byte b)` and `FileOutputStream.write(byte b)` for each byte written.\n\n\n```java\npublic class DigestCheckingFileOutputStream extends OutputStream {\n\tprivate DigestOutputStream digest;\n\tprivate byte[] expectedMD5;\n\n\tpublic DigestCheckingFileOutputStream(File file, byte[] expectedMD5)\n\t\tthrows IOException, NoSuchAlgorithmException {\n\t\t\tthis.expectedMD5 = expectedMD5;\n\t\t\tdigest = new DigestOutputStream(new FileOutputStream(file),\n\t\t\t\t\t\t\t\t\t\t\tMessageDigest.getInstance(\"MD5\"));\n\t\t}\n\n\t@Override\n\tpublic void write(int b) throws IOException {\n\t\tdigest.write(b);\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\tsuper.close();\n\n\t\tdigest.close();\n\t\tbyte[] md5 = digest.getMessageDigest().digest();\n\t\tif (expectedMD5 != null && !Arrays.equals(expectedMD5, md5)) {\n\t\t\tthrow new InternalError();\n\t\t}\n\t}\n}\n\n```\nThe example can be updated to use a more efficient method. In this case, calls to `write(byte[] b, int off, int len)` are simply forwarded to `DigestOutputStream.write(byte[] b, int off, int len)`.\n\n\n```java\npublic class DigestCheckingFileOutputStream extends OutputStream {\n\tprivate DigestOutputStream digest;\n\tprivate byte[] expectedMD5;\n\n\tpublic DigestCheckingFileOutputStream(File file, byte[] expectedMD5)\n\t\tthrows IOException, NoSuchAlgorithmException {\n\t\t\tthis.expectedMD5 = expectedMD5;\n\t\t\tdigest = new DigestOutputStream(new FileOutputStream(file),\n\t\t\t\t\t\t\t\t\t\t\tMessageDigest.getInstance(\"MD5\"));\n\t\t}\n\n\t@Override\n\tpublic void write(int b) throws IOException {\n\t\tdigest.write(b);\n\t}\n\n\t@Override\n\tpublic void write(byte[] b, int off, int len) throws IOException {\n\t\tdigest.write(b, off, len);\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\tsuper.close();\n\n\t\tdigest.close();\n\t\tbyte[] md5 = digest.getMessageDigest().digest();\n\t\tif (expectedMD5 != null && !Arrays.equals(expectedMD5, md5)) {\n\t\t\tthrow new InternalError();\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Java API Specification: [OutputStream.write(byte\\[\\] b, int off, int len)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/OutputStream.html#write(byte[],int,int)), [FilterOutputStream.write(byte\\[\\] b, int off, int len)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FilterOutputStream.html#write(byte[],int,int)).\n"},"properties":{"tags":["efficiency"],"description":"Using the default implementation of 'write(byte[],int,int)'\n              provided by 'java.io.OutputStream' is very inefficient.","id":"java/inefficient-output-stream","kind":"problem","name":"Inefficient output stream","precision":"very-high","problem.severity":"warning"}},{"id":"java/non-static-nested-class","name":"java/non-static-nested-class","shortDescription":{"text":"Inner class could be static"},"fullDescription":{"text":"A non-static nested class keeps a reference to the enclosing object, which makes the nested class bigger and may cause a memory leak."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Inner class could be static\nNested classes allow logical grouping of related concerns, increasing encapsulation and readability. However, there is a potential disadvantage when using them that you should be aware of.\n\nAny non-static nested class implicitly holds onto its \"enclosing instance\". This means that:\n\n* The nested class has an implicitly defined field. The field holds a reference to the instance of the enclosing class that constructed the nested class.\n* The nested class's constructors have an implicit parameter. The parameter is used for passing in the instance of the enclosing class. A reference to the instance is then stored in the field mentioned above.\nOften, this is useful and necessary, because non-static nested class instances have access to instance state on their enclosing classes. However, if this instance state is not needed by the nested class, this makes nested class instances larger than necessary, and hidden references to the enclosing classes are often the source of subtle memory leaks.\n\n\n## Recommendation\nWhen a nested class does not need the enclosing instance, it is better to declare the nested class `static`, avoiding the implicit field. As a result, instances of the nested class become smaller, and hidden references to the enclosing class are made explicit.\n\nIf a reference to the enclosing class instance is required during construction of the nested class instance (but not subsequently), the constructor of the nested class should be refactored so that it is explicitly given a reference to the enclosing instance.\n\nIf the nested class refers to a type variable of an enclosing class instance, consider parameterizing the nested class by that type variable.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 22. Addison-Wesley, 2008.\n* Java Language Specification: [8.1.3. Inner Classes and Enclosing Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.3).\n* The Java Tutorials: [Nested Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html).\n","markdown":"# Inner class could be static\nNested classes allow logical grouping of related concerns, increasing encapsulation and readability. However, there is a potential disadvantage when using them that you should be aware of.\n\nAny non-static nested class implicitly holds onto its \"enclosing instance\". This means that:\n\n* The nested class has an implicitly defined field. The field holds a reference to the instance of the enclosing class that constructed the nested class.\n* The nested class's constructors have an implicit parameter. The parameter is used for passing in the instance of the enclosing class. A reference to the instance is then stored in the field mentioned above.\nOften, this is useful and necessary, because non-static nested class instances have access to instance state on their enclosing classes. However, if this instance state is not needed by the nested class, this makes nested class instances larger than necessary, and hidden references to the enclosing classes are often the source of subtle memory leaks.\n\n\n## Recommendation\nWhen a nested class does not need the enclosing instance, it is better to declare the nested class `static`, avoiding the implicit field. As a result, instances of the nested class become smaller, and hidden references to the enclosing class are made explicit.\n\nIf a reference to the enclosing class instance is required during construction of the nested class instance (but not subsequently), the constructor of the nested class should be refactored so that it is explicitly given a reference to the enclosing instance.\n\nIf the nested class refers to a type variable of an enclosing class instance, consider parameterizing the nested class by that type variable.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 22. Addison-Wesley, 2008.\n* Java Language Specification: [8.1.3. Inner Classes and Enclosing Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.3).\n* The Java Tutorials: [Nested Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html).\n"},"properties":{"tags":["efficiency","maintainability"],"description":"A non-static nested class keeps a reference to the enclosing object,\n              which makes the nested class bigger and may cause a memory leak.","id":"java/non-static-nested-class","kind":"problem","name":"Inner class could be static","precision":"high","problem.severity":"recommendation"}},{"id":"java/inefficient-string-constructor","name":"java/inefficient-string-constructor","shortDescription":{"text":"Inefficient String constructor"},"fullDescription":{"text":"Using the 'String(String)' constructor is less memory efficient than using the constructor argument directly."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Inefficient String constructor\nThe `String` class is immutable, which means that there is no way to change the string that it represents. Consequently, there is rarely a need to copy a `String` object or construct a new instance based on an existing string, for example by writing something like `String hello = new String(\"hello\")`. Furthermore, this practice is not memory efficient.\n\n\n## Recommendation\nThe copied string is functionally indistinguishable from the argument that was passed into the `String` constructor, so you can simply omit the constructor call and use the argument passed into it directly. Unless an explicit copy of the argument string is needed, this is a safe transformation.\n\n\n## Example\nThe following example shows three cases of copying a string using the `String` constructor, which is inefficient. In each case, simply removing the constructor call `new String` and leaving the argument results in better code and less memory churn.\n\n\n```java\npublic void sayHello(String world) {\n\t// AVOID: Inefficient 'String' constructor\n\tString message = new String(\"hello \");\n\n\t// AVOID: Inefficient 'String' constructor\n\tmessage = new String(message + world);\n\n\t// AVOID: Inefficient 'String' constructor\n\tSystem.out.println(new String(message));\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 5. Addison-Wesley, 2008.\n* Java API Specification: [String(String)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#%3Cinit%3E(java.lang.String)).\n","markdown":"# Inefficient String constructor\nThe `String` class is immutable, which means that there is no way to change the string that it represents. Consequently, there is rarely a need to copy a `String` object or construct a new instance based on an existing string, for example by writing something like `String hello = new String(\"hello\")`. Furthermore, this practice is not memory efficient.\n\n\n## Recommendation\nThe copied string is functionally indistinguishable from the argument that was passed into the `String` constructor, so you can simply omit the constructor call and use the argument passed into it directly. Unless an explicit copy of the argument string is needed, this is a safe transformation.\n\n\n## Example\nThe following example shows three cases of copying a string using the `String` constructor, which is inefficient. In each case, simply removing the constructor call `new String` and leaving the argument results in better code and less memory churn.\n\n\n```java\npublic void sayHello(String world) {\n\t// AVOID: Inefficient 'String' constructor\n\tString message = new String(\"hello \");\n\n\t// AVOID: Inefficient 'String' constructor\n\tmessage = new String(message + world);\n\n\t// AVOID: Inefficient 'String' constructor\n\tSystem.out.println(new String(message));\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 5. Addison-Wesley, 2008.\n* Java API Specification: [String(String)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#%3Cinit%3E(java.lang.String)).\n"},"properties":{"tags":["efficiency","maintainability"],"description":"Using the 'String(String)' constructor is less memory efficient than using the\n              constructor argument directly.","id":"java/inefficient-string-constructor","kind":"problem","name":"Inefficient String constructor","precision":"high","problem.severity":"recommendation"}},{"id":"java/iterator-implements-iterable","name":"java/iterator-implements-iterable","shortDescription":{"text":"Iterator implementing Iterable"},"fullDescription":{"text":"An 'Iterator' that also implements 'Iterable' by returning itself as its 'Iterator' does not support multiple traversals. This can lead to unexpected behavior when it is viewed as an 'Iterable'."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Iterator implementing Iterable\nJava has two interfaces for dealing with iteration, `Iterable<T>` and `Iterator<T>`. An `Iterable<T>` represents a sequence of elements that can be traversed, and an `Iterator<T>` represents the **state** of an ongoing traversal. As an example, all the `Collection<T>` classes in the Java standard library implement `Iterable<T>`. Comparing this to a traditional `for` loop that increments an integer index and iterates over the elements of an array, then the `Iterable<T>` object corresponds to the array, whereas the `Iterator<T>` object corresponds to the index variable.\n\nImplementations of `Iterable<T>` are generally expected to support multiple traversals of the element sequence they represent, although there can be exceptions if the underlying data somehow makes this undesirable, see for example `DirectoryStream<T>`. If an implementation of `Iterable<T>` does not support multiple iterations, then its `iterator()` method should throw an exception on its second and subsequent calls. This makes bugs easier to find if such an `Iterable<T>` is used more than once, for example in two different for-each loops.\n\n\n## Recommendation\nWhen working with custom implementations of `Iterator<T>` it is easy to add `implements Iterable<T>` and a simple `return this;` implementation of `iterator()` to support the for-each syntax. This can, however, hide subtle bugs and is therefore not recommended. It is better to separate the two and use a main representation that only implements `Iterable<T>` without containing any iteration state. This object can then return a short-lived `Iterator<T>` each time it needs to be traversed.\n\nIf this refactoring is undesirable for some reason, then the `iterator()` method should at the very least throw an exception if called more than once.\n\n\n## Example\nThe following example does not distinguish the iterable from its iterator, and therefore causes the second loop to terminate immediately without any effect.\n\n\n```java\nclass ElemIterator implements Iterator<MyElem>, Iterable<MyElem> {\n  private MyElem[] data;\n  private idx = 0;\n\n  public boolean hasNext() {\n    return idx < data.length;\n  }\n  public MyElem next() {\n    return data[idx++];\n  }\n  public Iterator<MyElem> iterator() {\n    return this;\n  }\n  // ...\n}\n\nvoid useMySequence(Iterable<MyElem> s) {\n  // do some work by traversing the sequence\n  for (MyElem e : s) {\n    // ...\n  }\n  // do some more work by traversing it again\n  for (MyElem e : s) {\n    // ...\n  }\n}\n\n```\nThe best solution is a refactoring along the following lines where `Iterable` classes are used to pass around references to data. This allows the `Iterator` instances to be short-lived and avoids the sharing of iteration state.\n\n\n```java\nclass ElemSequence implements Iterable<MyElem> {\n  private MyElem[] data;\n\n  public Iterator<MyElem> iterator() {\n    return new Iterator<MyElem>() {\n      private idx = 0;\n      public boolean hasNext() {\n        return idx < data.length;\n      }\n      public MyElem next() {\n        return data[idx++];\n      }\n    };\n  }\n  // ...\n}\n\n```\nIf a refactoring, as described above, is too cumbersome or is otherwise undesirable, then a guard can be inserted, as shown below. Using a guard ensures that multiple iteration fails early, making it easier to find any related bugs. This solution is less ideal than the refactoring above, but nevertheless an improvement over the original.\n\n\n```java\nclass ElemIterator implements Iterator<MyElem>, Iterable<MyElem> {\n  private MyElem[] data;\n  private idx = 0;\n  private boolean usedAsIterable = false;\n\n  public boolean hasNext() {\n    return idx < data.length;\n  }\n  public MyElem next() {\n    return data[idx++];\n  }\n  public Iterator<MyElem> iterator() {\n    if (usedAsIterable || idx > 0)\n      throw new IllegalStateException();\n    usedAsIterable = true;\n    return this;\n  }\n  // ...\n}\n\n```\n\n## References\n* Java Language Specification: [The enhanced for statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.2).\n* Java API Specification: [Interface Iterable&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Iterable.html), [Interface Iterator&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html), [Interface DirectoryStream&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/DirectoryStream.html).\n","markdown":"# Iterator implementing Iterable\nJava has two interfaces for dealing with iteration, `Iterable<T>` and `Iterator<T>`. An `Iterable<T>` represents a sequence of elements that can be traversed, and an `Iterator<T>` represents the **state** of an ongoing traversal. As an example, all the `Collection<T>` classes in the Java standard library implement `Iterable<T>`. Comparing this to a traditional `for` loop that increments an integer index and iterates over the elements of an array, then the `Iterable<T>` object corresponds to the array, whereas the `Iterator<T>` object corresponds to the index variable.\n\nImplementations of `Iterable<T>` are generally expected to support multiple traversals of the element sequence they represent, although there can be exceptions if the underlying data somehow makes this undesirable, see for example `DirectoryStream<T>`. If an implementation of `Iterable<T>` does not support multiple iterations, then its `iterator()` method should throw an exception on its second and subsequent calls. This makes bugs easier to find if such an `Iterable<T>` is used more than once, for example in two different for-each loops.\n\n\n## Recommendation\nWhen working with custom implementations of `Iterator<T>` it is easy to add `implements Iterable<T>` and a simple `return this;` implementation of `iterator()` to support the for-each syntax. This can, however, hide subtle bugs and is therefore not recommended. It is better to separate the two and use a main representation that only implements `Iterable<T>` without containing any iteration state. This object can then return a short-lived `Iterator<T>` each time it needs to be traversed.\n\nIf this refactoring is undesirable for some reason, then the `iterator()` method should at the very least throw an exception if called more than once.\n\n\n## Example\nThe following example does not distinguish the iterable from its iterator, and therefore causes the second loop to terminate immediately without any effect.\n\n\n```java\nclass ElemIterator implements Iterator<MyElem>, Iterable<MyElem> {\n  private MyElem[] data;\n  private idx = 0;\n\n  public boolean hasNext() {\n    return idx < data.length;\n  }\n  public MyElem next() {\n    return data[idx++];\n  }\n  public Iterator<MyElem> iterator() {\n    return this;\n  }\n  // ...\n}\n\nvoid useMySequence(Iterable<MyElem> s) {\n  // do some work by traversing the sequence\n  for (MyElem e : s) {\n    // ...\n  }\n  // do some more work by traversing it again\n  for (MyElem e : s) {\n    // ...\n  }\n}\n\n```\nThe best solution is a refactoring along the following lines where `Iterable` classes are used to pass around references to data. This allows the `Iterator` instances to be short-lived and avoids the sharing of iteration state.\n\n\n```java\nclass ElemSequence implements Iterable<MyElem> {\n  private MyElem[] data;\n\n  public Iterator<MyElem> iterator() {\n    return new Iterator<MyElem>() {\n      private idx = 0;\n      public boolean hasNext() {\n        return idx < data.length;\n      }\n      public MyElem next() {\n        return data[idx++];\n      }\n    };\n  }\n  // ...\n}\n\n```\nIf a refactoring, as described above, is too cumbersome or is otherwise undesirable, then a guard can be inserted, as shown below. Using a guard ensures that multiple iteration fails early, making it easier to find any related bugs. This solution is less ideal than the refactoring above, but nevertheless an improvement over the original.\n\n\n```java\nclass ElemIterator implements Iterator<MyElem>, Iterable<MyElem> {\n  private MyElem[] data;\n  private idx = 0;\n  private boolean usedAsIterable = false;\n\n  public boolean hasNext() {\n    return idx < data.length;\n  }\n  public MyElem next() {\n    return data[idx++];\n  }\n  public Iterator<MyElem> iterator() {\n    if (usedAsIterable || idx > 0)\n      throw new IllegalStateException();\n    usedAsIterable = true;\n    return this;\n  }\n  // ...\n}\n\n```\n\n## References\n* Java Language Specification: [The enhanced for statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.2).\n* Java API Specification: [Interface Iterable&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Iterable.html), [Interface Iterator&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html), [Interface DirectoryStream&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/DirectoryStream.html).\n"},"properties":{"tags":["correctness","reliability"],"description":"An 'Iterator' that also implements 'Iterable' by returning itself as its 'Iterator'\n              does not support multiple traversals. This can lead to unexpected behavior when\n              it is viewed as an 'Iterable'.","id":"java/iterator-implements-iterable","kind":"problem","name":"Iterator implementing Iterable","precision":"very-high","problem.severity":"warning"}},{"id":"java/useless-type-test","name":"java/useless-type-test","shortDescription":{"text":"Useless type test"},"fullDescription":{"text":"Testing whether a derived type is an instance of its base type is unnecessary."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Useless type test\nIt is always the case that, for any type `B`, an instance of a type derived from `B` is also an instance of `B`. There is no need to explicitly test that this relationship exists.\n\n\n## Recommendation\nRemove the unnecessary type test to simplify the code.\n\n\n## Example\nThe following example shows an unnecessary type test.\n\n\n```java\npublic class UselessTypeTest {\n\tprivate static class B {}\n\tprivate static class D extends B {}\n\n\tpublic static void main(String[] args) {\n\t\tD d = new D();\n\t\tif(d instanceof B) {\t// violation\n\t\t\tSystem.out.println(\"Mon dieu, d is a B!\");\n\t\t}\n\t}\n}\n```\n","markdown":"# Useless type test\nIt is always the case that, for any type `B`, an instance of a type derived from `B` is also an instance of `B`. There is no need to explicitly test that this relationship exists.\n\n\n## Recommendation\nRemove the unnecessary type test to simplify the code.\n\n\n## Example\nThe following example shows an unnecessary type test.\n\n\n```java\npublic class UselessTypeTest {\n\tprivate static class B {}\n\tprivate static class D extends B {}\n\n\tpublic static void main(String[] args) {\n\t\tD d = new D();\n\t\tif(d instanceof B) {\t// violation\n\t\t\tSystem.out.println(\"Mon dieu, d is a B!\");\n\t\t}\n\t}\n}\n```\n"},"properties":{"tags":["maintainability","language-features","external/cwe/cwe-561"],"description":"Testing whether a derived type is an instance of its base type is unnecessary.","id":"java/useless-type-test","kind":"problem","name":"Useless type test","precision":"very-high","problem.severity":"warning"}},{"id":"java/useless-null-check","name":"java/useless-null-check","shortDescription":{"text":"Useless null check"},"fullDescription":{"text":"Checking whether an expression is null when that expression cannot possibly be null is useless."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Useless null check\nSometimes you can guarantee that a particular variable will never be null. For example when that variable has just been assigned a newly created object or is the exception caught by a `catch` clause. A null check on such a variable is misleading, and can potentially indicate a logic error.\n\n\n## Recommendation\nDo not check a variable for null if a null value is clearly impossible.\n\n\n## Example\nThe following example shows a null check on a newly created object. An object returned by `new` can never be null, so this check is superfluous.\n\n\n```java\nObject o = new Object();\nif (o == null) {\n  // this cannot happen!\n}\n\n```\n\n## References\n* Java Language Specification: [Creation of New Class Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.5), [Execution of try-catch](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.1).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n","markdown":"# Useless null check\nSometimes you can guarantee that a particular variable will never be null. For example when that variable has just been assigned a newly created object or is the exception caught by a `catch` clause. A null check on such a variable is misleading, and can potentially indicate a logic error.\n\n\n## Recommendation\nDo not check a variable for null if a null value is clearly impossible.\n\n\n## Example\nThe following example shows a null check on a newly created object. An object returned by `new` can never be null, so this check is superfluous.\n\n\n```java\nObject o = new Object();\nif (o == null) {\n  // this cannot happen!\n}\n\n```\n\n## References\n* Java Language Specification: [Creation of New Class Instances](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.5), [Execution of try-catch](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.20.1).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"},"properties":{"tags":["maintainability","useless-code","external/cwe/cwe-561"],"description":"Checking whether an expression is null when that expression cannot\n              possibly be null is useless.","id":"java/useless-null-check","kind":"problem","name":"Useless null check","precision":"very-high","problem.severity":"warning"}},{"id":"java/chained-type-tests","name":"java/chained-type-tests","shortDescription":{"text":"Chain of 'instanceof' tests"},"fullDescription":{"text":"Long sequences of type tests on a variable are difficult to maintain."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Chain of 'instanceof' tests\nLong sequences of type tests are often used to dispatch control to different branches of the code based on the type of a variable, as shown in the example below. They are often used to simulate pattern-matching in languages that do not support it. Whilst this works as a dispatch method, there are a number of problems:\n\n* They are difficult to maintain. It is easy to add a new subtype and forget to modify all of the type test sequences throughout your code.\n* They introduce unwanted dependencies on concrete classes. Code cannot be written only in terms of an interface but must instead be written considering all of the different special cases.\n* They can be error-prone - it is easy to test for a base type before a derived type, resulting in a failure to execute the code handling the derived type.\n\n## Recommendation\nThere are a number of different possible solutions to this problem:\n\n* **Polymorphism**. You can add a virtual method to the type hierarchy and put the segments of code to be called in the relevant override for each concrete class. This is a good solution when: (a) you can change the type hierarchy and (b) the operation being implemented is core functionality that the types should implement. If you implement this solution then you must be careful not to introduce unwanted dependencies. If the operation depends on entities that themselves depend on the type hierarchy, then you cannot move the operation to the type hierarchy without creating a dependency cycle.\n* **The visitor pattern**. You can introduce a visitor interface containing a visit method for each type in the type hierarchy, and add an `accept` method to each type in the hierarchy that takes a visitor as its parameter. The `accept` method calls the visit method of the visitor on `this`. Concrete visitors then implement the interface and process each specific type as necessary. This is a good solution when: (a) you can change the type hierarchy and (b) the type hierarchy should not know about the operation being implemented (either to avoid dependency or because it is not core functionality for the types in the hierarchy). It is also useful when you want to provide multiple operations with the same structure, on the same set of types, and you want the types themselves to control the way that the operation is structured. For example, \"visit this tree using an in-order walk and apply the operation to each node\". The basic visitor pattern is not suitable for all situations because it is cyclically-dependent, and the infrastructure involved is comparatively heavyweight.\n* **Reflection**. You can look up one of a set of overloaded methods based on the type of one of the method parameters and invoke the method manually. This results in a loss of type safety and is rather untidy, but there are times when it is the best solution. In particular, reflection is useful when you cannot change the type hierarchy, for example, because it is third-party code.\n\n## Example\nThe following example demonstrates the use \"Polymorphism\" and \"The visitor pattern\". More details on reflection can be found in \\[Flanagan\\].\n\n\n```java\nimport java.util.*;\n\npublic class ChainedInstanceof {\n\tpublic static void main(String[] args) {\n\t\t// BAD: example of a sequence of type tests\n\t\tList<BadAnimal> badAnimals = new ArrayList<BadAnimal>();\n\t\tbadAnimals.add(new BadCat());\n\t\tbadAnimals.add(new BadDog());\n\t\tfor(BadAnimal a: badAnimals) {\n\t\t\tif(a instanceof BadCat)      System.out.println(\"Miaow!\");\n\t\t\telse if(a instanceof BadDog) System.out.println(\"Woof!\");\n\t\t\telse                         throw new RuntimeException(\"Oops!\");\n\t\t}\n\n\t\t// GOOD: solution using polymorphism\n\t\tList<PolymorphicAnimal> polymorphicAnimals = new ArrayList<PolymorphicAnimal>();\n\t\tpolymorphicAnimals.add(new PolymorphicCat());\n\t\tpolymorphicAnimals.add(new PolymorphicDog());\n\t\tfor(PolymorphicAnimal a: polymorphicAnimals) a.speak();\n\n\t\t// GOOD: solution using the visitor pattern\n\t\tList<VisitableAnimal> visitableAnimals = new ArrayList<VisitableAnimal>();\n\t\tvisitableAnimals.add(new VisitableCat());\n\t\tvisitableAnimals.add(new VisitableDog());\n\t\tfor(VisitableAnimal a: visitableAnimals) a.accept(new SpeakVisitor());\n\t}\n\n\t//#################### TYPES FOR BAD EXAMPLE ####################\n\n\tprivate interface BadAnimal {}\n\tprivate static class BadCat implements BadAnimal {}\n\tprivate static class BadDog implements BadAnimal {}\n\n\t//#################### TYPES FOR POLYMORPHIC EXAMPLE ####################\n\n\tprivate interface PolymorphicAnimal {\n\t\tvoid speak();\n\t}\n\tprivate static class PolymorphicCat implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"Miaow!\"); }\n\t}\n\tprivate static class PolymorphicDog implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"Woof!\"); }\n\t}\n\n\t//#################### TYPES FOR VISITOR EXAMPLE ####################\n\n\tprivate interface Visitor {\n\t\tvoid visit(VisitableCat c);\n\t\tvoid visit(VisitableDog d);\n\t}\n\tprivate static class SpeakVisitor implements Visitor {\n\t\tpublic void visit(VisitableCat c) { System.out.println(\"Miaow!\"); }\n\t\tpublic void visit(VisitableDog d) { System.out.println(\"Woof!\"); }\n\t}\n\tprivate interface VisitableAnimal {\n\t\tvoid accept(Visitor v);\n\t}\n\tprivate static class VisitableCat implements VisitableAnimal {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n\tprivate static class VisitableDog implements VisitableAnimal {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n}\n\n```\n\n## References\n* D. Flanagan, *Java in a Nutshell: A Desktop Quick Reference*. O'Reilly Media, 1997.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc. Boston, MA, 1995.\n","markdown":"# Chain of 'instanceof' tests\nLong sequences of type tests are often used to dispatch control to different branches of the code based on the type of a variable, as shown in the example below. They are often used to simulate pattern-matching in languages that do not support it. Whilst this works as a dispatch method, there are a number of problems:\n\n* They are difficult to maintain. It is easy to add a new subtype and forget to modify all of the type test sequences throughout your code.\n* They introduce unwanted dependencies on concrete classes. Code cannot be written only in terms of an interface but must instead be written considering all of the different special cases.\n* They can be error-prone - it is easy to test for a base type before a derived type, resulting in a failure to execute the code handling the derived type.\n\n## Recommendation\nThere are a number of different possible solutions to this problem:\n\n* **Polymorphism**. You can add a virtual method to the type hierarchy and put the segments of code to be called in the relevant override for each concrete class. This is a good solution when: (a) you can change the type hierarchy and (b) the operation being implemented is core functionality that the types should implement. If you implement this solution then you must be careful not to introduce unwanted dependencies. If the operation depends on entities that themselves depend on the type hierarchy, then you cannot move the operation to the type hierarchy without creating a dependency cycle.\n* **The visitor pattern**. You can introduce a visitor interface containing a visit method for each type in the type hierarchy, and add an `accept` method to each type in the hierarchy that takes a visitor as its parameter. The `accept` method calls the visit method of the visitor on `this`. Concrete visitors then implement the interface and process each specific type as necessary. This is a good solution when: (a) you can change the type hierarchy and (b) the type hierarchy should not know about the operation being implemented (either to avoid dependency or because it is not core functionality for the types in the hierarchy). It is also useful when you want to provide multiple operations with the same structure, on the same set of types, and you want the types themselves to control the way that the operation is structured. For example, \"visit this tree using an in-order walk and apply the operation to each node\". The basic visitor pattern is not suitable for all situations because it is cyclically-dependent, and the infrastructure involved is comparatively heavyweight.\n* **Reflection**. You can look up one of a set of overloaded methods based on the type of one of the method parameters and invoke the method manually. This results in a loss of type safety and is rather untidy, but there are times when it is the best solution. In particular, reflection is useful when you cannot change the type hierarchy, for example, because it is third-party code.\n\n## Example\nThe following example demonstrates the use \"Polymorphism\" and \"The visitor pattern\". More details on reflection can be found in \\[Flanagan\\].\n\n\n```java\nimport java.util.*;\n\npublic class ChainedInstanceof {\n\tpublic static void main(String[] args) {\n\t\t// BAD: example of a sequence of type tests\n\t\tList<BadAnimal> badAnimals = new ArrayList<BadAnimal>();\n\t\tbadAnimals.add(new BadCat());\n\t\tbadAnimals.add(new BadDog());\n\t\tfor(BadAnimal a: badAnimals) {\n\t\t\tif(a instanceof BadCat)      System.out.println(\"Miaow!\");\n\t\t\telse if(a instanceof BadDog) System.out.println(\"Woof!\");\n\t\t\telse                         throw new RuntimeException(\"Oops!\");\n\t\t}\n\n\t\t// GOOD: solution using polymorphism\n\t\tList<PolymorphicAnimal> polymorphicAnimals = new ArrayList<PolymorphicAnimal>();\n\t\tpolymorphicAnimals.add(new PolymorphicCat());\n\t\tpolymorphicAnimals.add(new PolymorphicDog());\n\t\tfor(PolymorphicAnimal a: polymorphicAnimals) a.speak();\n\n\t\t// GOOD: solution using the visitor pattern\n\t\tList<VisitableAnimal> visitableAnimals = new ArrayList<VisitableAnimal>();\n\t\tvisitableAnimals.add(new VisitableCat());\n\t\tvisitableAnimals.add(new VisitableDog());\n\t\tfor(VisitableAnimal a: visitableAnimals) a.accept(new SpeakVisitor());\n\t}\n\n\t//#################### TYPES FOR BAD EXAMPLE ####################\n\n\tprivate interface BadAnimal {}\n\tprivate static class BadCat implements BadAnimal {}\n\tprivate static class BadDog implements BadAnimal {}\n\n\t//#################### TYPES FOR POLYMORPHIC EXAMPLE ####################\n\n\tprivate interface PolymorphicAnimal {\n\t\tvoid speak();\n\t}\n\tprivate static class PolymorphicCat implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"Miaow!\"); }\n\t}\n\tprivate static class PolymorphicDog implements PolymorphicAnimal {\n\t\tpublic void speak() { System.out.println(\"Woof!\"); }\n\t}\n\n\t//#################### TYPES FOR VISITOR EXAMPLE ####################\n\n\tprivate interface Visitor {\n\t\tvoid visit(VisitableCat c);\n\t\tvoid visit(VisitableDog d);\n\t}\n\tprivate static class SpeakVisitor implements Visitor {\n\t\tpublic void visit(VisitableCat c) { System.out.println(\"Miaow!\"); }\n\t\tpublic void visit(VisitableDog d) { System.out.println(\"Woof!\"); }\n\t}\n\tprivate interface VisitableAnimal {\n\t\tvoid accept(Visitor v);\n\t}\n\tprivate static class VisitableCat implements VisitableAnimal {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n\tprivate static class VisitableDog implements VisitableAnimal {\n\t\tpublic void accept(Visitor v) { v.visit(this); }\n\t}\n}\n\n```\n\n## References\n* D. Flanagan, *Java in a Nutshell: A Desktop Quick Reference*. O'Reilly Media, 1997.\n* E. Gamma, R. Helm, R. Johnson, J. Vlissides, *Design patterns: elements of reusable object-oriented software*. Addison-Wesley Longman Publishing Co., Inc. Boston, MA, 1995.\n"},"properties":{"tags":["maintainability","language-features"],"description":"Long sequences of type tests on a variable are difficult to maintain.","id":"java/chained-type-tests","kind":"problem","name":"Chain of 'instanceof' tests","precision":"high","problem.severity":"recommendation"}},{"id":"java/iterable-wraps-iterator","name":"java/iterable-wraps-iterator","shortDescription":{"text":"Iterable wrapping an iterator"},"fullDescription":{"text":"An 'Iterable' that reuses an 'Iterator' instance does not support multiple traversals and can lead to unexpected behavior."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Iterable wrapping an iterator\nJava has two interfaces for dealing with iteration, `Iterable<T>` and `Iterator<T>`. An `Iterable<T>` represents a sequence of elements that can be traversed, and an `Iterator<T>` represents the **state** of an ongoing traversal. As an example, all the `Collection<T>` classes in the Java standard library implement `Iterable<T>`. Comparing this to a traditional `for` loop that increments an integer index and iterates over the elements of an array, then the `Iterable<T>` object corresponds to the array, whereas the `Iterator<T>` object corresponds to the index variable.\n\nImplementations of `Iterable<T>` are generally expected to support multiple traversals of the element sequence they represent, although there can be exceptions if the underlying data somehow makes this undesirable, see for example `DirectoryStream<T>`. If an implementation of `Iterable<T>` does not support multiple iterations, then its `iterator()` method should throw an exception on its second and subsequent calls. This makes bugs easier to find if such an `Iterable<T>` is used more than once, for example in two different for-each loops.\n\n\n## Recommendation\nWhen writing the `iterator()` method in an `Iterable<T>` then it is important to make sure that each call will result in a fresh `Iterator<T>` instance containing all the necessary state for keeping track of the iteration. If the iterator is stored in the `Iterable<T>`, or somehow refers to iteration state stored in the `Iterable<T>`, then subsequent calls to `iterator()` can result in loops that only traverse a subset of the elements or have no effect at all.\n\n\n## Example\nThe following example returns the same iterator on every call, and therefore causes the second loop to terminate immediately without any effect.\n\n\n```java\nclass MySequence implements Iterable<MyElem> {\n  // ... some reference to data\n  final Iterator<MyElem> it = data.iterator();\n  // Wrong: reused iterator\n  public Iterator<MyElem> iterator() {\n    return it;\n  }\n}\n\nvoid useMySequence(MySequence s) {\n  // do some work by traversing the sequence\n  for (MyElem e : s) {\n    // ...\n  }\n  // do some more work by traversing it again\n  for (MyElem e : s) {\n    // ...\n  }\n}\n\n```\nThis second example returns a newly created iterator each time, but still relies on iteration state stored in the surrounding class, and therefore also causes the second loop to terminate immediately.\n\n\n```java\nclass MySequence implements Iterable<MyElem> {\n  // ... some reference to data\n  final Iterator<MyElem> it = data.iterator();\n  // Wrong: iteration state outside returned iterator\n  public Iterator<MyElem> iterator() {\n    return new Iterator<MyElem>() {\n      public boolean hasNext() {\n        return it.hasNext();\n      }\n      public MyElem next() {\n        return transformElem(it.next());\n      }\n      public void remove() {\n        // ...\n      }\n    };\n  }\n}\n\n```\nThe code should instead be written like this, such that each call to `iterator()` correctly gives a fresh iterator that starts at the beginning.\n\n\n```java\nclass MySequence implements Iterable<MyElem> {\n  // ... some reference to data\n  public Iterator<MyElem> iterator() {\n    return new Iterator<MyElem>() {\n      // Correct: iteration state inside returned iterator\n      final Iterator<MyElem> it = data.iterator();\n      public boolean hasNext() {\n        return it.hasNext();\n      }\n      public MyElem next() {\n        return transformElem(it.next());\n      }\n      public void remove() {\n        // ...\n      }\n    };\n  }\n}\n\n```\n\n## References\n* Java Language Specification: [The enhanced for statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.2).\n* Java API Specification: [Interface Iterable&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Iterable.html), [Interface Iterator&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html), [Interface DirectoryStream&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/DirectoryStream.html).\n","markdown":"# Iterable wrapping an iterator\nJava has two interfaces for dealing with iteration, `Iterable<T>` and `Iterator<T>`. An `Iterable<T>` represents a sequence of elements that can be traversed, and an `Iterator<T>` represents the **state** of an ongoing traversal. As an example, all the `Collection<T>` classes in the Java standard library implement `Iterable<T>`. Comparing this to a traditional `for` loop that increments an integer index and iterates over the elements of an array, then the `Iterable<T>` object corresponds to the array, whereas the `Iterator<T>` object corresponds to the index variable.\n\nImplementations of `Iterable<T>` are generally expected to support multiple traversals of the element sequence they represent, although there can be exceptions if the underlying data somehow makes this undesirable, see for example `DirectoryStream<T>`. If an implementation of `Iterable<T>` does not support multiple iterations, then its `iterator()` method should throw an exception on its second and subsequent calls. This makes bugs easier to find if such an `Iterable<T>` is used more than once, for example in two different for-each loops.\n\n\n## Recommendation\nWhen writing the `iterator()` method in an `Iterable<T>` then it is important to make sure that each call will result in a fresh `Iterator<T>` instance containing all the necessary state for keeping track of the iteration. If the iterator is stored in the `Iterable<T>`, or somehow refers to iteration state stored in the `Iterable<T>`, then subsequent calls to `iterator()` can result in loops that only traverse a subset of the elements or have no effect at all.\n\n\n## Example\nThe following example returns the same iterator on every call, and therefore causes the second loop to terminate immediately without any effect.\n\n\n```java\nclass MySequence implements Iterable<MyElem> {\n  // ... some reference to data\n  final Iterator<MyElem> it = data.iterator();\n  // Wrong: reused iterator\n  public Iterator<MyElem> iterator() {\n    return it;\n  }\n}\n\nvoid useMySequence(MySequence s) {\n  // do some work by traversing the sequence\n  for (MyElem e : s) {\n    // ...\n  }\n  // do some more work by traversing it again\n  for (MyElem e : s) {\n    // ...\n  }\n}\n\n```\nThis second example returns a newly created iterator each time, but still relies on iteration state stored in the surrounding class, and therefore also causes the second loop to terminate immediately.\n\n\n```java\nclass MySequence implements Iterable<MyElem> {\n  // ... some reference to data\n  final Iterator<MyElem> it = data.iterator();\n  // Wrong: iteration state outside returned iterator\n  public Iterator<MyElem> iterator() {\n    return new Iterator<MyElem>() {\n      public boolean hasNext() {\n        return it.hasNext();\n      }\n      public MyElem next() {\n        return transformElem(it.next());\n      }\n      public void remove() {\n        // ...\n      }\n    };\n  }\n}\n\n```\nThe code should instead be written like this, such that each call to `iterator()` correctly gives a fresh iterator that starts at the beginning.\n\n\n```java\nclass MySequence implements Iterable<MyElem> {\n  // ... some reference to data\n  public Iterator<MyElem> iterator() {\n    return new Iterator<MyElem>() {\n      // Correct: iteration state inside returned iterator\n      final Iterator<MyElem> it = data.iterator();\n      public boolean hasNext() {\n        return it.hasNext();\n      }\n      public MyElem next() {\n        return transformElem(it.next());\n      }\n      public void remove() {\n        // ...\n      }\n    };\n  }\n}\n\n```\n\n## References\n* Java Language Specification: [The enhanced for statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.2).\n* Java API Specification: [Interface Iterable&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Iterable.html), [Interface Iterator&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html), [Interface DirectoryStream&lt;T&gt;](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/DirectoryStream.html).\n"},"properties":{"tags":["correctness","reliability"],"description":"An 'Iterable' that reuses an 'Iterator' instance does not support multiple traversals\n              and can lead to unexpected behavior.","id":"java/iterable-wraps-iterator","kind":"problem","name":"Iterable wrapping an iterator","precision":"very-high","problem.severity":"warning"}},{"id":"java/missing-override-annotation","name":"java/missing-override-annotation","shortDescription":{"text":"Missing Override annotation"},"fullDescription":{"text":"A method that overrides a method in a superclass but does not have an 'Override' annotation cannot take advantage of compiler checks, and makes code less readable."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Missing Override annotation\nJava enables you to annotate methods that are intended to override a method in a superclass. Compilers are required to generate an error if such an annotated method does not override a method in a superclass, which provides increased protection from potential defects. An annotated method also improves code readability.\n\n\n## Recommendation\nAdd an `@Override` annotation to a method that is intended to override a method in a superclass.\n\n\n## Example\nIn the following example, `Triangle.getArea` overrides `Rectangle.getArea`, so it is annotated with `@Override`.\n\n\n```java\nclass Rectangle\n{\n    private int w = 10, h = 10;\n    public int getArea() { \n        return w * h; \n    }\n}\n \nclass Triangle extends Rectangle\n{\n    @Override  // Annotation of an overriding method \n    public int getArea() { \n        return super.getArea() / 2; \n    }\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 36. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n* The Java Tutorials: [Predefined Annotation Types](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html).\n","markdown":"# Missing Override annotation\nJava enables you to annotate methods that are intended to override a method in a superclass. Compilers are required to generate an error if such an annotated method does not override a method in a superclass, which provides increased protection from potential defects. An annotated method also improves code readability.\n\n\n## Recommendation\nAdd an `@Override` annotation to a method that is intended to override a method in a superclass.\n\n\n## Example\nIn the following example, `Triangle.getArea` overrides `Rectangle.getArea`, so it is annotated with `@Override`.\n\n\n```java\nclass Rectangle\n{\n    private int w = 10, h = 10;\n    public int getArea() { \n        return w * h; \n    }\n}\n \nclass Triangle extends Rectangle\n{\n    @Override  // Annotation of an overriding method \n    public int getArea() { \n        return super.getArea() / 2; \n    }\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 36. Addison-Wesley, 2008.\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n* The Java Tutorials: [Predefined Annotation Types](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html).\n"},"properties":{"tags":["maintainability"],"description":"A method that overrides a method in a superclass but does not have an 'Override'\n              annotation cannot take advantage of compiler checks, and makes code less readable.","id":"java/missing-override-annotation","kind":"problem","name":"Missing Override annotation","precision":"high","problem.severity":"recommendation"}},{"id":"java/inconsistent-javadoc-throws","name":"java/inconsistent-javadoc-throws","shortDescription":{"text":"Javadoc has impossible 'throws' tag"},"fullDescription":{"text":"Javadoc that incorrectly claims a method or constructor can throw an exception is misleading."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Javadoc has impossible 'throws' tag\nA Javadoc `@throws` or `@exception` tag that references an exception that cannot be thrown is misleading.\n\n\n## Recommendation\nEnsure that you only include the `@throws` or `@exception` tags in Javadoc when an exception can be thrown.\n\n\n## Example\nThe following example shows a method with Javadoc that claims it can throw `Exception`. Since `Exception` is a checked exception and the method does not declare that it may throw an exception, the Javadoc is wrong and should be updated.\n\n\n```java\n/**\n * Javadoc for method.\n *\n * @throws Exception if a problem occurs.\n */\npublic void noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\nIn the following example the Javadoc has been corrected by removing the `@throws` tag.\n\n\n```java\n/**\n * Javadoc for method.\n */\npublic void noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\n\n## References\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#throwstag),\n","markdown":"# Javadoc has impossible 'throws' tag\nA Javadoc `@throws` or `@exception` tag that references an exception that cannot be thrown is misleading.\n\n\n## Recommendation\nEnsure that you only include the `@throws` or `@exception` tags in Javadoc when an exception can be thrown.\n\n\n## Example\nThe following example shows a method with Javadoc that claims it can throw `Exception`. Since `Exception` is a checked exception and the method does not declare that it may throw an exception, the Javadoc is wrong and should be updated.\n\n\n```java\n/**\n * Javadoc for method.\n *\n * @throws Exception if a problem occurs.\n */\npublic void noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\nIn the following example the Javadoc has been corrected by removing the `@throws` tag.\n\n\n```java\n/**\n * Javadoc for method.\n */\npublic void noThrow() {\n\tSystem.out.println(\"This method does not throw.\");\n}\n```\n\n## References\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#throwstag),\n"},"properties":{"tags":["maintainability"],"description":"Javadoc that incorrectly claims a method or constructor can throw an exception\n              is misleading.","id":"java/inconsistent-javadoc-throws","kind":"problem","name":"Javadoc has impossible 'throws' tag","precision":"high","problem.severity":"recommendation"}},{"id":"java/unknown-javadoc-parameter","name":"java/unknown-javadoc-parameter","shortDescription":{"text":"Spurious Javadoc @param tags"},"fullDescription":{"text":"Javadoc @param tags that do not match any parameters in the method or constructor or any type parameters of the annotated class are confusing."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Spurious Javadoc @param tags\nJavadoc comments for public methods, constructors and generic classes should use the `@param` tag to describe the available parameters and type parameters. If the comment includes any empty, incorrect or outdated parameter names then this will make the documentation more difficult to read.\n\n\n## Recommendation\nThe Javadoc comment for a method, constructor or generic class should always use non-empty `@param` values that match actual parameter or type parameter names.\n\n\n## Example\nThe following example shows good and bad Javadoc comments that use the `@param` tag.\n\n\n```java\n/**\n * BAD: The following param tag is empty.\n *\n * @param   \n */ \npublic void emptyParamTag(int p){ ... }\n\n\n/**\n * BAD: The following param tag has a misspelled value.\n *\n * @param prameter The parameter's value.\n */ \npublic void typo(int parameter){ ... }\n\n\n/**\n * BAD: The following param tag appears to be outdated\n * since the method does not take any parameters.\n *\n * @param sign The number's sign.\n */ \npublic void outdated(){ ... }\n\n\n/**\n * BAD: The following param tag uses html within the tag value.\n *\n * @param <code>ordinate</code> The value of the y coordinate.\n */ \npublic void html(int ordinate){ ... }\n\n\n/**\n * BAD: Invalid syntax for type parameter.\n *\n * @param T The type of the parameter.\n * @param parameter The parameter value.\n */ \npublic <T> void parameterized(T parameter){ ... }\n\n/**\n * BAD: The following param tag refers to a non-existent type parameter.\n * \n * @param <X> The type of the elements.\n */\nclass Generic<T> { ... }\n\n/**\n * GOOD: A proper Javadoc comment.\n *\n * This method calculates the absolute value of a given number.\n *\n * @param <T> The number's type.\n * @param x The number to calculate the absolute value of.\n * @return The absolute value of <code>x</code>.\n */ \npublic <T extends Number> T abs(T x){ ... }\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#@param), [Documentation Comment Specification for the Standard Doclet](https://docs.oracle.com/en/java/javase/11/docs/specs/doc-comment-spec.html#param)\n","markdown":"# Spurious Javadoc @param tags\nJavadoc comments for public methods, constructors and generic classes should use the `@param` tag to describe the available parameters and type parameters. If the comment includes any empty, incorrect or outdated parameter names then this will make the documentation more difficult to read.\n\n\n## Recommendation\nThe Javadoc comment for a method, constructor or generic class should always use non-empty `@param` values that match actual parameter or type parameter names.\n\n\n## Example\nThe following example shows good and bad Javadoc comments that use the `@param` tag.\n\n\n```java\n/**\n * BAD: The following param tag is empty.\n *\n * @param   \n */ \npublic void emptyParamTag(int p){ ... }\n\n\n/**\n * BAD: The following param tag has a misspelled value.\n *\n * @param prameter The parameter's value.\n */ \npublic void typo(int parameter){ ... }\n\n\n/**\n * BAD: The following param tag appears to be outdated\n * since the method does not take any parameters.\n *\n * @param sign The number's sign.\n */ \npublic void outdated(){ ... }\n\n\n/**\n * BAD: The following param tag uses html within the tag value.\n *\n * @param <code>ordinate</code> The value of the y coordinate.\n */ \npublic void html(int ordinate){ ... }\n\n\n/**\n * BAD: Invalid syntax for type parameter.\n *\n * @param T The type of the parameter.\n * @param parameter The parameter value.\n */ \npublic <T> void parameterized(T parameter){ ... }\n\n/**\n * BAD: The following param tag refers to a non-existent type parameter.\n * \n * @param <X> The type of the elements.\n */\nclass Generic<T> { ... }\n\n/**\n * GOOD: A proper Javadoc comment.\n *\n * This method calculates the absolute value of a given number.\n *\n * @param <T> The number's type.\n * @param x The number to calculate the absolute value of.\n * @return The absolute value of <code>x</code>.\n */ \npublic <T extends Number> T abs(T x){ ... }\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Javadoc Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-javadoc.htm).\n* Java SE Documentation: [How to Write Doc Comments for the Javadoc Tool](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#@param), [Documentation Comment Specification for the Standard Doclet](https://docs.oracle.com/en/java/javase/11/docs/specs/doc-comment-spec.html#param)\n"},"properties":{"tags":["maintainability"],"description":"Javadoc @param tags that do not match any parameters in the method or constructor or\n              any type parameters of the annotated class are confusing.","id":"java/unknown-javadoc-parameter","kind":"problem","name":"Spurious Javadoc @param tags","precision":"very-high","problem.severity":"recommendation"}},{"id":"java/deprecated-call","name":"java/deprecated-call","shortDescription":{"text":"Deprecated method or constructor invocation"},"fullDescription":{"text":"Using a method or constructor that has been marked as deprecated may be dangerous or fail to take advantage of a better method or constructor."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Deprecated method or constructor invocation\nA method (or constructor) can be marked as deprecated using either the `@Deprecated` annotation or the `@deprecated` Javadoc tag. Using a method that has been marked as deprecated is bad practice, typically for one or more of the following reasons:\n\n* The method is dangerous.\n* There is a better alternative method.\n* Methods that are marked as deprecated are often removed from future versions of an API. So using a deprecated method may cause extra maintenance effort when the API is upgraded.\n\n## Recommendation\nAvoid using a method that has been marked as deprecated. Follow any guidance that is provided with the `@deprecated` Javadoc tag, which should explain how to replace the call to the deprecated method.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java API Specification: [Annotation Type Deprecated](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Deprecated.html).\n* Java SE Documentation: [How and When To Deprecate APIs](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html).\n* Common Weakness Enumeration: [CWE-477](https://cwe.mitre.org/data/definitions/477.html).\n","markdown":"# Deprecated method or constructor invocation\nA method (or constructor) can be marked as deprecated using either the `@Deprecated` annotation or the `@deprecated` Javadoc tag. Using a method that has been marked as deprecated is bad practice, typically for one or more of the following reasons:\n\n* The method is dangerous.\n* There is a better alternative method.\n* Methods that are marked as deprecated are often removed from future versions of an API. So using a deprecated method may cause extra maintenance effort when the API is upgraded.\n\n## Recommendation\nAvoid using a method that has been marked as deprecated. Follow any guidance that is provided with the `@deprecated` Javadoc tag, which should explain how to replace the call to the deprecated method.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java API Specification: [Annotation Type Deprecated](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Deprecated.html).\n* Java SE Documentation: [How and When To Deprecate APIs](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html).\n* Common Weakness Enumeration: [CWE-477](https://cwe.mitre.org/data/definitions/477.html).\n"},"properties":{"tags":["maintainability","non-attributable","external/cwe/cwe-477"],"description":"Using a method or constructor that has been marked as deprecated may be dangerous or\n              fail to take advantage of a better method or constructor.","id":"java/deprecated-call","kind":"problem","name":"Deprecated method or constructor invocation","precision":"high","problem.severity":"recommendation"}},{"id":"java/underscore-identifier","name":"java/underscore-identifier","shortDescription":{"text":"Underscore used as identifier"},"fullDescription":{"text":"Use of a single underscore character as an identifier results in a compiler error with Java source level 9 or later."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Underscore used as identifier\nThe underscore character is a reserved keyword in Java 9 and therefore disallowed as a one-character identifier.\n\n\n## Recommendation\nRename any identifiers that consist of a one-character underscore.\n\n\n## References\n* Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).\n* JDK Bug System: [Disallow _ as a one-character identifier](https://bugs.openjdk.java.net/browse/JDK-8061549).\n","markdown":"# Underscore used as identifier\nThe underscore character is a reserved keyword in Java 9 and therefore disallowed as a one-character identifier.\n\n\n## Recommendation\nRename any identifiers that consist of a one-character underscore.\n\n\n## References\n* Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).\n* JDK Bug System: [Disallow _ as a one-character identifier](https://bugs.openjdk.java.net/browse/JDK-8061549).\n"},"properties":{"tags":["maintainability"],"description":"Use of a single underscore character as an identifier\n              results in a compiler error with Java source level 9 or later.","id":"java/underscore-identifier","kind":"problem","name":"Underscore used as identifier","precision":"high","problem.severity":"recommendation"}},{"id":"java/jdk-internal-api-access","name":"java/jdk-internal-api-access","shortDescription":{"text":"Access to unsupported JDK-internal API"},"fullDescription":{"text":"Use of unsupported JDK-internal APIs may cause compatibility issues when upgrading to newer versions of Java, in particular Java 9."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Access to unsupported JDK-internal API\nJava 9 removes access to various unsupported JDK-internal APIs by default.\n\n\n## Recommendation\nExamine the use of unsupported JDK-internal APIs and consider replacing them with supported APIs as recommended in the references.\n\n\n## References\n* Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).\n* OpenJDK Documentation: [Java Dependency Analysis Tool](https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool), [JEP 260: Encapsulate Most Internal APIs](https://openjdk.java.net/jeps/260), [JEP 261: Module System](https://openjdk.java.net/jeps/261).\n","markdown":"# Access to unsupported JDK-internal API\nJava 9 removes access to various unsupported JDK-internal APIs by default.\n\n\n## Recommendation\nExamine the use of unsupported JDK-internal APIs and consider replacing them with supported APIs as recommended in the references.\n\n\n## References\n* Oracle JDK Documentation: [Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm).\n* OpenJDK Documentation: [Java Dependency Analysis Tool](https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool), [JEP 260: Encapsulate Most Internal APIs](https://openjdk.java.net/jeps/260), [JEP 261: Module System](https://openjdk.java.net/jeps/261).\n"},"properties":{"tags":["maintainability"],"description":"Use of unsupported JDK-internal APIs may cause compatibility issues\n              when upgrading to newer versions of Java, in particular Java 9.","id":"java/jdk-internal-api-access","kind":"problem","name":"Access to unsupported JDK-internal API","precision":"high","problem.severity":"recommendation"}},{"id":"java/abstract-to-concrete-cast","name":"java/abstract-to-concrete-cast","shortDescription":{"text":"Cast from abstract to concrete collection"},"fullDescription":{"text":"A cast from an abstract collection to a concrete implementation type makes the code brittle."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Cast from abstract to concrete collection\nMost collections in the Java standard library are defined by an abstract interface (for example `java.util.List` or `java.util.Set`), which is implemented by a range of concrete classes and a range of wrappers. Normally, except when constructing an object, it is better to use the abstract types because this avoids assumptions about what the implementation is.\n\nA cast from an abstract to a concrete collection makes the code brittle by ensuring it works only for one possible implementation class and not others. Usually, such casts are either an indication of over-reliance on concrete implementation types, or of the fact that the wrong abstract type was used.\n\n\n## Recommendation\nIt is usually best to use the abstract type consistently in variable, field and parameter declarations.\n\nThere may be individual exceptions. For example, it is common to declare variables as `LinkedHashSet` rather than `Set` when the iteration order matters and only the `LinkedHashSet` implementation provides the right behavior.\n\n\n## Example\nThe following example illustrates a situation where the wrong abstract type is used. The `List` interface does not provide a `poll` method, so the original code casts `queue` down to the concrete type `LinkedList`, which does. To avoid this downcasting, simply use the correct abstract type for this method, namely `Queue`. This documents the intent of the programmer and allows for various implementations of queues to be used by clients of this method.\n\n\n```java\nCustomer getNext(List<Customer> queue) {\n\tif (queue == null)\n\t\treturn null;\n\tLinkedList<Customer> myQueue = (LinkedList<Customer>)queue;  // AVOID: Cast to concrete type.\n\treturn myQueue.poll();\n}\n\nCustomer getNext(Queue<Customer> queue) {\n\tif (queue == null)\n\t\treturn null;\n\treturn queue.poll();  // GOOD: Use abstract type.\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 52. Addison-Wesley, 2008.\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html).\n* Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n","markdown":"# Cast from abstract to concrete collection\nMost collections in the Java standard library are defined by an abstract interface (for example `java.util.List` or `java.util.Set`), which is implemented by a range of concrete classes and a range of wrappers. Normally, except when constructing an object, it is better to use the abstract types because this avoids assumptions about what the implementation is.\n\nA cast from an abstract to a concrete collection makes the code brittle by ensuring it works only for one possible implementation class and not others. Usually, such casts are either an indication of over-reliance on concrete implementation types, or of the fact that the wrong abstract type was used.\n\n\n## Recommendation\nIt is usually best to use the abstract type consistently in variable, field and parameter declarations.\n\nThere may be individual exceptions. For example, it is common to declare variables as `LinkedHashSet` rather than `Set` when the iteration order matters and only the `LinkedHashSet` implementation provides the right behavior.\n\n\n## Example\nThe following example illustrates a situation where the wrong abstract type is used. The `List` interface does not provide a `poll` method, so the original code casts `queue` down to the concrete type `LinkedList`, which does. To avoid this downcasting, simply use the correct abstract type for this method, namely `Queue`. This documents the intent of the programmer and allows for various implementations of queues to be used by clients of this method.\n\n\n```java\nCustomer getNext(List<Customer> queue) {\n\tif (queue == null)\n\t\treturn null;\n\tLinkedList<Customer> myQueue = (LinkedList<Customer>)queue;  // AVOID: Cast to concrete type.\n\treturn myQueue.poll();\n}\n\nCustomer getNext(Queue<Customer> queue) {\n\tif (queue == null)\n\t\treturn null;\n\treturn queue.poll();  // GOOD: Use abstract type.\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 52. Addison-Wesley, 2008.\n* Java API Specification: [Collection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html).\n* Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n"},"properties":{"tags":["reliability","maintainability","modularity","external/cwe/cwe-485"],"description":"A cast from an abstract collection to a concrete implementation type makes the\n              code brittle.","id":"java/abstract-to-concrete-cast","kind":"problem","name":"Cast from abstract to concrete collection","precision":"very-high","problem.severity":"warning"}},{"id":"java/internal-representation-exposure","name":"java/internal-representation-exposure","shortDescription":{"text":"Exposing internal representation"},"fullDescription":{"text":"An object that accidentally exposes its internal representation may allow the object's fields to be modified in ways that the object is not prepared to handle."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Exposing internal representation\nA subtle type of defect is caused when an object accidentally exposes its internal representation to the code outside the object, and the internal representation is then (deliberately or accidentally) modified in ways that the object is not prepared to handle. Most commonly, this happens when a getter returns a direct reference to a mutable field within the object, or a setter just assigns a mutable argument to its field.\n\n\n## Recommendation\nThere are three ways of addressing this problem:\n\n* **Using immutable objects** : The fields store objects that are *immutable*, which means that once constructed their value can never be changed. Examples from the standard library are `String`, `Integer` or `Float`. Although such an object may be aliased, or shared between several contexts, there can be no unexpected changes to the internal state of the object because it cannot be modified.\n* **Creating a read-only view** : The `java.util.Collections.unmodifiable*` methods can be used to create a read-only view of a collection without copying it. This tends to give better performance than creating copies of objects. Note that this technique is not suitable for every situation, because any changes to the underlying collection will spread to affect the view. This can lead to unexpected results, and is a particular danger when writing multi-threaded code.\n* **Making defensive copies** : Each setter (or constructor) makes a copy or clone of the incoming parameter. In this way, it constructs an instance known only internally, and no matter what happens with the object that was passed in, the state stays consistent. Conversely, each getter for a field must also construct a copy of the field's value to return.\n\n## Example\nIn the following example, the private field `items` is returned directly by the getter `getItems`. Thus, a caller obtains a reference to internal object state and can manipulate the collection of items in the cart. In the example, each of the carts is emptied when `countItems` is called.\n\n\n```java\npublic class Cart {\n\tprivate Set<Item> items;\n\t// ...\n\t// AVOID: Exposes representation\n\tpublic Set<Item> getItems() {\n\t\treturn items;\n\t}\n}\n....\nint countItems(Set<Cart> carts) {\n\tint result = 0;\n\tfor (Cart cart : carts) {\n\t\tSet<Item> items = cart.getItems();\n\t\tresult += items.size();\n\t\titems.clear(); // AVOID: Changes internal representation\n\t}\n\treturn result;\n}\n```\nThe solution is for `getItems` to return a *copy* of the actual field, for example `return new HashSet<Item>(items);`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 15 and 39. Addison-Wesley, 2008.\n* Java API Specification: [Collections](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html).\n* Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n","markdown":"# Exposing internal representation\nA subtle type of defect is caused when an object accidentally exposes its internal representation to the code outside the object, and the internal representation is then (deliberately or accidentally) modified in ways that the object is not prepared to handle. Most commonly, this happens when a getter returns a direct reference to a mutable field within the object, or a setter just assigns a mutable argument to its field.\n\n\n## Recommendation\nThere are three ways of addressing this problem:\n\n* **Using immutable objects** : The fields store objects that are *immutable*, which means that once constructed their value can never be changed. Examples from the standard library are `String`, `Integer` or `Float`. Although such an object may be aliased, or shared between several contexts, there can be no unexpected changes to the internal state of the object because it cannot be modified.\n* **Creating a read-only view** : The `java.util.Collections.unmodifiable*` methods can be used to create a read-only view of a collection without copying it. This tends to give better performance than creating copies of objects. Note that this technique is not suitable for every situation, because any changes to the underlying collection will spread to affect the view. This can lead to unexpected results, and is a particular danger when writing multi-threaded code.\n* **Making defensive copies** : Each setter (or constructor) makes a copy or clone of the incoming parameter. In this way, it constructs an instance known only internally, and no matter what happens with the object that was passed in, the state stays consistent. Conversely, each getter for a field must also construct a copy of the field's value to return.\n\n## Example\nIn the following example, the private field `items` is returned directly by the getter `getItems`. Thus, a caller obtains a reference to internal object state and can manipulate the collection of items in the cart. In the example, each of the carts is emptied when `countItems` is called.\n\n\n```java\npublic class Cart {\n\tprivate Set<Item> items;\n\t// ...\n\t// AVOID: Exposes representation\n\tpublic Set<Item> getItems() {\n\t\treturn items;\n\t}\n}\n....\nint countItems(Set<Cart> carts) {\n\tint result = 0;\n\tfor (Cart cart : carts) {\n\t\tSet<Item> items = cart.getItems();\n\t\tresult += items.size();\n\t\titems.clear(); // AVOID: Changes internal representation\n\t}\n\treturn result;\n}\n```\nThe solution is for `getItems` to return a *copy* of the actual field, for example `return new HashSet<Item>(items);`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Items 15 and 39. Addison-Wesley, 2008.\n* Java API Specification: [Collections](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html).\n* Common Weakness Enumeration: [CWE-485](https://cwe.mitre.org/data/definitions/485.html).\n"},"properties":{"tags":["reliability","maintainability","modularity","external/cwe/cwe-485"],"description":"An object that accidentally exposes its internal representation may allow the\n              object's fields to be modified in ways that the object is not prepared to handle.","id":"java/internal-representation-exposure","kind":"problem","name":"Exposing internal representation","precision":"high","problem.severity":"recommendation"}},{"id":"java/call-to-object-tostring","name":"java/call-to-object-tostring","shortDescription":{"text":"Use of default toString()"},"fullDescription":{"text":"Calling the default implementation of 'toString' returns a value that is unlikely to be what you expect."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Use of default toString()\nIn most cases, calling the default implementation of `toString` in `java.lang.Object` is not what is intended when a string representation of an object is required. The output of the default `toString` method consists of the class name of the object as well as the object's hashcode, which is usually not what was intended.\n\nThis rule includes explicit and implicit calls to `toString` that resolve to `java.lang.Object.toString`, particularly calls that are used in print or log statements.\n\n\n## Recommendation\nFor objects that are printed, define a `toString` method for the object that returns a human-readable string.\n\n\n## Example\nThe following example shows that printing an object makes an implicit call to `toString`. Because the class `WrongPerson` does not have a `toString` method, `Object.toString` is called instead, which returns the class name and the `wp` object's hashcode.\n\n\n```java\n// This class does not have a 'toString' method, so 'java.lang.Object.toString'\n// is used when the class is converted to a string.\nclass WrongPerson {\n\tprivate String name;\n\tprivate Date birthDate; \n\t\n\tpublic WrongPerson(String name, Date birthDate) {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tWrongPerson wp = new WrongPerson(\"Robert Van Winkle\", dateFormatter.parse(\"1967-10-31\"));\n\n\t// BAD: The following statement implicitly calls 'Object.toString', \n\t// which returns something similar to:\n\t// WrongPerson@4383f74d\n\tSystem.out.println(wp);\n}\n```\nIn contrast, in the following modification of the example, the class `Person` does have a `toString` method, which returns a string containing the arguments that were passed when the object `p` was created.\n\n\n```java\n// This class does have a 'toString' method, which is used when the object is\n// converted to a string.\nclass Person {\n\tprivate String name;\n\tprivate Date birthDate;\n\t\n\tpublic String toString() {\n\t\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\treturn \"(Name: \" + name + \", Birthdate: \" + dateFormatter.format(birthDate) + \")\";\n\t}\n\t\n\tpublic Person(String name, Date birthDate) {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tPerson p = new Person(\"Eric Arthur Blair\", dateFormatter.parse(\"1903-06-25\"));\n\n\t// GOOD: The following statement implicitly calls 'Person.toString', \n\t// which correctly returns a human-readable string:\n\t// (Name: Eric Arthur Blair, Birthdate: 1903-06-25)\n\tSystem.out.println(p);\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 10. Addison-Wesley, 2008.\n* Java API Specification: [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n","markdown":"# Use of default toString()\nIn most cases, calling the default implementation of `toString` in `java.lang.Object` is not what is intended when a string representation of an object is required. The output of the default `toString` method consists of the class name of the object as well as the object's hashcode, which is usually not what was intended.\n\nThis rule includes explicit and implicit calls to `toString` that resolve to `java.lang.Object.toString`, particularly calls that are used in print or log statements.\n\n\n## Recommendation\nFor objects that are printed, define a `toString` method for the object that returns a human-readable string.\n\n\n## Example\nThe following example shows that printing an object makes an implicit call to `toString`. Because the class `WrongPerson` does not have a `toString` method, `Object.toString` is called instead, which returns the class name and the `wp` object's hashcode.\n\n\n```java\n// This class does not have a 'toString' method, so 'java.lang.Object.toString'\n// is used when the class is converted to a string.\nclass WrongPerson {\n\tprivate String name;\n\tprivate Date birthDate; \n\t\n\tpublic WrongPerson(String name, Date birthDate) {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tWrongPerson wp = new WrongPerson(\"Robert Van Winkle\", dateFormatter.parse(\"1967-10-31\"));\n\n\t// BAD: The following statement implicitly calls 'Object.toString', \n\t// which returns something similar to:\n\t// WrongPerson@4383f74d\n\tSystem.out.println(wp);\n}\n```\nIn contrast, in the following modification of the example, the class `Person` does have a `toString` method, which returns a string containing the arguments that were passed when the object `p` was created.\n\n\n```java\n// This class does have a 'toString' method, which is used when the object is\n// converted to a string.\nclass Person {\n\tprivate String name;\n\tprivate Date birthDate;\n\t\n\tpublic String toString() {\n\t\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\treturn \"(Name: \" + name + \", Birthdate: \" + dateFormatter.format(birthDate) + \")\";\n\t}\n\t\n\tpublic Person(String name, Date birthDate) {\n\t\tthis.name =name;\n\t\tthis.birthDate = birthDate;\n\t}\n}\n\npublic static void main(String args[]) throws Exception {\n\tDateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tPerson p = new Person(\"Eric Arthur Blair\", dateFormatter.parse(\"1903-06-25\"));\n\n\t// GOOD: The following statement implicitly calls 'Person.toString', \n\t// which correctly returns a human-readable string:\n\t// (Name: Eric Arthur Blair, Birthdate: 1903-06-25)\n\tSystem.out.println(p);\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 10. Addison-Wesley, 2008.\n* Java API Specification: [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"},"properties":{"tags":["reliability","maintainability"],"description":"Calling the default implementation of 'toString' returns a value that is unlikely to\n              be what you expect.","id":"java/call-to-object-tostring","kind":"problem","name":"Use of default toString()","precision":"high","problem.severity":"recommendation"}},{"id":"java/print-array","name":"java/print-array","shortDescription":{"text":"Implicit conversion from array to string"},"fullDescription":{"text":"Directly printing an array, without first converting the array to a string, produces unreadable results."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Implicit conversion from array to string\nPrinting an array is likely to produce unintended results. That is, the result does not contain the contents of the array. This is because the array is implicitly converted to a `String` using `Object.toString`, which just returns the following value:\n\n` getClass().getName() + '@' + Integer.toHexString(hashCode()) `\n\n\n## Recommendation\nWhen converting an array to a readable string, use `Arrays.toString` for one-dimensional arrays, or `Arrays.deepToString` for multi-dimensional arrays. These functions iterate over the contents of the array and produce human-readable output.\n\n\n## Example\nIn the following example, the contents of the array `words` are printed out only if `Arrays.toString` is called on the array first. Similarly, the contents of the multi-dimensional array `wordMatrix` are printed out only if `Arrays.deepToString` is called on the array first.\n\n\n```java\npublic static void main(String args[]) {\n\tString[] words = {\"Who\", \"is\", \"John\", \"Galt\"};\n\tString[][] wordMatrix = {{\"There\", \"is\"}, {\"no\", \"spoon\"}};\n\t\n\t// BAD: This implicitly uses 'Object.toString' to convert the contents\n\t// of 'words[]', and prints out something similar to:\n\t// [Ljava.lang.String;@459189e1\n\tSystem.out.println(words);\n\t\n\t// GOOD: 'Arrays.toString' calls 'toString' on\n\t// each of the array's elements. The statement prints out:\n\t// [Who, is, John, Galt]\n\tSystem.out.println(Arrays.toString(words));\n\t\n\t// ALMOST RIGHT: This calls 'toString' on each of the multi-dimensional \n\t// array's elements. However, because the elements are arrays, the statement\n\t// prints out something similar to:\n\t// [[Ljava.lang.String;@55f33675, [Ljava.lang.String;@527c6768]]\n\tSystem.out.println(Arrays.toString(wordMatrix));\n\t\n\t// GOOD: This properly prints out the contents of the multi-dimensional array:\n\t// [[There, is], [no, spoon]]\n\tSystem.out.println(Arrays.deepToString(wordMatrix));\n}\n```\n\n## References\n* Java API Specification: [Arrays.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#toString(java.lang.Object[])), [Arrays.deepToString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepToString(java.lang.Object[])), [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n","markdown":"# Implicit conversion from array to string\nPrinting an array is likely to produce unintended results. That is, the result does not contain the contents of the array. This is because the array is implicitly converted to a `String` using `Object.toString`, which just returns the following value:\n\n` getClass().getName() + '@' + Integer.toHexString(hashCode()) `\n\n\n## Recommendation\nWhen converting an array to a readable string, use `Arrays.toString` for one-dimensional arrays, or `Arrays.deepToString` for multi-dimensional arrays. These functions iterate over the contents of the array and produce human-readable output.\n\n\n## Example\nIn the following example, the contents of the array `words` are printed out only if `Arrays.toString` is called on the array first. Similarly, the contents of the multi-dimensional array `wordMatrix` are printed out only if `Arrays.deepToString` is called on the array first.\n\n\n```java\npublic static void main(String args[]) {\n\tString[] words = {\"Who\", \"is\", \"John\", \"Galt\"};\n\tString[][] wordMatrix = {{\"There\", \"is\"}, {\"no\", \"spoon\"}};\n\t\n\t// BAD: This implicitly uses 'Object.toString' to convert the contents\n\t// of 'words[]', and prints out something similar to:\n\t// [Ljava.lang.String;@459189e1\n\tSystem.out.println(words);\n\t\n\t// GOOD: 'Arrays.toString' calls 'toString' on\n\t// each of the array's elements. The statement prints out:\n\t// [Who, is, John, Galt]\n\tSystem.out.println(Arrays.toString(words));\n\t\n\t// ALMOST RIGHT: This calls 'toString' on each of the multi-dimensional \n\t// array's elements. However, because the elements are arrays, the statement\n\t// prints out something similar to:\n\t// [[Ljava.lang.String;@55f33675, [Ljava.lang.String;@527c6768]]\n\tSystem.out.println(Arrays.toString(wordMatrix));\n\t\n\t// GOOD: This properly prints out the contents of the multi-dimensional array:\n\t// [[There, is], [no, spoon]]\n\tSystem.out.println(Arrays.deepToString(wordMatrix));\n}\n```\n\n## References\n* Java API Specification: [Arrays.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#toString(java.lang.Object[])), [Arrays.deepToString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepToString(java.lang.Object[])), [Object.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"},"properties":{"tags":["maintainability"],"description":"Directly printing an array, without first converting the array to a string,\n              produces unreadable results.","id":"java/print-array","kind":"problem","name":"Implicit conversion from array to string","precision":"very-high","problem.severity":"recommendation"}},{"id":"java/useless-tostring-call","name":"java/useless-tostring-call","shortDescription":{"text":"Useless toString on String"},"fullDescription":{"text":"Calling 'toString' on a string is redundant."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Useless toString on String\nThere is no need to call `toString` on a `String` because it just returns the object itself. From the Java API Specification entry for `String.toString()`:\n\n> `public String toString()`\n\nThis object (which is already a string!) is itself returned.\n\n\n## Recommendation\nDo not call `toString` on a `String` object.\n\n\n## Example\nThe following example shows an unnecessary call to `toString` on the string `name`.\n\n\n```java\npublic static void main(String args[]) {\n\tString name = \"John Doe\";\n\t\n\t// BAD: Unnecessary call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my name is \" + name.toString());\n\t\n\t// GOOD: No call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my name is \" + name);\n}\n```\n\n## References\n* Java API Specification: [String.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toString()).\n","markdown":"# Useless toString on String\nThere is no need to call `toString` on a `String` because it just returns the object itself. From the Java API Specification entry for `String.toString()`:\n\n> `public String toString()`\n\nThis object (which is already a string!) is itself returned.\n\n\n## Recommendation\nDo not call `toString` on a `String` object.\n\n\n## Example\nThe following example shows an unnecessary call to `toString` on the string `name`.\n\n\n```java\npublic static void main(String args[]) {\n\tString name = \"John Doe\";\n\t\n\t// BAD: Unnecessary call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my name is \" + name.toString());\n\t\n\t// GOOD: No call to 'toString' on 'name'\n\tSystem.out.println(\"Hi, my name is \" + name);\n}\n```\n\n## References\n* Java API Specification: [String.toString()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#toString()).\n"},"properties":{"tags":["maintainability"],"description":"Calling 'toString' on a string is redundant.","id":"java/useless-tostring-call","kind":"problem","name":"Useless toString on String","precision":"high","problem.severity":"recommendation"}},{"id":"java/class-name-matches-super-class","name":"java/class-name-matches-super-class","shortDescription":{"text":"Class has same name as super class"},"fullDescription":{"text":"A class that has the same name as its superclass may be confusing."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Class has same name as super class\nA class that has the same name as its superclass may be confusing.\n\n\n## Recommendation\nClarify the difference between the subclass and the superclass by using different names.\n\n\n## Example\nIn the following example, it is not clear that the `attendees` field refers to the inner class `Attendees` and not the class `com.company.util.Attendees`.\n\n\n```java\nimport com.company.util.Attendees;\n\npublic class Meeting\n{\n\tprivate Attendees attendees;\n\n\t// ...\n\t// Many lines\n\t// ...\n\n\t// AVOID: This class has the same name as its superclass.\n\tprivate static class Attendees extends com.company.util.Attendees\n\t{\n\t\t// ...\n\t}\n}\n```\nTo fix this, the inner class should be renamed.\n\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4. Prentice Hall, 2008.\n","markdown":"# Class has same name as super class\nA class that has the same name as its superclass may be confusing.\n\n\n## Recommendation\nClarify the difference between the subclass and the superclass by using different names.\n\n\n## Example\nIn the following example, it is not clear that the `attendees` field refers to the inner class `Attendees` and not the class `com.company.util.Attendees`.\n\n\n```java\nimport com.company.util.Attendees;\n\npublic class Meeting\n{\n\tprivate Attendees attendees;\n\n\t// ...\n\t// Many lines\n\t// ...\n\n\t// AVOID: This class has the same name as its superclass.\n\tprivate static class Attendees extends com.company.util.Attendees\n\t{\n\t\t// ...\n\t}\n}\n```\nTo fix this, the inner class should be renamed.\n\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, &sect;17.N4. Prentice Hall, 2008.\n"},"properties":{"tags":["maintainability","readability","naming"],"description":"A class that has the same name as its superclass may be confusing.","id":"java/class-name-matches-super-class","kind":"problem","name":"Class has same name as super class","precision":"high","problem.severity":"recommendation"}},{"id":"java/subtle-inherited-call","name":"java/subtle-inherited-call","shortDescription":{"text":"Subtle call to inherited method"},"fullDescription":{"text":"An unqualified call to a method that exists with the same signature in both a superclass and an outer class is ambiguous."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Subtle call to inherited method\nIf a call is made to a method from an inner class A, and a method of that name is defined in both a superclass of A and an outer class of A, it is not clear to a programmer which method is intended to be called.\n\n\n## Example\nIn the following example, it is not clear whether the call to `printMessage` calls the method that is defined in `Outer` or `Super`.\n\n\n```java\npublic class Outer\n{\n\tvoid printMessage() {\n\t\tSystem.out.println(\"Outer\");\n\t}\n\t\n\tclass Inner extends Super\n\t{\n\t\tvoid ambiguous() {\n\t\t\tprintMessage();  // Ambiguous call\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Outer().new Inner().ambiguous();\n\t}\n}\n\nclass Super\n{\n\tvoid printMessage() {\n\t\tSystem.out.println(\"Super\");\n\t}\n}\n\n```\nInherited methods take precedence over methods in outer classes, so the method in the superclass is called. However, such situations are a potential cause of confusion and defects.\n\n\n## Recommendation\nResolve the ambiguity by explicitly qualifying the method call:\n\n* To specify the outer class, prefix the method with `Outer.this.`.\n* To specify the superclass, prefix the method with `super.`.\nIn the above example, the call to `printMessage` could be replaced by either `Outer.this.printMessage` or `super.printMessage`, depending on which method you intend to call. To preserve the behavior in the example, use `super.printMessage`.\n\n\n## References\n* Inner Classes Specification: [What are top-level classes and inner classes?](http://www.cis.upenn.edu/~bcpierce/courses/629/jdkdocs/guide/innerclasses/spec/innerclasses.doc1.html).\n","markdown":"# Subtle call to inherited method\nIf a call is made to a method from an inner class A, and a method of that name is defined in both a superclass of A and an outer class of A, it is not clear to a programmer which method is intended to be called.\n\n\n## Example\nIn the following example, it is not clear whether the call to `printMessage` calls the method that is defined in `Outer` or `Super`.\n\n\n```java\npublic class Outer\n{\n\tvoid printMessage() {\n\t\tSystem.out.println(\"Outer\");\n\t}\n\t\n\tclass Inner extends Super\n\t{\n\t\tvoid ambiguous() {\n\t\t\tprintMessage();  // Ambiguous call\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Outer().new Inner().ambiguous();\n\t}\n}\n\nclass Super\n{\n\tvoid printMessage() {\n\t\tSystem.out.println(\"Super\");\n\t}\n}\n\n```\nInherited methods take precedence over methods in outer classes, so the method in the superclass is called. However, such situations are a potential cause of confusion and defects.\n\n\n## Recommendation\nResolve the ambiguity by explicitly qualifying the method call:\n\n* To specify the outer class, prefix the method with `Outer.this.`.\n* To specify the superclass, prefix the method with `super.`.\nIn the above example, the call to `printMessage` could be replaced by either `Outer.this.printMessage` or `super.printMessage`, depending on which method you intend to call. To preserve the behavior in the example, use `super.printMessage`.\n\n\n## References\n* Inner Classes Specification: [What are top-level classes and inner classes?](http://www.cis.upenn.edu/~bcpierce/courses/629/jdkdocs/guide/innerclasses/spec/innerclasses.doc1.html).\n"},"properties":{"tags":["reliability","readability"],"description":"An unqualified call to a method that exists with the same signature in both a\n              superclass and an outer class is ambiguous.","id":"java/subtle-inherited-call","kind":"problem","name":"Subtle call to inherited method","precision":"very-high","problem.severity":"warning"}},{"id":"java/local-shadows-field","name":"java/local-shadows-field","shortDescription":{"text":"Possible confusion of local and field"},"fullDescription":{"text":"A method in which a variable is declared with the same name as a field is difficult to understand."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Possible confusion of local and field\nIf a method declares a local variable with the same name as a field, then it is very easy to mix up the two when reading or modifying the program.\n\n\n## Recommendation\nConsider using different names for the field and local variable to make the difference between them clear.\n\n\n## Example\nThe following example shows a local variable `values` that has the same name as a field.\n\n\n```java\npublic class Container\n{\n\tprivate int[] values; // Field called 'values'\n\t\n\tpublic Container (int... values) {\n\t\tthis.values = values;\n\t}\n\n\tpublic Container dup() {\n\t\tint length = values.length;\n\t\tint[] values = new int[length];  // Local variable called 'values'\n\t\tContainer result = new Container(values);\n\t\treturn result;\n\t}\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [ 6.4 Shadowing and Obscuring](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4).\n","markdown":"# Possible confusion of local and field\nIf a method declares a local variable with the same name as a field, then it is very easy to mix up the two when reading or modifying the program.\n\n\n## Recommendation\nConsider using different names for the field and local variable to make the difference between them clear.\n\n\n## Example\nThe following example shows a local variable `values` that has the same name as a field.\n\n\n```java\npublic class Container\n{\n\tprivate int[] values; // Field called 'values'\n\t\n\tpublic Container (int... values) {\n\t\tthis.values = values;\n\t}\n\n\tpublic Container dup() {\n\t\tint length = values.length;\n\t\tint[] values = new int[length];  // Local variable called 'values'\n\t\tContainer result = new Container(values);\n\t\treturn result;\n\t}\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [ 6.4 Shadowing and Obscuring](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4).\n"},"properties":{"tags":["maintainability","readability"],"description":"A method in which a variable is declared with the same name as a field is difficult\n              to understand.","id":"java/local-shadows-field","kind":"problem","name":"Possible confusion of local and field","precision":"high","problem.severity":"recommendation"}},{"id":"java/confusing-method-signature","name":"java/confusing-method-signature","shortDescription":{"text":"Confusing overloading of methods"},"fullDescription":{"text":"Overloaded methods that have the same number of parameters, where each pair of corresponding parameter types is convertible by casting or autoboxing, may be confusing."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Confusing overloading of methods\nOverloaded method declarations that have the same number of parameters may be confusing if none of the corresponding pairs of parameter types is substantially different. A pair of parameter types A and B is substantially different if A cannot be cast to B and B cannot be cast to A. If the parameter types are not substantially different then the programmer may assume that the method with parameter type A is called when in fact the method with parameter type B is called.\n\n\n## Recommendation\nIt is generally best to avoid declaring overloaded methods with the same number of parameters, unless at least one of the corresponding parameter pairs is substantially different.\n\n\n## Example\nDeclaring overloaded methods `process(Object obj)` and `process(String s)` is confusing because the parameter types are not substantially different. It is clearer to declare methods with different names: `processObject(Object obj)` and `processString(String s)`.\n\nIn contrast, declaring overloaded methods `process(Object obj, String s)` and `process(String s, int i)` is not as confusing because the second parameters of each method are substantially different.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 41. Addison-Wesley, 2008.\n* Java Language Specification: [15.12 Method Invocation Expressions](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12).\n","markdown":"# Confusing overloading of methods\nOverloaded method declarations that have the same number of parameters may be confusing if none of the corresponding pairs of parameter types is substantially different. A pair of parameter types A and B is substantially different if A cannot be cast to B and B cannot be cast to A. If the parameter types are not substantially different then the programmer may assume that the method with parameter type A is called when in fact the method with parameter type B is called.\n\n\n## Recommendation\nIt is generally best to avoid declaring overloaded methods with the same number of parameters, unless at least one of the corresponding parameter pairs is substantially different.\n\n\n## Example\nDeclaring overloaded methods `process(Object obj)` and `process(String s)` is confusing because the parameter types are not substantially different. It is clearer to declare methods with different names: `processObject(Object obj)` and `processString(String s)`.\n\nIn contrast, declaring overloaded methods `process(Object obj, String s)` and `process(String s, int i)` is not as confusing because the second parameters of each method are substantially different.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 41. Addison-Wesley, 2008.\n* Java Language Specification: [15.12 Method Invocation Expressions](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12).\n"},"properties":{"tags":["maintainability","readability","naming"],"description":"Overloaded methods that have the same number of parameters, where each pair of\n              corresponding parameter types is convertible by casting or autoboxing, may be\n              confusing.","id":"java/confusing-method-signature","kind":"problem","name":"Confusing overloading of methods","precision":"high","problem.severity":"recommendation"}},{"id":"java/confusing-method-name","name":"java/confusing-method-name","shortDescription":{"text":"Confusing method names because of capitalization"},"fullDescription":{"text":"Methods in the same class whose names differ only in capitalization are confusing."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Confusing method names because of capitalization\nIt is bad practice to have methods in a class with names that differ only in their capitalization. This can be confusing and lead to mistakes.\n\n\n## Recommendation\nName the methods to make the distinction between them clear.\n\n\n## Example\nThe following example shows a class that contains two methods: `toUri` and `toURI`. One or both of them should be renamed.\n\n\n```java\npublic class InternetResource\n{\n\tprivate String protocol;\n\tprivate String host;\n\tprivate String path;\n\n\t// ...\n\n\tpublic String toUri() {\n\t\treturn protocol + \"://\" + host + \"/\" + path;\n\t}\n\n\t// ...\n\n\tpublic String toURI() {\n\t\treturn toUri();\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, 17.N4. Prentice Hall, 2008.\n","markdown":"# Confusing method names because of capitalization\nIt is bad practice to have methods in a class with names that differ only in their capitalization. This can be confusing and lead to mistakes.\n\n\n## Recommendation\nName the methods to make the distinction between them clear.\n\n\n## Example\nThe following example shows a class that contains two methods: `toUri` and `toURI`. One or both of them should be renamed.\n\n\n```java\npublic class InternetResource\n{\n\tprivate String protocol;\n\tprivate String host;\n\tprivate String path;\n\n\t// ...\n\n\tpublic String toUri() {\n\t\treturn protocol + \"://\" + host + \"/\" + path;\n\t}\n\n\t// ...\n\n\tpublic String toURI() {\n\t\treturn toUri();\n\t}\n}\n```\n\n## References\n* R. C. Martin, *Clean Code: A Handbook of Agile Software Craftsmanship*, 17.N4. Prentice Hall, 2008.\n"},"properties":{"tags":["maintainability","readability","naming"],"description":"Methods in the same class whose names differ only in capitalization are\n              confusing.","id":"java/confusing-method-name","kind":"problem","name":"Confusing method names because of capitalization","precision":"high","problem.severity":"recommendation"}},{"id":"java/local-variable-is-never-read","name":"java/local-variable-is-never-read","shortDescription":{"text":"Unread local variable"},"fullDescription":{"text":"A local variable that is never read is redundant."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Unread local variable\nA local variable that is never read is useless.\n\nAs a matter of good practice, there should be no unused or useless code. It makes the program more difficult to understand and maintain, and can waste a programmer's time.\n\n\n## Recommendation\nThis rule applies to variables that are never used as well as variables that are only written to but never read. In both cases, ensure that no operations are missing that would use the local variable. If appropriate, simply remove the declaration. However, if the variable is written to, ensure that any side-effects in the assignments are retained. (For further details, see the example.)\n\n\n## Example\nIn the following example, the local variable `oldQuantity` is assigned a value but never read. In the fixed version of the example, the variable is removed but the call to `items.put` in the assignment is retained.\n\n\n```java\n// Version containing unread local variable\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\tInteger oldQuantity = items.put(i, quantity);  // AVOID: Unread local variable\n\t}\n}\n\n// Version with unread local variable removed\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\titems.put(i, quantity);\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n","markdown":"# Unread local variable\nA local variable that is never read is useless.\n\nAs a matter of good practice, there should be no unused or useless code. It makes the program more difficult to understand and maintain, and can waste a programmer's time.\n\n\n## Recommendation\nThis rule applies to variables that are never used as well as variables that are only written to but never read. In both cases, ensure that no operations are missing that would use the local variable. If appropriate, simply remove the declaration. However, if the variable is written to, ensure that any side-effects in the assignments are retained. (For further details, see the example.)\n\n\n## Example\nIn the following example, the local variable `oldQuantity` is assigned a value but never read. In the fixed version of the example, the variable is removed but the call to `items.put` in the assignment is retained.\n\n\n```java\n// Version containing unread local variable\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\tInteger oldQuantity = items.put(i, quantity);  // AVOID: Unread local variable\n\t}\n}\n\n// Version with unread local variable removed\npublic class Cart {\n\tprivate Map<Item, Integer> items = ...;\n\tpublic void add(Item i) {\n\t\tInteger quantity = items.get(i);\n\t\tif (quantity = null)\n\t\t\tquantity = 1;\n\t\telse\n\t\t\tquantity++;\n\t\titems.put(i, quantity);\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"},"properties":{"tags":["maintainability","useless-code","external/cwe/cwe-561"],"description":"A local variable that is never read is redundant.","id":"java/local-variable-is-never-read","kind":"problem","name":"Unread local variable","precision":"high","problem.severity":"recommendation"}},{"id":"java/unused-label","name":"java/unused-label","shortDescription":{"text":"Unused label"},"fullDescription":{"text":"An unused label for a loop or 'switch' statement is either redundant or indicates incorrect 'break' or 'continue' statements."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Unused label\nLoop and `switch` statements can be labeled. These labels can serve as targets for `break` or `continue` statements, to specify which loop or `switch` statement they refer to.\n\nApart from serving as such jump targets, the labels have no effect on program behavior, which means that having an unused label is suspicious.\n\n\n## Recommendation\nIf the label is used to document the intended behavior of a loop or `switch` statement, remove it. It is better to use comments for this purpose. However, an unused label may indicate that something is wrong: that some of the nested `break` or `continue` statements should be using the label. In this case, the current control flow is probably wrong, and you should adjust some jumps to use the label after checking the desired behavior.\n\n\n## Example\nThe following example uses a loop and a nested loop to check whether any of the currently active shopping carts contains a particular item. On line 4, the `carts:` label is unused. Inspecting the code, we can see that the `break` statement on line 10 is inefficient because it only breaks out of the nested loop. It could in fact break out of the outer loop, which should improve performance in common cases. By changing the statement on line 10 to read `break carts;`, the label is no longer unused and we improve the code.\n\n\n```java\npublic class WebStore {\n\tpublic boolean itemIsBeingBought(Item item) {\n\t\tboolean found = false;\n\t\tcarts:  // AVOID: Unused label\n\t\tfor (int i = 0; i < carts.size(); i++) {\n\t\t\tCart cart = carts.get(i);\n\t\t\tfor (int j = 0; j < cart.numItems(); j++) {\n\t\t\t\tif (item.equals(cart.getItem(j))) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n","markdown":"# Unused label\nLoop and `switch` statements can be labeled. These labels can serve as targets for `break` or `continue` statements, to specify which loop or `switch` statement they refer to.\n\nApart from serving as such jump targets, the labels have no effect on program behavior, which means that having an unused label is suspicious.\n\n\n## Recommendation\nIf the label is used to document the intended behavior of a loop or `switch` statement, remove it. It is better to use comments for this purpose. However, an unused label may indicate that something is wrong: that some of the nested `break` or `continue` statements should be using the label. In this case, the current control flow is probably wrong, and you should adjust some jumps to use the label after checking the desired behavior.\n\n\n## Example\nThe following example uses a loop and a nested loop to check whether any of the currently active shopping carts contains a particular item. On line 4, the `carts:` label is unused. Inspecting the code, we can see that the `break` statement on line 10 is inefficient because it only breaks out of the nested loop. It could in fact break out of the outer loop, which should improve performance in common cases. By changing the statement on line 10 to read `break carts;`, the label is no longer unused and we improve the code.\n\n\n```java\npublic class WebStore {\n\tpublic boolean itemIsBeingBought(Item item) {\n\t\tboolean found = false;\n\t\tcarts:  // AVOID: Unused label\n\t\tfor (int i = 0; i < carts.size(); i++) {\n\t\t\tCart cart = carts.get(i);\n\t\t\tfor (int j = 0; j < cart.numItems(); j++) {\n\t\t\t\tif (item.equals(cart.getItem(j))) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n}\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"},"properties":{"tags":["maintainability","useless-code","external/cwe/cwe-561"],"description":"An unused label for a loop or 'switch' statement is either redundant or indicates\n              incorrect 'break' or 'continue' statements.","id":"java/unused-label","kind":"problem","name":"Unused label","precision":"high","problem.severity":"recommendation"}},{"id":"java/unused-reference-type","name":"java/unused-reference-type","shortDescription":{"text":"Unused classes and interfaces"},"fullDescription":{"text":"A non-public class or interface that is not used anywhere in the program wastes programmer resources."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Unused classes and interfaces\nA non-public class or interface that is not used anywhere in the program may cause a programmer to waste time and effort maintaining and documenting it.\n\n\n## Recommendation\nEnsure that redundant types are removed from the program.\n\n\n## References\n* Wikipedia: [Unreachable code](http://en.wikipedia.org/wiki/Unreachable_code).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n","markdown":"# Unused classes and interfaces\nA non-public class or interface that is not used anywhere in the program may cause a programmer to waste time and effort maintaining and documenting it.\n\n\n## Recommendation\nEnsure that redundant types are removed from the program.\n\n\n## References\n* Wikipedia: [Unreachable code](http://en.wikipedia.org/wiki/Unreachable_code).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"},"properties":{"tags":["maintainability","useless-code","external/cwe/cwe-561"],"description":"A non-public class or interface that is not used anywhere in the program wastes\n              programmer resources.","id":"java/unused-reference-type","kind":"problem","name":"Unused classes and interfaces","precision":"high","problem.severity":"recommendation"}},{"id":"java/unimplementable-interface","name":"java/unimplementable-interface","shortDescription":{"text":"Interface cannot be implemented"},"fullDescription":{"text":"An interface method that is incompatible with a protected method on 'java.lang.Object' means that the interface cannot be implemented."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Interface cannot be implemented\nAn interface that contains methods whose return types clash with protected methods on `java.lang.Object` can never be implemented, because methods cannot be overloaded based simply on their return type.\n\n\n## Recommendation\nIf the interface is useful, name methods so that they do not clash with methods in `Object`. Otherwise you should delete the interface.\n\n\n## Example\nIn the following example, the interface `I` is useless because the `clone` method must return type `java.lang.Object`:\n\n\n```java\ninterface I {\n    int clone();\n}\n\nclass C implements I {\n    public int clone() {\n        return 23;\n    }\n}\n```\nAny attempt to implement the interface produces an error:\n\n```\n\nInterfaceCannotBeImplemented.java:6: clone() in C cannot override\n  clone() in java.lang.Object; attempting to use incompatible return\n  type\nfound   : int\nrequired: java.lang.Object\n  public int clone() {\n             ^\n1 error\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [9.2 Interface Members](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.2).\n","markdown":"# Interface cannot be implemented\nAn interface that contains methods whose return types clash with protected methods on `java.lang.Object` can never be implemented, because methods cannot be overloaded based simply on their return type.\n\n\n## Recommendation\nIf the interface is useful, name methods so that they do not clash with methods in `Object`. Otherwise you should delete the interface.\n\n\n## Example\nIn the following example, the interface `I` is useless because the `clone` method must return type `java.lang.Object`:\n\n\n```java\ninterface I {\n    int clone();\n}\n\nclass C implements I {\n    public int clone() {\n        return 23;\n    }\n}\n```\nAny attempt to implement the interface produces an error:\n\n```\n\nInterfaceCannotBeImplemented.java:6: clone() in C cannot override\n  clone() in java.lang.Object; attempting to use incompatible return\n  type\nfound   : int\nrequired: java.lang.Object\n  public int clone() {\n             ^\n1 error\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [9.2 Interface Members](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.2).\n"},"properties":{"tags":["maintainability","useless-code"],"description":"An interface method that is incompatible with a protected method on\n              'java.lang.Object' means that the interface cannot be implemented.","id":"java/unimplementable-interface","kind":"problem","name":"Interface cannot be implemented","precision":"very-high","problem.severity":"warning"}},{"id":"java/non-null-boxed-variable","name":"java/non-null-boxed-variable","shortDescription":{"text":"Boxed variable is never null"},"fullDescription":{"text":"Using a boxed type for a variable that is never assigned 'null' hinders readability because it implies that 'null' is a potential value."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Boxed variable is never null\nIn Java all of the primitive types have boxed counterparts. The boxed types are objects and can therefore be `null`, whereas the primitive types can never be `null`. The names of the primitive and boxed types are similar except that primitive types start with a lower-case letter and boxed types start with an upper-case letter (also, for `char` and `int` the names of the boxed types are slightly longer, namely `Character` and `Integer`).\n\nBecause the names are so similar and because Java performs automatic boxing and unboxing conversions, they can easily be confused. Furthermore, using a boxed type where a primitive type was intended leads to both readability issues and potentially superfluous allocation of objects.\n\n\n## Recommendation\nIf a variable is never assigned `null` it should use the primitive type, as this both directly shows the impossibility of `null` and also avoids unnecessary boxing and unboxing conversions.\n\n\n## Example\nIn the example below the variable `done` controls the loop exit. It is only set to `false` before the loop entry and set to `true` at some point during the loop iteration.\n\n\n```java\nBoolean done = false;\nwhile (!done) {\n  // ...\n  done = true;\n  // ...\n}\n\n```\nEach of the assignments to `done` involves a boxing conversion and the check involves an unboxing conversion. Since `done` is never `null`, these conversions can be completely avoided, and the code made clearer, by using the primitive type instead. Therefore the code should be rewritten in the following way:\n\n\n```java\nboolean done = false;\nwhile (!done) {\n  // ...\n  done = true;\n  // ...\n}\n\n```\n\n## References\n* Java Language Specification: [Boxing Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.7), [Unboxing Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.8).\n* The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n","markdown":"# Boxed variable is never null\nIn Java all of the primitive types have boxed counterparts. The boxed types are objects and can therefore be `null`, whereas the primitive types can never be `null`. The names of the primitive and boxed types are similar except that primitive types start with a lower-case letter and boxed types start with an upper-case letter (also, for `char` and `int` the names of the boxed types are slightly longer, namely `Character` and `Integer`).\n\nBecause the names are so similar and because Java performs automatic boxing and unboxing conversions, they can easily be confused. Furthermore, using a boxed type where a primitive type was intended leads to both readability issues and potentially superfluous allocation of objects.\n\n\n## Recommendation\nIf a variable is never assigned `null` it should use the primitive type, as this both directly shows the impossibility of `null` and also avoids unnecessary boxing and unboxing conversions.\n\n\n## Example\nIn the example below the variable `done` controls the loop exit. It is only set to `false` before the loop entry and set to `true` at some point during the loop iteration.\n\n\n```java\nBoolean done = false;\nwhile (!done) {\n  // ...\n  done = true;\n  // ...\n}\n\n```\nEach of the assignments to `done` involves a boxing conversion and the check involves an unboxing conversion. Since `done` is never `null`, these conversions can be completely avoided, and the code made clearer, by using the primitive type instead. Therefore the code should be rewritten in the following way:\n\n\n```java\nboolean done = false;\nwhile (!done) {\n  // ...\n  done = true;\n  // ...\n}\n\n```\n\n## References\n* Java Language Specification: [Boxing Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.7), [Unboxing Conversion](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.8).\n* The Java Tutorials: [Autoboxing and Unboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html).\n"},"properties":{"tags":["readability","types"],"description":"Using a boxed type for a variable that is never assigned 'null'\n              hinders readability because it implies that 'null' is a potential value.","id":"java/non-null-boxed-variable","kind":"problem","name":"Boxed variable is never null","precision":"very-high","problem.severity":"warning"}},{"id":"java/constants-only-interface","name":"java/constants-only-interface","shortDescription":{"text":"Constant interface anti-pattern"},"fullDescription":{"text":"Implementing an interface (or extending an abstract class) only to put a number of constant definitions into scope is considered bad practice."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Constant interface anti-pattern\nDefinitions of constants (meaning static, final fields) should be placed in an appropriate class where they belong logically. However, it is usually bad practice to implement an interface (or extend an abstract class) only to put a number of constant definitions into scope.\n\n\n## Recommendation\nThe preferred way of putting the constant definitions into scope is to use the `import static` directive, which allows a compilation unit to put any visible static members from other classes into scope.\n\nThis issue is discussed in \\[Bloch\\]:\n\n> That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the classes exported API. It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility.\n\nTo prevent this pollution of a class's binary interface, it is best to move the constant definitions to whatever concrete class uses them most frequently. Users of the definitions could use `import static` to access the relevant fields.\n\n\n## Example\nIn the following example, the interface `MathConstants` has been defined only to hold a constant.\n\n\n```java\npublic class NoConstantsOnly {\n\tstatic interface MathConstants\n\t{\n\t    public static final Double Pi = 3.14;\n\t}\n\n\tstatic class Circle implements MathConstants\n\t{\n\t    public double radius;\n\t    public double area()\n\t    {\n\t        return Math.pow(radius, 2) * Pi;\n\t    }\n\t}\n}\n```\nInstead, the constant should be moved to the `Circle` class or another class that uses the constant frequently.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 19. Addison-Wesley, 2008.\n","markdown":"# Constant interface anti-pattern\nDefinitions of constants (meaning static, final fields) should be placed in an appropriate class where they belong logically. However, it is usually bad practice to implement an interface (or extend an abstract class) only to put a number of constant definitions into scope.\n\n\n## Recommendation\nThe preferred way of putting the constant definitions into scope is to use the `import static` directive, which allows a compilation unit to put any visible static members from other classes into scope.\n\nThis issue is discussed in \\[Bloch\\]:\n\n> That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the classes exported API. It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility.\n\nTo prevent this pollution of a class's binary interface, it is best to move the constant definitions to whatever concrete class uses them most frequently. Users of the definitions could use `import static` to access the relevant fields.\n\n\n## Example\nIn the following example, the interface `MathConstants` has been defined only to hold a constant.\n\n\n```java\npublic class NoConstantsOnly {\n\tstatic interface MathConstants\n\t{\n\t    public static final Double Pi = 3.14;\n\t}\n\n\tstatic class Circle implements MathConstants\n\t{\n\t    public double radius;\n\t    public double area()\n\t    {\n\t        return Math.pow(radius, 2) * Pi;\n\t    }\n\t}\n}\n```\nInstead, the constant should be moved to the `Circle` class or another class that uses the constant frequently.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 19. Addison-Wesley, 2008.\n"},"properties":{"tags":["maintainability","modularity"],"description":"Implementing an interface (or extending an abstract class)\n              only to put a number of constant definitions into scope is considered bad practice.","id":"java/constants-only-interface","kind":"problem","name":"Constant interface anti-pattern","precision":"high","problem.severity":"recommendation"}},{"id":"java/ignored-error-status-of-call","name":"java/ignored-error-status-of-call","shortDescription":{"text":"Ignored error status of call"},"fullDescription":{"text":"Ignoring an exceptional value that is returned by a method may cause subsequent code to fail."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Ignored error status of call\nMany methods in the Java Development Kit (for examples, see the references below) return status values (for example, as an `int`) to indicate whether the method execution finished normally. They may return an error code if the method did not finish normally. If the method result is not checked, exceptional method executions may cause subsequent code to fail.\n\n\n## Recommendation\nYou should insert additional code to check the return value and take appropriate action.\n\n\n## Example\nThe following example uses the `java.io.InputStream.read` method to read 16 bytes from an input stream and store them in an array. However, `read` may not actually be able to read as many bytes as requested, for example because the stream is exhausted. Therefore, the code should not simply rely on the array `b` being filled with precisely 16 bytes from the input stream. Instead, the code should check the method's return value, which indicates the number of bytes actually read.\n\n\n```java\njava.io.InputStream is = (...);\nbyte[] b = new byte[16];\nis.read(b);\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [ EXP00-J. Do not ignore values returned by methods](https://wiki.sei.cmu.edu/confluence/display/java/EXP00-J.+Do+not+ignore+values+returned+by+methods).\n* Java API Specification: [ java.util.Queue.offer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html#offer(E)).\n* Java API Specification: [ java.util.concurrent.BlockingQueue.offer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/BlockingQueue.html#offer(E,long,java.util.concurrent.TimeUnit)).\n* Java API Specification, java.util.concurrent.locks.Condition: [ await](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html#await(long,java.util.concurrent.TimeUnit)), [ awaitUntil](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html#awaitUntil(java.util.Date)), [ awaitNanos](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html#awaitNanos(long)).\n* Java API Specification, java.io.File: [ createNewFile](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#createNewFile()), [ delete](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#delete()), [ mkdir](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#mkdir()), [ renameTo](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#renameTo(java.io.File)), [ setLastModified](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setLastModified(long)), [ setReadOnly](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setReadOnly()), [ setWritable(boolean)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setWritable(boolean)), [ setWritable(boolean, boolean)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setWritable(boolean,boolean)).\n* Java API Specification, java.io.InputStream: [ skip](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#skip(long)), [ read(byte\\[\\])](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#read(byte%5B%5D)), [ read(byte\\[\\], int, int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#read(byte[],int,int)).\n* Common Weakness Enumeration: [CWE-391](https://cwe.mitre.org/data/definitions/391.html).\n","markdown":"# Ignored error status of call\nMany methods in the Java Development Kit (for examples, see the references below) return status values (for example, as an `int`) to indicate whether the method execution finished normally. They may return an error code if the method did not finish normally. If the method result is not checked, exceptional method executions may cause subsequent code to fail.\n\n\n## Recommendation\nYou should insert additional code to check the return value and take appropriate action.\n\n\n## Example\nThe following example uses the `java.io.InputStream.read` method to read 16 bytes from an input stream and store them in an array. However, `read` may not actually be able to read as many bytes as requested, for example because the stream is exhausted. Therefore, the code should not simply rely on the array `b` being filled with precisely 16 bytes from the input stream. Instead, the code should check the method's return value, which indicates the number of bytes actually read.\n\n\n```java\njava.io.InputStream is = (...);\nbyte[] b = new byte[16];\nis.read(b);\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [ EXP00-J. Do not ignore values returned by methods](https://wiki.sei.cmu.edu/confluence/display/java/EXP00-J.+Do+not+ignore+values+returned+by+methods).\n* Java API Specification: [ java.util.Queue.offer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html#offer(E)).\n* Java API Specification: [ java.util.concurrent.BlockingQueue.offer](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/BlockingQueue.html#offer(E,long,java.util.concurrent.TimeUnit)).\n* Java API Specification, java.util.concurrent.locks.Condition: [ await](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html#await(long,java.util.concurrent.TimeUnit)), [ awaitUntil](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html#awaitUntil(java.util.Date)), [ awaitNanos](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html#awaitNanos(long)).\n* Java API Specification, java.io.File: [ createNewFile](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#createNewFile()), [ delete](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#delete()), [ mkdir](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#mkdir()), [ renameTo](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#renameTo(java.io.File)), [ setLastModified](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setLastModified(long)), [ setReadOnly](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setReadOnly()), [ setWritable(boolean)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setWritable(boolean)), [ setWritable(boolean, boolean)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/File.html#setWritable(boolean,boolean)).\n* Java API Specification, java.io.InputStream: [ skip](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#skip(long)), [ read(byte\\[\\])](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#read(byte%5B%5D)), [ read(byte\\[\\], int, int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html#read(byte[],int,int)).\n* Common Weakness Enumeration: [CWE-391](https://cwe.mitre.org/data/definitions/391.html).\n"},"properties":{"tags":["reliability","correctness","external/cwe/cwe-391"],"description":"Ignoring an exceptional value that is returned by a method may cause subsequent\n              code to fail.","id":"java/ignored-error-status-of-call","kind":"problem","name":"Ignored error status of call","precision":"high","problem.severity":"recommendation"}},{"id":"java/uncaught-number-format-exception","name":"java/uncaught-number-format-exception","shortDescription":{"text":"Missing catch of NumberFormatException"},"fullDescription":{"text":"Calling a string to number conversion method without handling 'NumberFormatException' may cause unexpected runtime exceptions."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Missing catch of NumberFormatException\nMethods such as `Integer.parseInt` that parse strings into numbers throw `NumberFormatException` if their arguments cannot be parsed. This exception should be caught so that any parse errors can be handled.\n\n\n## Recommendation\nIt is usually best to handle `NumberFormatException` in a `catch` clause surrounding the call to the parsing method.\n\n\n## Example\nIn the following example, the first call to `Integer.parseInt` does not catch the exception. The second call does.\n\n\n```java\nString s = ...;\nint n;\n\nn = Integer.parseInt(s); // BAD: NumberFormatException is not caught.\n\ntry {\n        n = Integer.parseInt(s);\n} catch (NumberFormatException e) {  // GOOD: The exception is caught. \n        // Handle the exception\n}\n\n```\n\n## References\n* Java API Specification: [Integer.valueOf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#valueOf(java.lang.String)), [Integer.parseInt](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#parseInt(java.lang.String)), [Long.parseLong](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html#parseLong(java.lang.String)), [NumberFormatException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NumberFormatException.html).\n* Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).\n","markdown":"# Missing catch of NumberFormatException\nMethods such as `Integer.parseInt` that parse strings into numbers throw `NumberFormatException` if their arguments cannot be parsed. This exception should be caught so that any parse errors can be handled.\n\n\n## Recommendation\nIt is usually best to handle `NumberFormatException` in a `catch` clause surrounding the call to the parsing method.\n\n\n## Example\nIn the following example, the first call to `Integer.parseInt` does not catch the exception. The second call does.\n\n\n```java\nString s = ...;\nint n;\n\nn = Integer.parseInt(s); // BAD: NumberFormatException is not caught.\n\ntry {\n        n = Integer.parseInt(s);\n} catch (NumberFormatException e) {  // GOOD: The exception is caught. \n        // Handle the exception\n}\n\n```\n\n## References\n* Java API Specification: [Integer.valueOf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#valueOf(java.lang.String)), [Integer.parseInt](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#parseInt(java.lang.String)), [Long.parseLong](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Long.html#parseLong(java.lang.String)), [NumberFormatException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NumberFormatException.html).\n* Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).\n"},"properties":{"tags":["reliability","external/cwe/cwe-248"],"description":"Calling a string to number conversion method without handling\n              'NumberFormatException' may cause unexpected runtime exceptions.","id":"java/uncaught-number-format-exception","kind":"problem","name":"Missing catch of NumberFormatException","precision":"high","problem.severity":"recommendation"}},{"id":"java/static-initialization-vector","name":"java/static-initialization-vector","shortDescription":{"text":"Using a static initialization vector for encryption"},"fullDescription":{"text":"An initialization vector (IV) used for ciphers of certain modes (such as CBC or GCM) should be unique and unpredictable, to maximize encryption and prevent dictionary attacks."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Using a static initialization vector for encryption\nWhen a cipher is used in certain modes such as CBC or GCM, it requires an initialization vector (IV). Under the same secret key, IVs should be unique and ideally unpredictable. If the same IV is used with the same secret key, then the same plaintext results in the same ciphertext. This can let an attacker learn if the same data pieces are transferred or stored, or help the attacker run a dictionary attack.\n\n\n## Recommendation\nUse a random IV generated by `SecureRandom`.\n\n\n## Example\nThe following example initializes a cipher with a static IV, which is unsafe:\n\n\n```java\nbyte[] iv = new byte[16]; // all zeroes\nGCMParameterSpec params = new GCMParameterSpec(128, iv);\nCipher cipher = Cipher.getInstance(\"AES/GCM/PKCS5PADDING\");\ncipher.init(Cipher.ENCRYPT_MODE, key, params);\n```\nThe next example initializes a cipher with a random IV:\n\n\n```java\nbyte[] iv = new byte[16];\nSecureRandom random = SecureRandom.getInstanceStrong();\nrandom.nextBytes(iv);\nGCMParameterSpec params = new GCMParameterSpec(128, iv);\nCipher cipher = Cipher.getInstance(\"AES/GCM/PKCS5PADDING\");\ncipher.init(Cipher.ENCRYPT_MODE, key, params);\n```\n\n## References\n* Wikipedia: [Initialization vector](https://en.wikipedia.org/wiki/Initialization_vector).\n* National Institute of Standards and Technology: [Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf).\n* National Institute of Standards and Technology: [FIPS 140-2: Security Requirements for Cryptographic Modules](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf).\n* Common Weakness Enumeration: [CWE-329](https://cwe.mitre.org/data/definitions/329.html).\n* Common Weakness Enumeration: [CWE-1204](https://cwe.mitre.org/data/definitions/1204.html).\n","markdown":"# Using a static initialization vector for encryption\nWhen a cipher is used in certain modes such as CBC or GCM, it requires an initialization vector (IV). Under the same secret key, IVs should be unique and ideally unpredictable. If the same IV is used with the same secret key, then the same plaintext results in the same ciphertext. This can let an attacker learn if the same data pieces are transferred or stored, or help the attacker run a dictionary attack.\n\n\n## Recommendation\nUse a random IV generated by `SecureRandom`.\n\n\n## Example\nThe following example initializes a cipher with a static IV, which is unsafe:\n\n\n```java\nbyte[] iv = new byte[16]; // all zeroes\nGCMParameterSpec params = new GCMParameterSpec(128, iv);\nCipher cipher = Cipher.getInstance(\"AES/GCM/PKCS5PADDING\");\ncipher.init(Cipher.ENCRYPT_MODE, key, params);\n```\nThe next example initializes a cipher with a random IV:\n\n\n```java\nbyte[] iv = new byte[16];\nSecureRandom random = SecureRandom.getInstanceStrong();\nrandom.nextBytes(iv);\nGCMParameterSpec params = new GCMParameterSpec(128, iv);\nCipher cipher = Cipher.getInstance(\"AES/GCM/PKCS5PADDING\");\ncipher.init(Cipher.ENCRYPT_MODE, key, params);\n```\n\n## References\n* Wikipedia: [Initialization vector](https://en.wikipedia.org/wiki/Initialization_vector).\n* National Institute of Standards and Technology: [Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf).\n* National Institute of Standards and Technology: [FIPS 140-2: Security Requirements for Cryptographic Modules](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf).\n* Common Weakness Enumeration: [CWE-329](https://cwe.mitre.org/data/definitions/329.html).\n* Common Weakness Enumeration: [CWE-1204](https://cwe.mitre.org/data/definitions/1204.html).\n"},"properties":{"tags":["security","external/cwe/cwe-329","external/cwe/cwe-1204"],"description":"An initialization vector (IV) used for ciphers of certain modes (such as CBC or GCM) should be unique and unpredictable, to maximize encryption and prevent dictionary attacks.","id":"java/static-initialization-vector","kind":"path-problem","name":"Using a static initialization vector for encryption","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/android/webview-debugging-enabled","name":"java/android/webview-debugging-enabled","shortDescription":{"text":"Android Webview debugging enabled"},"fullDescription":{"text":"Enabling Webview debugging in production builds can expose entry points or leak sensitive information."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Android Webview debugging enabled\nThe `WebView.setWebContentsDebuggingEnabled` method enables or disables the contents of any `WebView` in the application to be debugged.\n\nYou should only enable debugging features during development. When you create a production build, you should disable it. If you enable debugging features, this can make your code vulnerable by adding entry points, or leaking sensitive information.\n\n\n## Recommendation\nEnsure that debugging features are not enabled in production builds, such as by guarding calls to `WebView.setWebContentsDebuggingEnabled(true)` by a flag that is only enabled in debug builds.\n\n\n## Example\nIn the first (bad) example, WebView debugging is always enabled. whereas the GOOD case only enables it if the `android:debuggable` attribute is set to `true`.\n\n\n```java\n// BAD - debugging is always enabled \nWebView.setWebContentsDebuggingEnabled(true);\n\n// GOOD - debugging is only enabled when this is a debug build, as indicated by the debuggable flag being set.\nif (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE)) {\n    WebView.setWebContentsDebuggingEnabled(true);\n}\n```\n\n## References\n* Android Developers: [setWebContentsDebuggingEnabled](https://developer.android.com/reference/android/webkit/WebView.html#setWebContentsDebuggingEnabled(boolean)).\n* Android Developers: [Remote debugging WebViews](https://developer.chrome.com/docs/devtools/remote-debugging/webviews/).\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n","markdown":"# Android Webview debugging enabled\nThe `WebView.setWebContentsDebuggingEnabled` method enables or disables the contents of any `WebView` in the application to be debugged.\n\nYou should only enable debugging features during development. When you create a production build, you should disable it. If you enable debugging features, this can make your code vulnerable by adding entry points, or leaking sensitive information.\n\n\n## Recommendation\nEnsure that debugging features are not enabled in production builds, such as by guarding calls to `WebView.setWebContentsDebuggingEnabled(true)` by a flag that is only enabled in debug builds.\n\n\n## Example\nIn the first (bad) example, WebView debugging is always enabled. whereas the GOOD case only enables it if the `android:debuggable` attribute is set to `true`.\n\n\n```java\n// BAD - debugging is always enabled \nWebView.setWebContentsDebuggingEnabled(true);\n\n// GOOD - debugging is only enabled when this is a debug build, as indicated by the debuggable flag being set.\nif (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE)) {\n    WebView.setWebContentsDebuggingEnabled(true);\n}\n```\n\n## References\n* Android Developers: [setWebContentsDebuggingEnabled](https://developer.android.com/reference/android/webkit/WebView.html#setWebContentsDebuggingEnabled(boolean)).\n* Android Developers: [Remote debugging WebViews](https://developer.chrome.com/docs/devtools/remote-debugging/webviews/).\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"},"properties":{"tags":["security","external/cwe/cwe-489"],"description":"Enabling Webview debugging in production builds can expose entry points or leak sensitive information.","id":"java/android/webview-debugging-enabled","kind":"path-problem","name":"Android Webview debugging enabled","precision":"high","problem.severity":"warning","security-severity":"7.2"}},{"id":"java/android/debuggable-attribute-enabled","name":"java/android/debuggable-attribute-enabled","shortDescription":{"text":"Android debuggable attribute enabled"},"fullDescription":{"text":"An enabled debugger can allow for entry points in the application or reveal sensitive information."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Android debuggable attribute enabled\nThe Android manifest file defines configuration settings for Android applications. In this file, the `android:debuggable` attribute of the `application` element can be used to define whether or not the application can be debugged. When set to `true`, this attribute will allow the application to be debugged even when running on a device in user mode.\n\nWhen a debugger is enabled, it could allow for entry points in the application or reveal sensitive information. As a result, `android:debuggable` should only be enabled during development and should be disabled in production builds.\n\n\n## Recommendation\nIn Android applications, either set the `android:debuggable` attribute to `false`, or do not include it in the manifest. The default value, when not included, is `false`.\n\n\n## Example\nIn the example below, the `android:debuggable` attribute is set to `true`.\n\n\n```xml\n<manifest ... >\n    <!-- BAD: 'android:debuggable' set to 'true' -->\n    <application\n        android:debuggable=\"true\">\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\nThe corrected version sets the `android:debuggable` attribute to `false`.\n\n\n```xml\n<manifest ... >\n    <!-- GOOD: 'android:debuggable' set to 'false' -->\n    <application\n        android:debuggable=\"false\">\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\n\n## References\n* Android Developers: [App Manifest Overview](https://developer.android.com/guide/topics/manifest/manifest-intro).\n* Android Developers: [The android:debuggable attribute](https://developer.android.com/guide/topics/manifest/application-element#debug).\n* Android Developers: [Enable debugging](https://developer.android.com/studio/debug#enable-debug).\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n","markdown":"# Android debuggable attribute enabled\nThe Android manifest file defines configuration settings for Android applications. In this file, the `android:debuggable` attribute of the `application` element can be used to define whether or not the application can be debugged. When set to `true`, this attribute will allow the application to be debugged even when running on a device in user mode.\n\nWhen a debugger is enabled, it could allow for entry points in the application or reveal sensitive information. As a result, `android:debuggable` should only be enabled during development and should be disabled in production builds.\n\n\n## Recommendation\nIn Android applications, either set the `android:debuggable` attribute to `false`, or do not include it in the manifest. The default value, when not included, is `false`.\n\n\n## Example\nIn the example below, the `android:debuggable` attribute is set to `true`.\n\n\n```xml\n<manifest ... >\n    <!-- BAD: 'android:debuggable' set to 'true' -->\n    <application\n        android:debuggable=\"true\">\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\nThe corrected version sets the `android:debuggable` attribute to `false`.\n\n\n```xml\n<manifest ... >\n    <!-- GOOD: 'android:debuggable' set to 'false' -->\n    <application\n        android:debuggable=\"false\">\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\n\n## References\n* Android Developers: [App Manifest Overview](https://developer.android.com/guide/topics/manifest/manifest-intro).\n* Android Developers: [The android:debuggable attribute](https://developer.android.com/guide/topics/manifest/application-element#debug).\n* Android Developers: [Enable debugging](https://developer.android.com/studio/debug#enable-debug).\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"},"properties":{"tags":["security","external/cwe/cwe-489"],"description":"An enabled debugger can allow for entry points in the application or reveal sensitive information.","id":"java/android/debuggable-attribute-enabled","kind":"problem","name":"Android debuggable attribute enabled","precision":"very-high","problem.severity":"warning","security-severity":"7.2"}},{"id":"java/android/insecure-local-authentication","name":"java/android/insecure-local-authentication","shortDescription":{"text":"Insecure local authentication"},"fullDescription":{"text":"Local authentication that does not make use of a `CryptoObject` can be bypassed."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Insecure local authentication\nBiometric local authentication such as fingerprint recognition can be used to protect sensitive data or actions within an application. However, if this authentication does not use a `KeyStore`-backed key, it can be bypassed by a privileged malicious application, or by an attacker with physical access using application hooking tools such as Frida.\n\n\n## Recommendation\nGenerate a secure key in the Android `KeyStore`. Ensure that the `onAuthenticationSuccess` callback for a biometric prompt uses it in a way that is required for the sensitive parts of the application to function, such as by using it to decrypt sensitive data or credentials.\n\n\n## Example\nIn the following (bad) case, no `CryptoObject` is required for the biometric prompt to grant access, so it can be bypassed.\n\n\n```java\nbiometricPrompt.authenticate(\n    cancellationSignal,\n    executor,\n    new BiometricPrompt.AuthenticationCallback {\n        @Override\n        // BAD: This authentication callback does not make use of a `CryptoObject` from the `result`.\n        public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {\n            grantAccess()\n        }\n    }\n)\n```\nIn the following (good) case, a secret key is generated in the Android `KeyStore`. The application requires this secret key for access, using it to decrypt data.\n\n\n```java\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n\n\nprivate SecretKey getSecretKey() {\n    KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n    keyStore.load(null);\n    return ((SecretKey)keyStore.getKey(\"MySecretKey\", null));\n}\n\nprivate Cipher getCipher() {\n    return Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + \"/\"\n            + KeyProperties.BLOCK_MODE_CBC + \"/\"\n            + KeyProperties.ENCRYPTION_PADDING_PKCS7);\n}\n\npublic prompt(byte[] encryptedData) {\n    Cipher cipher = getCipher();\n    SecretKey secretKey = getSecretKey();\n    cipher.init(Cipher.DECRYPT_MODE, secretKey);\n\n    biometricPrompt.authenticate(\n        new BiometricPrompt.CryptoObject(cipher),\n        cancellationSignal,\n        executor,\n        new BiometricPrompt.AuthenticationCallback() {\n            @Override\n            // GOOD: This authentication callback uses the result to decrypt some data.\n            public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {\n                Cipher cipher = result.getCryptoObject().getCipher();\n                byte[] decryptedData = cipher.doFinal(encryptedData);\n                grantAccessWithData(decryptedData);\n            }\n        }\n    );\n}\n```\n\n## References\n* OWASP Mobile Application Security: [Android Local Authentication](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)\n* OWASP Mobile Application Security: [Testing Biometric Authentication](https://mas.owasp.org/MASTG/tests/android/MASVS-AUTH/MASTG-TEST-0018/)\n* WithSecure: [How Secure is your Android Keystore Authentication?](https://labs.withsecure.com/publications/how-secure-is-your-android-keystore-authentication)\n* Android Developers: [Biometric Authentication](https://developer.android.com/training/sign-in/biometric-auth)\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n","markdown":"# Insecure local authentication\nBiometric local authentication such as fingerprint recognition can be used to protect sensitive data or actions within an application. However, if this authentication does not use a `KeyStore`-backed key, it can be bypassed by a privileged malicious application, or by an attacker with physical access using application hooking tools such as Frida.\n\n\n## Recommendation\nGenerate a secure key in the Android `KeyStore`. Ensure that the `onAuthenticationSuccess` callback for a biometric prompt uses it in a way that is required for the sensitive parts of the application to function, such as by using it to decrypt sensitive data or credentials.\n\n\n## Example\nIn the following (bad) case, no `CryptoObject` is required for the biometric prompt to grant access, so it can be bypassed.\n\n\n```java\nbiometricPrompt.authenticate(\n    cancellationSignal,\n    executor,\n    new BiometricPrompt.AuthenticationCallback {\n        @Override\n        // BAD: This authentication callback does not make use of a `CryptoObject` from the `result`.\n        public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {\n            grantAccess()\n        }\n    }\n)\n```\nIn the following (good) case, a secret key is generated in the Android `KeyStore`. The application requires this secret key for access, using it to decrypt data.\n\n\n```java\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n\n\nprivate SecretKey getSecretKey() {\n    KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n    keyStore.load(null);\n    return ((SecretKey)keyStore.getKey(\"MySecretKey\", null));\n}\n\nprivate Cipher getCipher() {\n    return Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + \"/\"\n            + KeyProperties.BLOCK_MODE_CBC + \"/\"\n            + KeyProperties.ENCRYPTION_PADDING_PKCS7);\n}\n\npublic prompt(byte[] encryptedData) {\n    Cipher cipher = getCipher();\n    SecretKey secretKey = getSecretKey();\n    cipher.init(Cipher.DECRYPT_MODE, secretKey);\n\n    biometricPrompt.authenticate(\n        new BiometricPrompt.CryptoObject(cipher),\n        cancellationSignal,\n        executor,\n        new BiometricPrompt.AuthenticationCallback() {\n            @Override\n            // GOOD: This authentication callback uses the result to decrypt some data.\n            public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {\n                Cipher cipher = result.getCryptoObject().getCipher();\n                byte[] decryptedData = cipher.doFinal(encryptedData);\n                grantAccessWithData(decryptedData);\n            }\n        }\n    );\n}\n```\n\n## References\n* OWASP Mobile Application Security: [Android Local Authentication](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)\n* OWASP Mobile Application Security: [Testing Biometric Authentication](https://mas.owasp.org/MASTG/tests/android/MASVS-AUTH/MASTG-TEST-0018/)\n* WithSecure: [How Secure is your Android Keystore Authentication?](https://labs.withsecure.com/publications/how-secure-is-your-android-keystore-authentication)\n* Android Developers: [Biometric Authentication](https://developer.android.com/training/sign-in/biometric-auth)\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n"},"properties":{"tags":["security","external/cwe/cwe-287"],"description":"Local authentication that does not make use of a `CryptoObject` can be bypassed.","id":"java/android/insecure-local-authentication","kind":"problem","name":"Insecure local authentication","precision":"high","problem.severity":"warning","security-severity":"4.4"}},{"id":"java/predictable-seed","name":"java/predictable-seed","shortDescription":{"text":"Use of a predictable seed in a secure random number generator"},"fullDescription":{"text":"Using a predictable seed in a pseudo-random number generator can lead to predictability of the numbers generated by it."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Use of a predictable seed in a secure random number generator\nUsing a predictable seed in a pseudo-random number generator can lead to predictability of the numbers generated by it.\n\n\n## Recommendation\nIf the predictability of the pseudo-random number generator does not matter then consider using the faster `Random` class from `java.util`. If it is important that the pseudo-random number generator produces completely unpredictable values then either let the generator securely seed itself by not specifying a seed or specify a randomly generated, unpredictable seed.\n\n\n## Example\nIn the first example shown here, a constant value is used as a seed. Depending on the implementation of ` SecureRandom`, this could lead to the same random number being generated each time the code is executed.\n\nIn the second example shown here, the system time is used as a seed. Depending on the implementation of ` SecureRandom`, if an attacker knows what time the code was run, they could predict the generated random number.\n\nIn the third example shown here, the random number generator is allowed to generate its own seed, which it will do in a secure way.\n\n\n```java\nSecureRandom prng = new SecureRandom();\nint randomData = 0;\n\n// BAD: Using a constant value as a seed for a random number generator means all numbers it generates are predictable.\nprng.setSeed(12345L);\nrandomData = prng.next(32);\n\n// BAD: System.currentTimeMillis() returns the system time which is predictable.\nprng.setSeed(System.currentTimeMillis());\nrandomData = prng.next(32);\n\n// GOOD: SecureRandom implementations seed themselves securely by default.\nprng = new SecureRandom();\nrandomData = prng.next(32);\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).\n* Common Weakness Enumeration: [CWE-337](https://cwe.mitre.org/data/definitions/337.html).\n","markdown":"# Use of a predictable seed in a secure random number generator\nUsing a predictable seed in a pseudo-random number generator can lead to predictability of the numbers generated by it.\n\n\n## Recommendation\nIf the predictability of the pseudo-random number generator does not matter then consider using the faster `Random` class from `java.util`. If it is important that the pseudo-random number generator produces completely unpredictable values then either let the generator securely seed itself by not specifying a seed or specify a randomly generated, unpredictable seed.\n\n\n## Example\nIn the first example shown here, a constant value is used as a seed. Depending on the implementation of ` SecureRandom`, this could lead to the same random number being generated each time the code is executed.\n\nIn the second example shown here, the system time is used as a seed. Depending on the implementation of ` SecureRandom`, if an attacker knows what time the code was run, they could predict the generated random number.\n\nIn the third example shown here, the random number generator is allowed to generate its own seed, which it will do in a secure way.\n\n\n```java\nSecureRandom prng = new SecureRandom();\nint randomData = 0;\n\n// BAD: Using a constant value as a seed for a random number generator means all numbers it generates are predictable.\nprng.setSeed(12345L);\nrandomData = prng.next(32);\n\n// BAD: System.currentTimeMillis() returns the system time which is predictable.\nprng.setSeed(System.currentTimeMillis());\nrandomData = prng.next(32);\n\n// GOOD: SecureRandom implementations seed themselves securely by default.\nprng = new SecureRandom();\nrandomData = prng.next(32);\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).\n* Common Weakness Enumeration: [CWE-337](https://cwe.mitre.org/data/definitions/337.html).\n"},"properties":{"tags":["security","external/cwe/cwe-335","external/cwe/cwe-337"],"description":"Using a predictable seed in a pseudo-random number generator can lead to predictability of the numbers generated by it.","id":"java/predictable-seed","kind":"problem","name":"Use of a predictable seed in a secure random number generator","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"java/xxe","name":"java/xxe","shortDescription":{"text":"Resolving XML external entity in user-controlled data"},"fullDescription":{"text":"Parsing user-controlled XML documents and allowing expansion of external entity references may lead to disclosure of confidential data or denial of service."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Resolving XML external entity in user-controlled data\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial of service, or server side request forgery. Even when the result of parsing is not returned to the user, out-of-band data retrieval techniques may allow attackers to steal sensitive data. Denial of services can also be carried out in this situation.\n\nThere are many XML parsers for Java, and most of them are vulnerable to XXE because their default settings enable parsing of external entities. This query currently identifies vulnerable XML parsing from the following parsers: `javax.xml.parsers.DocumentBuilder`, `javax.xml.stream.XMLStreamReader`, `org.jdom.input.SAXBuilder`/`org.jdom2.input.SAXBuilder`, `javax.xml.parsers.SAXParser`,`org.dom4j.io.SAXReader`, `org.xml.sax.XMLReader`, `javax.xml.transform.sax.SAXSource`, `javax.xml.transform.TransformerFactory`, `javax.xml.transform.sax.SAXTransformerFactory`, `javax.xml.validation.SchemaFactory`, `javax.xml.bind.Unmarshaller` and `javax.xml.xpath.XPathExpression`.\n\n\n## Recommendation\nThe best way to prevent XXE attacks is to disable the parsing of any Document Type Declarations (DTDs) in untrusted data. If this is not possible you should disable the parsing of external general entities and external parameter entities. This improves security but the code will still be at risk of denial of service and server side request forgery attacks. Protection against denial of service attacks may also be implemented by setting entity expansion limits, which is done by default in recent JDK and JRE implementations. We recommend visiting OWASP's [XML Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java), finding the specific XML parser, and applying the mitigation listed there. Other mitigations might be sufficient in some cases, but manual verification will be needed, as the query will continue to flag the parser as potentially dangerous.\n\n\n## Example\nThe following example calls `parse` on a `DocumentBuilder` that is not safely configured on untrusted data, and is therefore inherently unsafe.\n\n\n```java\npublic void parse(Socket sock) throws Exception {\n  DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n  DocumentBuilder builder = factory.newDocumentBuilder();\n  builder.parse(sock.getInputStream()); //unsafe\n}\n\n```\nIn this example, the `DocumentBuilder` is created with DTD disabled, securing it against XXE attack.\n\n\n```java\npublic void disableDTDParse(Socket sock) throws Exception {\n  DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n  factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n  DocumentBuilder builder = factory.newDocumentBuilder();\n  builder.parse(sock.getInputStream()); //safe\n}\n\n```\n\n## References\n* OWASP vulnerability description: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* OWASP guidance on parsing xml files: [XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java).\n* Paper by Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/)\n* Out-of-band data retrieval: Timur Yunusov &amp; Alexey Osipov, Black hat EU 2013: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Denial of service attack (Billion laughs): [Billion Laughs.](https://en.wikipedia.org/wiki/Billion_laughs)\n* The Java Tutorials: [Processing Limit Definitions.](https://docs.oracle.com/javase/tutorial/jaxp/limits/limits.html)\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n","markdown":"# Resolving XML external entity in user-controlled data\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial of service, or server side request forgery. Even when the result of parsing is not returned to the user, out-of-band data retrieval techniques may allow attackers to steal sensitive data. Denial of services can also be carried out in this situation.\n\nThere are many XML parsers for Java, and most of them are vulnerable to XXE because their default settings enable parsing of external entities. This query currently identifies vulnerable XML parsing from the following parsers: `javax.xml.parsers.DocumentBuilder`, `javax.xml.stream.XMLStreamReader`, `org.jdom.input.SAXBuilder`/`org.jdom2.input.SAXBuilder`, `javax.xml.parsers.SAXParser`,`org.dom4j.io.SAXReader`, `org.xml.sax.XMLReader`, `javax.xml.transform.sax.SAXSource`, `javax.xml.transform.TransformerFactory`, `javax.xml.transform.sax.SAXTransformerFactory`, `javax.xml.validation.SchemaFactory`, `javax.xml.bind.Unmarshaller` and `javax.xml.xpath.XPathExpression`.\n\n\n## Recommendation\nThe best way to prevent XXE attacks is to disable the parsing of any Document Type Declarations (DTDs) in untrusted data. If this is not possible you should disable the parsing of external general entities and external parameter entities. This improves security but the code will still be at risk of denial of service and server side request forgery attacks. Protection against denial of service attacks may also be implemented by setting entity expansion limits, which is done by default in recent JDK and JRE implementations. We recommend visiting OWASP's [XML Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java), finding the specific XML parser, and applying the mitigation listed there. Other mitigations might be sufficient in some cases, but manual verification will be needed, as the query will continue to flag the parser as potentially dangerous.\n\n\n## Example\nThe following example calls `parse` on a `DocumentBuilder` that is not safely configured on untrusted data, and is therefore inherently unsafe.\n\n\n```java\npublic void parse(Socket sock) throws Exception {\n  DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n  DocumentBuilder builder = factory.newDocumentBuilder();\n  builder.parse(sock.getInputStream()); //unsafe\n}\n\n```\nIn this example, the `DocumentBuilder` is created with DTD disabled, securing it against XXE attack.\n\n\n```java\npublic void disableDTDParse(Socket sock) throws Exception {\n  DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n  factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n  DocumentBuilder builder = factory.newDocumentBuilder();\n  builder.parse(sock.getInputStream()); //safe\n}\n\n```\n\n## References\n* OWASP vulnerability description: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* OWASP guidance on parsing xml files: [XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java).\n* Paper by Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/)\n* Out-of-band data retrieval: Timur Yunusov &amp; Alexey Osipov, Black hat EU 2013: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Denial of service attack (Billion laughs): [Billion Laughs.](https://en.wikipedia.org/wiki/Billion_laughs)\n* The Java Tutorials: [Processing Limit Definitions.](https://docs.oracle.com/javase/tutorial/jaxp/limits/limits.html)\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n"},"properties":{"tags":["security","external/cwe/cwe-611","external/cwe/cwe-776","external/cwe/cwe-827"],"description":"Parsing user-controlled XML documents and allowing expansion of external entity\n references may lead to disclosure of confidential data or denial of service.","id":"java/xxe","kind":"path-problem","name":"Resolving XML external entity in user-controlled data","precision":"high","problem.severity":"error","security-severity":"9.1"}},{"id":"java/android/implicitly-exported-component","name":"java/android/implicitly-exported-component","shortDescription":{"text":"Implicitly exported Android component"},"fullDescription":{"text":"Android components with an '<intent-filter>' and no 'android:exported' attribute are implicitly exported, which can allow for improper access to the components themselves and to their data."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Implicitly exported Android component\nThe Android manifest file defines configuration settings for Android applications. In this file, components can be declared with intent filters which specify what the components can do and what types of intents the components can respond to. If the `android:exported` attribute is omitted from the component when an intent filter is included, then the component will be implicitly exported.\n\nAn implicitly exported component could allow for improper access to the component and its data.\n\n\n## Recommendation\nExplicitly set the `android:exported` attribute for every component or use permissions to limit access to the component.\n\n\n## Example\nIn the example below, the `android:exported` attribute is omitted when an intent filter is used.\n\n\n```xml\n<manifest ... >\n    <application ...\n        <!-- BAD: this component is implicitly exported -->\n        <activity>\n            android:name=\".Activity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n\n```\nA corrected version sets the `android:exported` attribute to `false`.\n\n\n```xml\n<manifest ... >\n    <application ...\n        <!-- GOOD: this component is not exported due to 'android:exported' explicitly set to 'false'-->\n        <activity>\n            android:name=\".Activity\">\n            android:exported=\"false\"\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n\n```\n\n## References\n* Android Developers: [App Manifest Overview](https://developer.android.com/guide/topics/manifest/manifest-intro).\n* Android Developers: [The &lt;intent-filter&gt; element](https://developer.android.com/guide/topics/manifest/intent-filter-element).\n* Android Developers: [The android:exported attribute](https://developer.android.com/guide/topics/manifest/activity-element#exported).\n* Android Developers: [The android:permission attribute](https://developer.android.com/guide/topics/manifest/activity-element#prmsn).\n* Android Developers: [Safer component exporting](https://developer.android.com/about/versions/12/behavior-changes-12#exported).\n* Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n","markdown":"# Implicitly exported Android component\nThe Android manifest file defines configuration settings for Android applications. In this file, components can be declared with intent filters which specify what the components can do and what types of intents the components can respond to. If the `android:exported` attribute is omitted from the component when an intent filter is included, then the component will be implicitly exported.\n\nAn implicitly exported component could allow for improper access to the component and its data.\n\n\n## Recommendation\nExplicitly set the `android:exported` attribute for every component or use permissions to limit access to the component.\n\n\n## Example\nIn the example below, the `android:exported` attribute is omitted when an intent filter is used.\n\n\n```xml\n<manifest ... >\n    <application ...\n        <!-- BAD: this component is implicitly exported -->\n        <activity>\n            android:name=\".Activity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n\n```\nA corrected version sets the `android:exported` attribute to `false`.\n\n\n```xml\n<manifest ... >\n    <application ...\n        <!-- GOOD: this component is not exported due to 'android:exported' explicitly set to 'false'-->\n        <activity>\n            android:name=\".Activity\">\n            android:exported=\"false\"\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n\n```\n\n## References\n* Android Developers: [App Manifest Overview](https://developer.android.com/guide/topics/manifest/manifest-intro).\n* Android Developers: [The &lt;intent-filter&gt; element](https://developer.android.com/guide/topics/manifest/intent-filter-element).\n* Android Developers: [The android:exported attribute](https://developer.android.com/guide/topics/manifest/activity-element#exported).\n* Android Developers: [The android:permission attribute](https://developer.android.com/guide/topics/manifest/activity-element#prmsn).\n* Android Developers: [Safer component exporting](https://developer.android.com/about/versions/12/behavior-changes-12#exported).\n* Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n"},"properties":{"tags":["security","external/cwe/cwe-926"],"description":"Android components with an '<intent-filter>' and no 'android:exported' attribute are implicitly exported, which can allow for improper access to the components themselves and to their data.","id":"java/android/implicitly-exported-component","kind":"problem","name":"Implicitly exported Android component","precision":"high","problem.severity":"warning","security-severity":"8.2"}},{"id":"java/android/intent-uri-permission-manipulation","name":"java/android/intent-uri-permission-manipulation","shortDescription":{"text":"Intent URI permission manipulation"},"fullDescription":{"text":"Returning an externally provided Intent via 'setResult' may allow a malicious application to access arbitrary content providers of the vulnerable application."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Intent URI permission manipulation\nWhen an Android component expects a result from an Activity, `startActivityForResult` can be used. The started Activity can then use `setResult` to return the appropriate data to the calling component.\n\nIf an Activity obtains the incoming, user-provided Intent and directly returns it via `setResult` without any checks, the application may be unintentionally giving arbitrary access to its content providers, even if they are not exported, as long as they are configured with the attribute `android:grantUriPermissions=\"true\"`. This happens because the attacker adds the appropriate URI permission flags to the provided Intent, which take effect once the Intent is reflected back.\n\n\n## Recommendation\nAvoid returning user-provided or untrusted Intents via `setResult`. Use a new Intent instead.\n\nIf it is required to use the received Intent, make sure that it does not contain URI permission flags, either by checking them with `Intent.getFlags` or removing them with `Intent.removeFlags`.\n\n\n## Example\nThe following sample contains three examples. In the first example, a user-provided Intent is obtained and directly returned back with `setResult`, which is dangerous. In the second example, a new Intent is created to safely return the desired data. The third example shows how the obtained Intent can be sanitized by removing dangerous flags before using it to return data to the calling component.\n\n\n```java\npublic class IntentUriPermissionManipulation extends Activity {\n\n    // BAD: the user-provided Intent is returned as-is\n    public void dangerous() {\n        Intent intent = getIntent();\n        intent.putExtra(\"result\", \"resultData\");\n        setResult(intent);\n    }\n\n    // GOOD: a new Intent is created and returned\n    public void safe() {\n        Intent intent = new Intent();\n        intent.putExtra(\"result\", \"resultData\");\n        setResult(intent);\n    }\n\n    // GOOD: the user-provided Intent is sanitized before being returned\n    public void sanitized() {\n        Intent intent = getIntent();\n        intent.putExtra(\"result\", \"resultData\");\n        intent.removeFlags(\n                Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\n        setResult(intent);\n    }\n}\n\n```\n\n## References\n* Google Help: [Remediation for Intent Redirection Vulnerability](https://support.google.com/faqs/answer/9267555?hl=en).\n* Common Weakness Enumeration: [CWE-266](https://cwe.mitre.org/data/definitions/266.html).\n* Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n","markdown":"# Intent URI permission manipulation\nWhen an Android component expects a result from an Activity, `startActivityForResult` can be used. The started Activity can then use `setResult` to return the appropriate data to the calling component.\n\nIf an Activity obtains the incoming, user-provided Intent and directly returns it via `setResult` without any checks, the application may be unintentionally giving arbitrary access to its content providers, even if they are not exported, as long as they are configured with the attribute `android:grantUriPermissions=\"true\"`. This happens because the attacker adds the appropriate URI permission flags to the provided Intent, which take effect once the Intent is reflected back.\n\n\n## Recommendation\nAvoid returning user-provided or untrusted Intents via `setResult`. Use a new Intent instead.\n\nIf it is required to use the received Intent, make sure that it does not contain URI permission flags, either by checking them with `Intent.getFlags` or removing them with `Intent.removeFlags`.\n\n\n## Example\nThe following sample contains three examples. In the first example, a user-provided Intent is obtained and directly returned back with `setResult`, which is dangerous. In the second example, a new Intent is created to safely return the desired data. The third example shows how the obtained Intent can be sanitized by removing dangerous flags before using it to return data to the calling component.\n\n\n```java\npublic class IntentUriPermissionManipulation extends Activity {\n\n    // BAD: the user-provided Intent is returned as-is\n    public void dangerous() {\n        Intent intent = getIntent();\n        intent.putExtra(\"result\", \"resultData\");\n        setResult(intent);\n    }\n\n    // GOOD: a new Intent is created and returned\n    public void safe() {\n        Intent intent = new Intent();\n        intent.putExtra(\"result\", \"resultData\");\n        setResult(intent);\n    }\n\n    // GOOD: the user-provided Intent is sanitized before being returned\n    public void sanitized() {\n        Intent intent = getIntent();\n        intent.putExtra(\"result\", \"resultData\");\n        intent.removeFlags(\n                Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\n        setResult(intent);\n    }\n}\n\n```\n\n## References\n* Google Help: [Remediation for Intent Redirection Vulnerability](https://support.google.com/faqs/answer/9267555?hl=en).\n* Common Weakness Enumeration: [CWE-266](https://cwe.mitre.org/data/definitions/266.html).\n* Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n"},"properties":{"tags":["security","external/cwe/cwe-266","external/cwe/cwe-926"],"description":"Returning an externally provided Intent via 'setResult' may allow a malicious\n              application to access arbitrary content providers of the vulnerable application.","id":"java/android/intent-uri-permission-manipulation","kind":"path-problem","name":"Intent URI permission manipulation","precision":"high","problem.severity":"error","security-severity":"7.8"}},{"id":"java/improper-webview-certificate-validation","name":"java/improper-webview-certificate-validation","shortDescription":{"text":"Android `WebView` that accepts all certificates"},"fullDescription":{"text":"Trusting all certificates allows an attacker to perform a machine-in-the-middle attack."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Android `WebView` that accepts all certificates\nIf the `onReceivedSslError` method of an Android `WebViewClient` always calls `proceed` on the given `SslErrorHandler`, it trusts any certificate. This allows an attacker to perform a machine-in-the-middle attack against the application, therefore breaking any security Transport Layer Security (TLS) gives.\n\nAn attack might look like this:\n\n1. The vulnerable application connects to `https://example.com`.\n1. The attacker intercepts this connection and presents a valid, self-signed certificate for `https://example.com`.\n1. The vulnerable application calls the `onReceivedSslError` method to check whether it should trust the certificate.\n1. The `onReceivedSslError` method of your `WebViewClient` calls `SslErrorHandler.proceed`.\n1. The vulnerable application accepts the certificate and proceeds with the connection since your `WevViewClient` trusted it by proceeding.\n1. The attacker can now read the data your application sends to `https://example.com` and/or alter its replies while the application thinks the connection is secure.\n\n## Recommendation\nDo not use a call `SslerrorHandler.proceed` unconditionally. If you have to use a self-signed certificate, only accept that certificate, not all certificates.\n\n\n## Example\nIn the first (bad) example, the `WebViewClient` trusts all certificates by always calling `SslErrorHandler.proceed`. In the second (good) example, only certificates signed by a certain public key are accepted.\n\n\n```java\nclass Bad extends WebViewClient {\n    // BAD: All certificates are trusted.\n    public void onReceivedSslError (WebView view, SslErrorHandler handler, SslError error) { // $hasResult\n        handler.proceed(); \n    }\n}\n\nclass Good extends WebViewClient {\n    PublicKey myPubKey = ...;\n\n    // GOOD: Only certificates signed by a certain public key are trusted.\n    public void onReceivedSslError (WebView view, SslErrorHandler handler, SslError error) { // $hasResult\n        try {\n            X509Certificate cert = error.getCertificate().getX509Certificate();\n            cert.verify(this.myPubKey);\n            handler.proceed();\n        }\n        catch (CertificateException|NoSuchAlgorithmException|InvalidKeyException|NoSuchProviderException|SignatureException e) {\n            handler.cancel();\n        }\n    }    \n}\n```\n\n## References\n* [WebViewClient.onReceivedSslError documentation](https://developer.android.com/reference/android/webkit/WebViewClient?hl=en#onReceivedSslError(android.webkit.WebView,%20android.webkit.SslErrorHandler,%20android.net.http.SslError)).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n","markdown":"# Android `WebView` that accepts all certificates\nIf the `onReceivedSslError` method of an Android `WebViewClient` always calls `proceed` on the given `SslErrorHandler`, it trusts any certificate. This allows an attacker to perform a machine-in-the-middle attack against the application, therefore breaking any security Transport Layer Security (TLS) gives.\n\nAn attack might look like this:\n\n1. The vulnerable application connects to `https://example.com`.\n1. The attacker intercepts this connection and presents a valid, self-signed certificate for `https://example.com`.\n1. The vulnerable application calls the `onReceivedSslError` method to check whether it should trust the certificate.\n1. The `onReceivedSslError` method of your `WebViewClient` calls `SslErrorHandler.proceed`.\n1. The vulnerable application accepts the certificate and proceeds with the connection since your `WevViewClient` trusted it by proceeding.\n1. The attacker can now read the data your application sends to `https://example.com` and/or alter its replies while the application thinks the connection is secure.\n\n## Recommendation\nDo not use a call `SslerrorHandler.proceed` unconditionally. If you have to use a self-signed certificate, only accept that certificate, not all certificates.\n\n\n## Example\nIn the first (bad) example, the `WebViewClient` trusts all certificates by always calling `SslErrorHandler.proceed`. In the second (good) example, only certificates signed by a certain public key are accepted.\n\n\n```java\nclass Bad extends WebViewClient {\n    // BAD: All certificates are trusted.\n    public void onReceivedSslError (WebView view, SslErrorHandler handler, SslError error) { // $hasResult\n        handler.proceed(); \n    }\n}\n\nclass Good extends WebViewClient {\n    PublicKey myPubKey = ...;\n\n    // GOOD: Only certificates signed by a certain public key are trusted.\n    public void onReceivedSslError (WebView view, SslErrorHandler handler, SslError error) { // $hasResult\n        try {\n            X509Certificate cert = error.getCertificate().getX509Certificate();\n            cert.verify(this.myPubKey);\n            handler.proceed();\n        }\n        catch (CertificateException|NoSuchAlgorithmException|InvalidKeyException|NoSuchProviderException|SignatureException e) {\n            handler.cancel();\n        }\n    }    \n}\n```\n\n## References\n* [WebViewClient.onReceivedSslError documentation](https://developer.android.com/reference/android/webkit/WebViewClient?hl=en#onReceivedSslError(android.webkit.WebView,%20android.webkit.SslErrorHandler,%20android.net.http.SslError)).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"},"properties":{"tags":["security","external/cwe/cwe-295"],"description":"Trusting all certificates allows an attacker to perform a machine-in-the-middle attack.","id":"java/improper-webview-certificate-validation","kind":"problem","name":"Android `WebView` that accepts all certificates","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"java/insecure-trustmanager","name":"java/insecure-trustmanager","shortDescription":{"text":"`TrustManager` that accepts all certificates"},"fullDescription":{"text":"Trusting all certificates allows an attacker to perform a machine-in-the-middle attack."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# `TrustManager` that accepts all certificates\nIf the `checkServerTrusted` method of a `TrustManager` never throws a `CertificateException`, it trusts every certificate. This allows an attacker to perform a machine-in-the-middle attack against the application, therefore breaking any security Transport Layer Security (TLS) gives.\n\nAn attack might look like this:\n\n1. The vulnerable program connects to `https://example.com`.\n1. The attacker intercepts this connection and presents a valid, self-signed certificate for `https://example.com`.\n1. The vulnerable program calls the `checkServerTrusted` method to check whether it should trust the certificate.\n1. The `checkServerTrusted` method of your `TrustManager` does not throw a `CertificateException`.\n1. The vulnerable program accepts the certificate and proceeds with the connection since your `TrustManager` implicitly trusted it by not throwing an exception.\n1. The attacker can now read the data your program sends to `https://example.com` and/or alter its replies while the program thinks the connection is secure.\n\n## Recommendation\nDo not use a custom `TrustManager` that trusts any certificate. If you have to use a self-signed certificate, don't trust every certificate, but instead only trust this specific certificate. See below for an example of how to do this.\n\n\n## Example\nIn the first (bad) example, the `TrustManager` never throws a `CertificateException` and therefore implicitly trusts any certificate. This allows an attacker to perform a machine-in-the-middle attack. In the second (good) example, the self-signed certificate that should be trusted is loaded into a `KeyStore`. This explicitly defines the certificate as trusted and there is no need to create a custom `TrustManager`.\n\n\n```java\npublic static void main(String[] args) throws Exception {\n    {\n        class InsecureTrustManager implements X509TrustManager {\n            @Override\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                // BAD: Does not verify the certificate chain, allowing any certificate.\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\n            }\n        }\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        TrustManager[] trustManager = new TrustManager[] { new InsecureTrustManager() };\n        context.init(null, trustManager, null);\n    }\n    {\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        File certificateFile = new File(\"path/to/self-signed-certificate\");\n        // Create a `KeyStore` with default type\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        // `keyStore` is initially empty\n        keyStore.load(null, null);\n        X509Certificate generatedCertificate;\n        try (InputStream cert = new FileInputStream(certificateFile)) {\n            generatedCertificate = (X509Certificate) CertificateFactory.getInstance(\"X509\")\n                    .generateCertificate(cert);\n        }\n        // Add the self-signed certificate to the key store\n        keyStore.setCertificateEntry(certificateFile.getName(), generatedCertificate);\n        // Get default `TrustManagerFactory`\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        // Use it with our key store that trusts our self-signed certificate\n        tmf.init(keyStore);\n        TrustManager[] trustManagers = tmf.getTrustManagers();\n        context.init(null, trustManagers, null);\n        // GOOD, we are not using a custom `TrustManager` but instead have\n        // added the self-signed certificate we want to trust to the key\n        // store. Note, the `trustManagers` will **only** trust this one\n        // certificate.\n        \n        URL url = new URL(\"https://self-signed.badssl.com/\");\n        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n        conn.setSSLSocketFactory(context.getSocketFactory());\n    }\n}\n\n```\n\n## References\n* Android Developers: [Security with HTTPS and SSL](https://developer.android.com/training/articles/security-ssl).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n","markdown":"# `TrustManager` that accepts all certificates\nIf the `checkServerTrusted` method of a `TrustManager` never throws a `CertificateException`, it trusts every certificate. This allows an attacker to perform a machine-in-the-middle attack against the application, therefore breaking any security Transport Layer Security (TLS) gives.\n\nAn attack might look like this:\n\n1. The vulnerable program connects to `https://example.com`.\n1. The attacker intercepts this connection and presents a valid, self-signed certificate for `https://example.com`.\n1. The vulnerable program calls the `checkServerTrusted` method to check whether it should trust the certificate.\n1. The `checkServerTrusted` method of your `TrustManager` does not throw a `CertificateException`.\n1. The vulnerable program accepts the certificate and proceeds with the connection since your `TrustManager` implicitly trusted it by not throwing an exception.\n1. The attacker can now read the data your program sends to `https://example.com` and/or alter its replies while the program thinks the connection is secure.\n\n## Recommendation\nDo not use a custom `TrustManager` that trusts any certificate. If you have to use a self-signed certificate, don't trust every certificate, but instead only trust this specific certificate. See below for an example of how to do this.\n\n\n## Example\nIn the first (bad) example, the `TrustManager` never throws a `CertificateException` and therefore implicitly trusts any certificate. This allows an attacker to perform a machine-in-the-middle attack. In the second (good) example, the self-signed certificate that should be trusted is loaded into a `KeyStore`. This explicitly defines the certificate as trusted and there is no need to create a custom `TrustManager`.\n\n\n```java\npublic static void main(String[] args) throws Exception {\n    {\n        class InsecureTrustManager implements X509TrustManager {\n            @Override\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                // BAD: Does not verify the certificate chain, allowing any certificate.\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\n            }\n        }\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        TrustManager[] trustManager = new TrustManager[] { new InsecureTrustManager() };\n        context.init(null, trustManager, null);\n    }\n    {\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        File certificateFile = new File(\"path/to/self-signed-certificate\");\n        // Create a `KeyStore` with default type\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        // `keyStore` is initially empty\n        keyStore.load(null, null);\n        X509Certificate generatedCertificate;\n        try (InputStream cert = new FileInputStream(certificateFile)) {\n            generatedCertificate = (X509Certificate) CertificateFactory.getInstance(\"X509\")\n                    .generateCertificate(cert);\n        }\n        // Add the self-signed certificate to the key store\n        keyStore.setCertificateEntry(certificateFile.getName(), generatedCertificate);\n        // Get default `TrustManagerFactory`\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        // Use it with our key store that trusts our self-signed certificate\n        tmf.init(keyStore);\n        TrustManager[] trustManagers = tmf.getTrustManagers();\n        context.init(null, trustManagers, null);\n        // GOOD, we are not using a custom `TrustManager` but instead have\n        // added the self-signed certificate we want to trust to the key\n        // store. Note, the `trustManagers` will **only** trust this one\n        // certificate.\n        \n        URL url = new URL(\"https://self-signed.badssl.com/\");\n        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n        conn.setSSLSocketFactory(context.getSocketFactory());\n    }\n}\n\n```\n\n## References\n* Android Developers: [Security with HTTPS and SSL](https://developer.android.com/training/articles/security-ssl).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"},"properties":{"tags":["security","external/cwe/cwe-295"],"description":"Trusting all certificates allows an attacker to perform a machine-in-the-middle attack.","id":"java/insecure-trustmanager","kind":"path-problem","name":"`TrustManager` that accepts all certificates","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"java/ssrf","name":"java/ssrf","shortDescription":{"text":"Server-side request forgery"},"fullDescription":{"text":"Making web requests based on unvalidated user-input may cause the server to communicate with malicious servers."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Server-side request forgery\nDirectly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the server may be tricked into making a request and interacting with an attacker-controlled server.\n\n\n## Recommendation\nTo guard against SSRF attacks, you should avoid putting user-provided input directly into a request URL. Instead, maintain a list of authorized URLs on the server; then choose from that list based on the input provided. Alternatively, ensure requests constructed from user input are limited to a particular host or more restrictive URL prefix.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly to form a new request without validating the input, which facilitates SSRF attacks. It also shows how to remedy the problem by validating the user input against a known fixed string.\n\n\n```java\nimport java.net.http.HttpClient;\n\npublic class SSRF extends HttpServlet {\n\tprivate static final String VALID_URI = \"http://lgtm.com\";\n\tprivate HttpClient client = HttpClient.newHttpClient();\n\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows ServletException, IOException {\n\t\tURI uri = new URI(request.getParameter(\"uri\"));\n\t\t// BAD: a request parameter is incorporated without validation into a Http request\n\t\tHttpRequest r = HttpRequest.newBuilder(uri).build();\n\t\tclient.send(r, null);\n\n\t\t// GOOD: the request parameter is validated against a known fixed string\n\t\tif (VALID_URI.equals(request.getParameter(\"uri\"))) {\n\t\t\tHttpRequest r2 = HttpRequest.newBuilder(uri).build();\n\t\t\tclient.send(r2, null);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* [OWASP SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n","markdown":"# Server-side request forgery\nDirectly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the server may be tricked into making a request and interacting with an attacker-controlled server.\n\n\n## Recommendation\nTo guard against SSRF attacks, you should avoid putting user-provided input directly into a request URL. Instead, maintain a list of authorized URLs on the server; then choose from that list based on the input provided. Alternatively, ensure requests constructed from user input are limited to a particular host or more restrictive URL prefix.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly to form a new request without validating the input, which facilitates SSRF attacks. It also shows how to remedy the problem by validating the user input against a known fixed string.\n\n\n```java\nimport java.net.http.HttpClient;\n\npublic class SSRF extends HttpServlet {\n\tprivate static final String VALID_URI = \"http://lgtm.com\";\n\tprivate HttpClient client = HttpClient.newHttpClient();\n\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows ServletException, IOException {\n\t\tURI uri = new URI(request.getParameter(\"uri\"));\n\t\t// BAD: a request parameter is incorporated without validation into a Http request\n\t\tHttpRequest r = HttpRequest.newBuilder(uri).build();\n\t\tclient.send(r, null);\n\n\t\t// GOOD: the request parameter is validated against a known fixed string\n\t\tif (VALID_URI.equals(request.getParameter(\"uri\"))) {\n\t\t\tHttpRequest r2 = HttpRequest.newBuilder(uri).build();\n\t\t\tclient.send(r2, null);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* [OWASP SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"},"properties":{"tags":["security","external/cwe/cwe-918"],"description":"Making web requests based on unvalidated user-input\n              may cause the server to communicate with malicious servers.","id":"java/ssrf","kind":"path-problem","name":"Server-side request forgery","precision":"high","problem.severity":"error","security-severity":"9.1"}},{"id":"java/overly-large-range","name":"java/overly-large-range","shortDescription":{"text":"Overly permissive regular expression range"},"fullDescription":{"text":"Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```java\n\nimport java.util.regex.Pattern\npublic class Tester {\n    public static boolean is_valid_hex_color(String color) {\n        return Pattern.matches(\"#[0-9a-fA-f]{6}\", color);\n    }\n}\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```javascript\n\nimport java.util.regex.Pattern\npublic class Tester {\n    public static boolean is_valid_hex_color(String color) {\n        return Pattern.matches(\"#[0-9a-fA-F]{6}\", color);\n    }\n}\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n","markdown":"# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```java\n\nimport java.util.regex.Pattern\npublic class Tester {\n    public static boolean is_valid_hex_color(String color) {\n        return Pattern.matches(\"#[0-9a-fA-f]{6}\", color);\n    }\n}\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```javascript\n\nimport java.util.regex.Pattern\npublic class Tester {\n    public static boolean is_valid_hex_color(String color) {\n        return Pattern.matches(\"#[0-9a-fA-F]{6}\", color);\n    }\n}\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"},"properties":{"tags":["correctness","security","external/cwe/cwe-020"],"description":"Overly permissive regular expression ranges match a wider range of characters than intended.\n              This may allow an attacker to bypass a filter or sanitizer.","id":"java/overly-large-range","kind":"problem","name":"Overly permissive regular expression range","precision":"high","problem.severity":"warning","security-severity":"5.0"}},{"id":"java/insecure-cookie","name":"java/insecure-cookie","shortDescription":{"text":"Failure to use secure cookies"},"fullDescription":{"text":"Insecure cookies may be sent in cleartext, which makes them vulnerable to interception."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Failure to use secure cookies\nFailing to set the 'secure' flag on a cookie can cause it to be sent in cleartext. This makes it easier for an attacker to intercept.\n\n\n## Recommendation\nAlways use `setSecure` to set the 'secure' flag on a cookie before adding it to an `HttpServletResponse`.\n\n\n## Example\nThis example shows two ways of adding a cookie to an `HttpServletResponse`. The first way leaves out the setting of the 'secure' flag; the second way includes the setting of the flag.\n\n\n```java\npublic static void test(HttpServletRequest request, HttpServletResponse response) {\n\t{\n\t\tCookie cookie = new Cookie(\"secret\", \"fakesecret\");\n\t\t\n\t\t// BAD: 'secure' flag not set\n\t\tresponse.addCookie(cookie);\n\t}\n\n\t{\n\t\tCookie cookie = new Cookie(\"secret\", \"fakesecret\");\n\t\t\n\t\t// GOOD: set 'secure' flag\n\t\tcookie.setSecure(true);\n\t\tresponse.addCookie(cookie);\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* Java Platform, Enterprise Edition (Java EE) 7, API Specification: [Class Cookie](https://docs.oracle.com/javaee/7/api/javax/servlet/http/Cookie.html).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n","markdown":"# Failure to use secure cookies\nFailing to set the 'secure' flag on a cookie can cause it to be sent in cleartext. This makes it easier for an attacker to intercept.\n\n\n## Recommendation\nAlways use `setSecure` to set the 'secure' flag on a cookie before adding it to an `HttpServletResponse`.\n\n\n## Example\nThis example shows two ways of adding a cookie to an `HttpServletResponse`. The first way leaves out the setting of the 'secure' flag; the second way includes the setting of the flag.\n\n\n```java\npublic static void test(HttpServletRequest request, HttpServletResponse response) {\n\t{\n\t\tCookie cookie = new Cookie(\"secret\", \"fakesecret\");\n\t\t\n\t\t// BAD: 'secure' flag not set\n\t\tresponse.addCookie(cookie);\n\t}\n\n\t{\n\t\tCookie cookie = new Cookie(\"secret\", \"fakesecret\");\n\t\t\n\t\t// GOOD: set 'secure' flag\n\t\tcookie.setSecure(true);\n\t\tresponse.addCookie(cookie);\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* Java Platform, Enterprise Edition (Java EE) 7, API Specification: [Class Cookie](https://docs.oracle.com/javaee/7/api/javax/servlet/http/Cookie.html).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n"},"properties":{"tags":["security","external/cwe/cwe-614"],"description":"Insecure cookies may be sent in cleartext, which makes them vulnerable to\n              interception.","id":"java/insecure-cookie","kind":"problem","name":"Failure to use secure cookies","precision":"high","problem.severity":"error","security-severity":"5.0"}},{"id":"java/missing-jwt-signature-check","name":"java/missing-jwt-signature-check","shortDescription":{"text":"Missing JWT signature check"},"fullDescription":{"text":"Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Missing JWT signature check\nA JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.\n\nTherefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.\n\n\n## Recommendation\nAlways verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.\n\n\n## Example\nThe following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.\n\n\n```java\npublic void badJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(token); // BAD: Does not verify the signature\n}\n\npublic void badJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {\n                    @Override\n                    public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {\n                        return jwt;\n                    }\n                }); // BAD: The handler is called on an unverified JWT\n}\n\npublic void goodJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parseClaimsJws(token) // GOOD: Verify the signature\n                .getBody();\n}\n\npublic void goodJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {\n                    @Override\n                    public Jws<String> onPlaintextJws(Jws<String> jws) {\n                        return jws;\n                    }\n                }); // GOOD: The handler is called on a verified JWS\n}\n```\n\n## References\n* zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n","markdown":"# Missing JWT signature check\nA JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.\n\nTherefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.\n\n\n## Recommendation\nAlways verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.\n\n\n## Example\nThe following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.\n\n\n```java\npublic void badJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(token); // BAD: Does not verify the signature\n}\n\npublic void badJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {\n                    @Override\n                    public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {\n                        return jwt;\n                    }\n                }); // BAD: The handler is called on an unverified JWT\n}\n\npublic void goodJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parseClaimsJws(token) // GOOD: Verify the signature\n                .getBody();\n}\n\npublic void goodJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {\n                    @Override\n                    public Jws<String> onPlaintextJws(Jws<String> jws) {\n                        return jws;\n                    }\n                }); // GOOD: The handler is called on a verified JWS\n}\n```\n\n## References\n* zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n"},"properties":{"tags":["security","external/cwe/cwe-347"],"description":"Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.","id":"java/missing-jwt-signature-check","kind":"path-problem","name":"Missing JWT signature check","precision":"high","problem.severity":"error","security-severity":"7.8"}},{"id":"java/xss","name":"java/xss","shortDescription":{"text":"Cross-site scripting"},"fullDescription":{"text":"Writing user input directly to a web page allows for a cross-site scripting vulnerability."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to a web page, without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the reference.\n\n\n## Example\nThe following example shows the `page` parameter being written directly to the page, leaving the website vulnerable to cross-site scripting.\n\n\n```java\npublic class XSS extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\t// BAD: a request parameter is written directly to the Servlet response stream\n\t\tresponse.getWriter().print(\n\t\t\t\t\"The page \\\"\" + request.getParameter(\"page\") + \"\\\" was not found.\");\n\n\t}\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n","markdown":"# Cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to a web page, without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the reference.\n\n\n## Example\nThe following example shows the `page` parameter being written directly to the page, leaving the website vulnerable to cross-site scripting.\n\n\n```java\npublic class XSS extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\t// BAD: a request parameter is written directly to the Servlet response stream\n\t\tresponse.getWriter().print(\n\t\t\t\t\"The page \\\"\" + request.getParameter(\"page\") + \"\\\" was not found.\");\n\n\t}\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"},"properties":{"tags":["security","external/cwe/cwe-079"],"description":"Writing user input directly to a web page\n              allows for a cross-site scripting vulnerability.","id":"java/xss","kind":"path-problem","name":"Cross-site scripting","precision":"high","problem.severity":"error","security-severity":"6.1"}},{"id":"java/sql-injection","name":"java/sql-injection","shortDescription":{"text":"Query built from user-controlled sources"},"fullDescription":{"text":"Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n","markdown":"# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n"},"properties":{"tags":["security","external/cwe/cwe-089","external/cwe/cwe-564"],"description":"Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of\n              malicious code by the user.","id":"java/sql-injection","kind":"path-problem","name":"Query built from user-controlled sources","precision":"high","problem.severity":"error","security-severity":"8.8"}},{"id":"java/android/intent-redirection","name":"java/android/intent-redirection","shortDescription":{"text":"Android Intent redirection"},"fullDescription":{"text":"Starting Android components with user-provided Intents can provide access to internal components of the application, increasing the attack surface and potentially causing unintended effects."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Android Intent redirection\nAn exported Android component that obtains a user-provided Intent and uses it to launch another component can be exploited to obtain access to private, unexported components of the same app or to launch other apps' components on behalf of the victim app.\n\n\n## Recommendation\nDo not export components that start other components from a user-provided Intent. They can be made private by setting the `android:exported` property to `false` in the app's Android Manifest.\n\nIf this is not possible, restrict either which apps can send Intents to the affected component, or which components can be started from it.\n\n\n## Example\nThe following snippet contains three examples. In the first example, an arbitrary component can be started from the externally provided `forward_intent` Intent. In the second example, the destination component of the Intent is first checked to make sure it is safe. In the third example, the component that created the Intent is first checked to make sure it comes from a trusted origin.\n\n\n```java\n// BAD: A user-provided Intent is used to launch an arbitrary component\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"forward_intent\");\nstartActivity(forwardIntent);\n\n// GOOD: The destination component is checked before launching it\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"forward_intent\");\nComponentName destinationComponent = forwardIntent.resolveActivity(getPackageManager());\nif (destinationComponent.getPackageName().equals(\"safe.package\") && \n    destinationComponent.getClassName().equals(\"SafeClass\")) {\n    startActivity(forwardIntent);\n}\n\n// GOOD: The component that sent the Intent is checked before launching the destination component\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"forward_intent\");\nComponentName originComponent = getCallingActivity();\nif (originComponent.getPackageName().equals(\"trusted.package\") && originComponent.getClassName().equals(\"TrustedClass\")) {\n    startActivity(forwardIntent);\n}\n\n```\n\n## References\n* Google: [Remediation for Intent Redirection Vulnerability](https://support.google.com/faqs/answer/9267555?hl=en).\n* OWASP Mobile Security Testing Guide: [Intents](https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05a-platform-overview#intents).\n* Android Developers: [The android:exported attribute](https://developer.android.com/guide/topics/manifest/activity-element#exported).\n* Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n* Common Weakness Enumeration: [CWE-940](https://cwe.mitre.org/data/definitions/940.html).\n","markdown":"# Android Intent redirection\nAn exported Android component that obtains a user-provided Intent and uses it to launch another component can be exploited to obtain access to private, unexported components of the same app or to launch other apps' components on behalf of the victim app.\n\n\n## Recommendation\nDo not export components that start other components from a user-provided Intent. They can be made private by setting the `android:exported` property to `false` in the app's Android Manifest.\n\nIf this is not possible, restrict either which apps can send Intents to the affected component, or which components can be started from it.\n\n\n## Example\nThe following snippet contains three examples. In the first example, an arbitrary component can be started from the externally provided `forward_intent` Intent. In the second example, the destination component of the Intent is first checked to make sure it is safe. In the third example, the component that created the Intent is first checked to make sure it comes from a trusted origin.\n\n\n```java\n// BAD: A user-provided Intent is used to launch an arbitrary component\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"forward_intent\");\nstartActivity(forwardIntent);\n\n// GOOD: The destination component is checked before launching it\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"forward_intent\");\nComponentName destinationComponent = forwardIntent.resolveActivity(getPackageManager());\nif (destinationComponent.getPackageName().equals(\"safe.package\") && \n    destinationComponent.getClassName().equals(\"SafeClass\")) {\n    startActivity(forwardIntent);\n}\n\n// GOOD: The component that sent the Intent is checked before launching the destination component\nIntent forwardIntent = (Intent) getIntent().getParcelableExtra(\"forward_intent\");\nComponentName originComponent = getCallingActivity();\nif (originComponent.getPackageName().equals(\"trusted.package\") && originComponent.getClassName().equals(\"TrustedClass\")) {\n    startActivity(forwardIntent);\n}\n\n```\n\n## References\n* Google: [Remediation for Intent Redirection Vulnerability](https://support.google.com/faqs/answer/9267555?hl=en).\n* OWASP Mobile Security Testing Guide: [Intents](https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05a-platform-overview#intents).\n* Android Developers: [The android:exported attribute](https://developer.android.com/guide/topics/manifest/activity-element#exported).\n* Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n* Common Weakness Enumeration: [CWE-940](https://cwe.mitre.org/data/definitions/940.html).\n"},"properties":{"tags":["security","external/cwe/cwe-926","external/cwe/cwe-940"],"description":"Starting Android components with user-provided Intents\n              can provide access to internal components of the application,\n              increasing the attack surface and potentially causing unintended effects.","id":"java/android/intent-redirection","kind":"path-problem","name":"Android Intent redirection","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"java/world-writable-file-read","name":"java/world-writable-file-read","shortDescription":{"text":"Reading from a world writable file"},"fullDescription":{"text":"Reading from a file which is set as world writable is dangerous because the file may be modified or removed by external actors."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Reading from a world writable file\nReading from a world-writable file is dangerous on a multi-user system because other users may be able to affect program execution by modifying or deleting the file.\n\n\n## Recommendation\nDo not make files explicitly world writable unless the file is intended to be written by multiple users on a multi-user system. In many cases, the file may only need to be writable for the current user.\n\nFor some file systems, there may be alternatives to setting the file to be world writable. For example, POSIX file systems support \"groups\" which may be used to ensure that only subset of all the users can write to the file. Access Control Lists (ACLs) are available for many operating system and file system combinations, and can provide fine-grained read and write support without resorting to world writable permissions.\n\n\n## Example\nIn the following example, we are loading some configuration parameters from a file:\n\n```java\n\nprivate void readConfig(File configFile) {\n  if (!configFile.exists()) {\n    // Create an empty config file\n    configFile.createNewFile();\n    // Make the file writable for all\n    configFile.setWritable(true, false);\n  }\n  // Now read the config\n  loadConfig(configFile);\n}\n\n```\nIf the configuration file does not yet exist, an empty file is created. Creating an empty file can simplify the later code and is a convenience for the user. However, by setting the file to be world writable, we allow any user on the system to modify the configuration, not just the current user. If there may be untrusted users on the system, this is potentially dangerous.\n\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [FIO01-J. Create files with appropriate access permissions](https://wiki.sei.cmu.edu/confluence/display/java/FIO01-J.+Create+files+with+appropriate+access+permissions).\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n","markdown":"# Reading from a world writable file\nReading from a world-writable file is dangerous on a multi-user system because other users may be able to affect program execution by modifying or deleting the file.\n\n\n## Recommendation\nDo not make files explicitly world writable unless the file is intended to be written by multiple users on a multi-user system. In many cases, the file may only need to be writable for the current user.\n\nFor some file systems, there may be alternatives to setting the file to be world writable. For example, POSIX file systems support \"groups\" which may be used to ensure that only subset of all the users can write to the file. Access Control Lists (ACLs) are available for many operating system and file system combinations, and can provide fine-grained read and write support without resorting to world writable permissions.\n\n\n## Example\nIn the following example, we are loading some configuration parameters from a file:\n\n```java\n\nprivate void readConfig(File configFile) {\n  if (!configFile.exists()) {\n    // Create an empty config file\n    configFile.createNewFile();\n    // Make the file writable for all\n    configFile.setWritable(true, false);\n  }\n  // Now read the config\n  loadConfig(configFile);\n}\n\n```\nIf the configuration file does not yet exist, an empty file is created. Creating an empty file can simplify the later code and is a convenience for the user. However, by setting the file to be world writable, we allow any user on the system to modify the configuration, not just the current user. If there may be untrusted users on the system, this is potentially dangerous.\n\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [FIO01-J. Create files with appropriate access permissions](https://wiki.sei.cmu.edu/confluence/display/java/FIO01-J.+Create+files+with+appropriate+access+permissions).\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n"},"properties":{"tags":["security","external/cwe/cwe-732"],"description":"Reading from a file which is set as world writable is dangerous because\n              the file may be modified or removed by external actors.","id":"java/world-writable-file-read","kind":"problem","name":"Reading from a world writable file","precision":"high","problem.severity":"error","security-severity":"7.8"}},{"id":"java/ldap-injection","name":"java/ldap-injection","shortDescription":{"text":"LDAP query built from user-controlled sources"},"fullDescription":{"text":"Building an LDAP query from user-controlled sources is vulnerable to insertion of malicious LDAP code by the user."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# LDAP query built from user-controlled sources\nIf an LDAP query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious LDAP queries.\n\n\n## Recommendation\nIf user input must be included in an LDAP query, it should be escaped to avoid a malicious user providing special characters that change the meaning of the query. If possible build the LDAP query using framework helper methods, for example from Spring's `LdapQueryBuilder` and `LdapNameBuilder`, instead of string concatenation. Alternatively, escape user input using an appropriate LDAP encoding method, for example: `encodeForLDAP` or `encodeForDN` from OWASP ESAPI, `LdapEncoder.filterEncode` or `LdapEncoder.nameEncode` from Spring LDAP, or `Filter.encodeValue` from UnboundID library.\n\n\n## Example\nIn the following examples, the code accepts an \"organization name\" and a \"username\" from the user, which it uses to query LDAP.\n\nThe first example concatenates the unvalidated and unencoded user input directly into both the DN (Distinguished Name) and the search filter used for the LDAP query. A malicious user could provide special characters to change the meaning of these queries, and search for a completely different set of values. The LDAP query is executed using Java JNDI API.\n\nThe second example uses the OWASP ESAPI library to encode the user values before they are included in the DN and search filters. This ensures the meaning of the query cannot be changed by a malicious user.\n\n\n```java\nimport javax.naming.directory.DirContext;\nimport org.owasp.esapi.Encoder;\nimport org.owasp.esapi.reference.DefaultEncoder;\n\npublic void ldapQueryBad(HttpServletRequest request, DirContext ctx) throws NamingException {\n  String organizationName = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"username\");\n\n  // BAD: User input used in DN (Distinguished Name) without encoding\n  String dn = \"OU=People,O=\" + organizationName;\n\n  // BAD: User input used in search filter without encoding\n  String filter = \"username=\" + userName;\n\n  ctx.search(dn, filter, new SearchControls());\n}\n\npublic void ldapQueryGood(HttpServletRequest request, DirContext ctx) throws NamingException {\n  String organizationName = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"username\");\n\n  // ESAPI encoder\n  Encoder encoder = DefaultEncoder.getInstance();\n\n  // GOOD: Organization name is encoded before being used in DN\n  String safeOrganizationName = encoder.encodeForDN(organizationName);\n  String safeDn = \"OU=People,O=\" + safeOrganizationName;\n\n  // GOOD: User input is encoded before being used in search filter\n  String safeUsername = encoder.encodeForLDAP(username);\n  String safeFilter = \"username=\" + safeUsername;\n  \n  ctx.search(safeDn, safeFilter, new SearchControls());\n}\n```\nThe third example uses Spring `LdapQueryBuilder` to build an LDAP query. In addition to simplifying the building of complex search parameters, it also provides proper escaping of any unsafe characters in search filters. The DN is built using `LdapNameBuilder`, which also provides proper escaping.\n\n\n```java\nimport static org.springframework.ldap.query.LdapQueryBuilder.query;\nimport org.springframework.ldap.support.LdapNameBuilder;\n\npublic void ldapQueryGood(@RequestParam String organizationName, @RequestParam String username) {\n  // GOOD: Organization name is encoded before being used in DN\n  String safeDn = LdapNameBuilder.newInstance()\n    .add(\"O\", organizationName)\n    .add(\"OU=People\")\n    .build().toString();\n\n  // GOOD: User input is encoded before being used in search filter\n  LdapQuery query = query()\n    .base(safeDn)\n    .where(\"username\").is(username);\n\n  ldapTemplate.search(query, new AttributeCheckAttributesMapper());\n}\n```\nThe fourth example uses `UnboundID` classes, `Filter` and `DN`, to construct a safe filter and base DN.\n\n\n```java\nimport com.unboundid.ldap.sdk.LDAPConnection;\nimport com.unboundid.ldap.sdk.DN;\nimport com.unboundid.ldap.sdk.RDN;\nimport com.unboundid.ldap.sdk.Filter;\n\npublic void ldapQueryGood(HttpServletRequest request, LDAPConnection c) {\n  String organizationName = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"username\");\n\n  // GOOD: Organization name is encoded before being used in DN\n  DN safeDn = new DN(new RDN(\"OU\", \"People\"), new RDN(\"O\", organizationName));\n\n  // GOOD: User input is encoded before being used in search filter\n  Filter safeFilter = Filter.createEqualityFilter(\"username\", username);\n  \n  c.search(safeDn.toString(), SearchScope.ONE, safeFilter);\n}\n```\nThe fifth example shows how to build a safe filter and DN using the Apache LDAP API.\n\n\n```java\nimport org.apache.directory.ldap.client.api.LdapConnection;\nimport org.apache.directory.api.ldap.model.name.Dn;\nimport org.apache.directory.api.ldap.model.name.Rdn;\nimport org.apache.directory.api.ldap.model.message.SearchRequest;\nimport org.apache.directory.api.ldap.model.message.SearchRequestImpl;\nimport static org.apache.directory.ldap.client.api.search.FilterBuilder.equal;\n\npublic void ldapQueryGood(HttpServletRequest request, LdapConnection c) {\n  String organizationName = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"username\");\n\n  // GOOD: Organization name is encoded before being used in DN\n  Dn safeDn = new Dn(new Rdn(\"OU\", \"People\"), new Rdn(\"O\", organizationName));\n\n  // GOOD: User input is encoded before being used in search filter\n  String safeFilter = equal(\"username\", username);\n  \n  SearchRequest searchRequest = new SearchRequestImpl();\n  searchRequest.setBase(safeDn);\n  searchRequest.setFilter(safeFilter);\n  c.search(searchRequest);\n}\n```\n\n## References\n* OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).\n* OWASP ESAPI: [OWASP ESAPI](https://owasp.org/www-project-enterprise-security-api/).\n* Spring LdapQueryBuilder doc: [LdapQueryBuilder](https://docs.spring.io/spring-ldap/docs/current/apidocs/org/springframework/ldap/query/LdapQueryBuilder.html).\n* Spring LdapNameBuilder doc: [LdapNameBuilder](https://docs.spring.io/spring-ldap/docs/current/apidocs/org/springframework/ldap/support/LdapNameBuilder.html).\n* UnboundID: [Understanding and Defending Against LDAP Injection Attacks](https://ldap.com/2018/05/04/understanding-and-defending-against-ldap-injection-attacks/).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n","markdown":"# LDAP query built from user-controlled sources\nIf an LDAP query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious LDAP queries.\n\n\n## Recommendation\nIf user input must be included in an LDAP query, it should be escaped to avoid a malicious user providing special characters that change the meaning of the query. If possible build the LDAP query using framework helper methods, for example from Spring's `LdapQueryBuilder` and `LdapNameBuilder`, instead of string concatenation. Alternatively, escape user input using an appropriate LDAP encoding method, for example: `encodeForLDAP` or `encodeForDN` from OWASP ESAPI, `LdapEncoder.filterEncode` or `LdapEncoder.nameEncode` from Spring LDAP, or `Filter.encodeValue` from UnboundID library.\n\n\n## Example\nIn the following examples, the code accepts an \"organization name\" and a \"username\" from the user, which it uses to query LDAP.\n\nThe first example concatenates the unvalidated and unencoded user input directly into both the DN (Distinguished Name) and the search filter used for the LDAP query. A malicious user could provide special characters to change the meaning of these queries, and search for a completely different set of values. The LDAP query is executed using Java JNDI API.\n\nThe second example uses the OWASP ESAPI library to encode the user values before they are included in the DN and search filters. This ensures the meaning of the query cannot be changed by a malicious user.\n\n\n```java\nimport javax.naming.directory.DirContext;\nimport org.owasp.esapi.Encoder;\nimport org.owasp.esapi.reference.DefaultEncoder;\n\npublic void ldapQueryBad(HttpServletRequest request, DirContext ctx) throws NamingException {\n  String organizationName = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"username\");\n\n  // BAD: User input used in DN (Distinguished Name) without encoding\n  String dn = \"OU=People,O=\" + organizationName;\n\n  // BAD: User input used in search filter without encoding\n  String filter = \"username=\" + userName;\n\n  ctx.search(dn, filter, new SearchControls());\n}\n\npublic void ldapQueryGood(HttpServletRequest request, DirContext ctx) throws NamingException {\n  String organizationName = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"username\");\n\n  // ESAPI encoder\n  Encoder encoder = DefaultEncoder.getInstance();\n\n  // GOOD: Organization name is encoded before being used in DN\n  String safeOrganizationName = encoder.encodeForDN(organizationName);\n  String safeDn = \"OU=People,O=\" + safeOrganizationName;\n\n  // GOOD: User input is encoded before being used in search filter\n  String safeUsername = encoder.encodeForLDAP(username);\n  String safeFilter = \"username=\" + safeUsername;\n  \n  ctx.search(safeDn, safeFilter, new SearchControls());\n}\n```\nThe third example uses Spring `LdapQueryBuilder` to build an LDAP query. In addition to simplifying the building of complex search parameters, it also provides proper escaping of any unsafe characters in search filters. The DN is built using `LdapNameBuilder`, which also provides proper escaping.\n\n\n```java\nimport static org.springframework.ldap.query.LdapQueryBuilder.query;\nimport org.springframework.ldap.support.LdapNameBuilder;\n\npublic void ldapQueryGood(@RequestParam String organizationName, @RequestParam String username) {\n  // GOOD: Organization name is encoded before being used in DN\n  String safeDn = LdapNameBuilder.newInstance()\n    .add(\"O\", organizationName)\n    .add(\"OU=People\")\n    .build().toString();\n\n  // GOOD: User input is encoded before being used in search filter\n  LdapQuery query = query()\n    .base(safeDn)\n    .where(\"username\").is(username);\n\n  ldapTemplate.search(query, new AttributeCheckAttributesMapper());\n}\n```\nThe fourth example uses `UnboundID` classes, `Filter` and `DN`, to construct a safe filter and base DN.\n\n\n```java\nimport com.unboundid.ldap.sdk.LDAPConnection;\nimport com.unboundid.ldap.sdk.DN;\nimport com.unboundid.ldap.sdk.RDN;\nimport com.unboundid.ldap.sdk.Filter;\n\npublic void ldapQueryGood(HttpServletRequest request, LDAPConnection c) {\n  String organizationName = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"username\");\n\n  // GOOD: Organization name is encoded before being used in DN\n  DN safeDn = new DN(new RDN(\"OU\", \"People\"), new RDN(\"O\", organizationName));\n\n  // GOOD: User input is encoded before being used in search filter\n  Filter safeFilter = Filter.createEqualityFilter(\"username\", username);\n  \n  c.search(safeDn.toString(), SearchScope.ONE, safeFilter);\n}\n```\nThe fifth example shows how to build a safe filter and DN using the Apache LDAP API.\n\n\n```java\nimport org.apache.directory.ldap.client.api.LdapConnection;\nimport org.apache.directory.api.ldap.model.name.Dn;\nimport org.apache.directory.api.ldap.model.name.Rdn;\nimport org.apache.directory.api.ldap.model.message.SearchRequest;\nimport org.apache.directory.api.ldap.model.message.SearchRequestImpl;\nimport static org.apache.directory.ldap.client.api.search.FilterBuilder.equal;\n\npublic void ldapQueryGood(HttpServletRequest request, LdapConnection c) {\n  String organizationName = request.getParameter(\"organization_name\");\n  String username = request.getParameter(\"username\");\n\n  // GOOD: Organization name is encoded before being used in DN\n  Dn safeDn = new Dn(new Rdn(\"OU\", \"People\"), new Rdn(\"O\", organizationName));\n\n  // GOOD: User input is encoded before being used in search filter\n  String safeFilter = equal(\"username\", username);\n  \n  SearchRequest searchRequest = new SearchRequestImpl();\n  searchRequest.setBase(safeDn);\n  searchRequest.setFilter(safeFilter);\n  c.search(searchRequest);\n}\n```\n\n## References\n* OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).\n* OWASP ESAPI: [OWASP ESAPI](https://owasp.org/www-project-enterprise-security-api/).\n* Spring LdapQueryBuilder doc: [LdapQueryBuilder](https://docs.spring.io/spring-ldap/docs/current/apidocs/org/springframework/ldap/query/LdapQueryBuilder.html).\n* Spring LdapNameBuilder doc: [LdapNameBuilder](https://docs.spring.io/spring-ldap/docs/current/apidocs/org/springframework/ldap/support/LdapNameBuilder.html).\n* UnboundID: [Understanding and Defending Against LDAP Injection Attacks](https://ldap.com/2018/05/04/understanding-and-defending-against-ldap-injection-attacks/).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n"},"properties":{"tags":["security","external/cwe/cwe-090"],"description":"Building an LDAP query from user-controlled sources is vulnerable to insertion of\n              malicious LDAP code by the user.","id":"java/ldap-injection","kind":"path-problem","name":"LDAP query built from user-controlled sources","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"java/maven/dependency-upon-bintray","name":"java/maven/dependency-upon-bintray","shortDescription":{"text":"Depending upon JCenter/Bintray as an artifact repository"},"fullDescription":{"text":"Using a deprecated artifact repository may eventually give attackers access for a supply chain attack."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Depending upon JCenter/Bintray as an artifact repository\n[Bintray and JCenter are shutting down on February 1st, 2022](https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/). Relying upon repositories that are deprecated or scheduled to be shutdown can have unintended consequences; for example, artifacts being resolved from a different artifact server or a total failure of the CI build.\n\nWhen artifact repositories are left unmaintained for a long period of time, vulnerabilities may emerge. Theoretically, this could allow attackers to inject malicious code into the artifacts that you are resolving and infect build artifacts that are being produced. This can be used by attackers to perform a [supply chain attack](https://en.wikipedia.org/wiki/Supply_chain_attack) against your project's users.\n\n\n## Recommendation\nAlways use the canonical repository for resolving your dependencies.\n\n\n## Example\nThe following example shows locations in a Maven POM file where artifact repository upload/download is configured. The use of Bintray in any of these locations is not advised.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.semmle</groupId>\n    <artifactId>parent</artifactId>\n    <version>1.0</version>\n    <packaging>pom</packaging>\n\n    <name>Bintray Usage</name>\n    <description>An example of using bintray to download and upload dependencies</description>\n\n    <distributionManagement>\n        <repository>\n            <id>jcenter</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use JCenter -->\n            <url>https://jcenter.bintray.com</url>\n        </repository>\n        <snapshotRepository>\n            <id>jcenter-snapshots</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use JCenter -->\n            <url>https://jcenter.bintray.com</url>\n        </snapshotRepository>\n    </distributionManagement>\n    <repositories>\n        <repository>\n            <id>jcenter</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use JCenter -->\n            <url>https://jcenter.bintray.com</url>\n        </repository>\n    </repositories>\n    <repositories>\n        <repository>\n            <id>jcenter</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use Bintray -->\n            <url>https://dl.bintray.com/groovy/maven</url>\n        </repository>\n    </repositories>\n    <pluginRepositories>\n        <pluginRepository>\n            <id>jcenter-plugins</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use JCenter -->\n            <url>https://jcenter.bintray.com</url>\n        </pluginRepository>\n    </pluginRepositories>\n</project>\n\n```\n\n## References\n* JFrog blog: [ Into the Sunset on May 1st: Bintray, JCenter, GoCenter, and ChartCenter ](https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/)\n* Common Weakness Enumeration: [CWE-1104](https://cwe.mitre.org/data/definitions/1104.html).\n","markdown":"# Depending upon JCenter/Bintray as an artifact repository\n[Bintray and JCenter are shutting down on February 1st, 2022](https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/). Relying upon repositories that are deprecated or scheduled to be shutdown can have unintended consequences; for example, artifacts being resolved from a different artifact server or a total failure of the CI build.\n\nWhen artifact repositories are left unmaintained for a long period of time, vulnerabilities may emerge. Theoretically, this could allow attackers to inject malicious code into the artifacts that you are resolving and infect build artifacts that are being produced. This can be used by attackers to perform a [supply chain attack](https://en.wikipedia.org/wiki/Supply_chain_attack) against your project's users.\n\n\n## Recommendation\nAlways use the canonical repository for resolving your dependencies.\n\n\n## Example\nThe following example shows locations in a Maven POM file where artifact repository upload/download is configured. The use of Bintray in any of these locations is not advised.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.semmle</groupId>\n    <artifactId>parent</artifactId>\n    <version>1.0</version>\n    <packaging>pom</packaging>\n\n    <name>Bintray Usage</name>\n    <description>An example of using bintray to download and upload dependencies</description>\n\n    <distributionManagement>\n        <repository>\n            <id>jcenter</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use JCenter -->\n            <url>https://jcenter.bintray.com</url>\n        </repository>\n        <snapshotRepository>\n            <id>jcenter-snapshots</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use JCenter -->\n            <url>https://jcenter.bintray.com</url>\n        </snapshotRepository>\n    </distributionManagement>\n    <repositories>\n        <repository>\n            <id>jcenter</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use JCenter -->\n            <url>https://jcenter.bintray.com</url>\n        </repository>\n    </repositories>\n    <repositories>\n        <repository>\n            <id>jcenter</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use Bintray -->\n            <url>https://dl.bintray.com/groovy/maven</url>\n        </repository>\n    </repositories>\n    <pluginRepositories>\n        <pluginRepository>\n            <id>jcenter-plugins</id>\n            <name>JCenter</name>\n            <!-- BAD! Don't use JCenter -->\n            <url>https://jcenter.bintray.com</url>\n        </pluginRepository>\n    </pluginRepositories>\n</project>\n\n```\n\n## References\n* JFrog blog: [ Into the Sunset on May 1st: Bintray, JCenter, GoCenter, and ChartCenter ](https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/)\n* Common Weakness Enumeration: [CWE-1104](https://cwe.mitre.org/data/definitions/1104.html).\n"},"properties":{"tags":["security","external/cwe/cwe-1104"],"description":"Using a deprecated artifact repository may eventually give attackers access for a supply chain attack.","id":"java/maven/dependency-upon-bintray","kind":"problem","name":"Depending upon JCenter/Bintray as an artifact repository","precision":"very-high","problem.severity":"error","security-severity":"6.5"}},{"id":"java/zipslip","name":"java/zipslip","shortDescription":{"text":"Arbitrary file access during archive extraction (\"Zip Slip\")"},"fullDescription":{"text":"Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Arbitrary file access during archive extraction (\"Zip Slip\")\nExtracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a zip file contains a file entry `..\\sneaky-file`, and the zip file is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a zip archive entry is to verify that the normalized full path of the output file starts with a prefix that matches the destination directory. Path normalization can be done with either `java.io.File.getCanonicalFile()` or `java.nio.file.Path.normalize()`. Prefix checking can be done with `String.startsWith(..)`, but it is better to use `java.nio.file.Path.startsWith(..)`, as the latter works on complete path segments.\n\nAnother alternative is to validate archive entries against a whitelist of expected files.\n\n\n## Example\nIn this example, a file path taken from a zip archive item entry is combined with a destination directory. The result is used as the destination file path without verifying that the result is within the destination directory. If provided with a zip file containing an archive path like `..\\sneaky-file`, then this file would be written outside the destination directory.\n\n\n```java\nvoid writeZipEntry(ZipEntry entry, File destinationDir) {\n    File file = new File(destinationDir, entry.getName());\n    FileOutputStream fos = new FileOutputStream(file); // BAD\n    // ... write entry to fos ...\n}\n\n```\nTo fix this vulnerability, we need to verify that the normalized `file` still has `destinationDir` as its prefix, and throw an exception if this is not the case.\n\n\n```java\nvoid writeZipEntry(ZipEntry entry, File destinationDir) {\n    File file = new File(destinationDir, entry.getName());\n    if (!file.toPath().normalize().startsWith(destinationDir.toPath()))\n        throw new Exception(\"Bad zip entry\");\n    FileOutputStream fos = new FileOutputStream(file); // OK\n    // ... write entry to fos ...\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n","markdown":"# Arbitrary file access during archive extraction (\"Zip Slip\")\nExtracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a zip file contains a file entry `..\\sneaky-file`, and the zip file is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a zip archive entry is to verify that the normalized full path of the output file starts with a prefix that matches the destination directory. Path normalization can be done with either `java.io.File.getCanonicalFile()` or `java.nio.file.Path.normalize()`. Prefix checking can be done with `String.startsWith(..)`, but it is better to use `java.nio.file.Path.startsWith(..)`, as the latter works on complete path segments.\n\nAnother alternative is to validate archive entries against a whitelist of expected files.\n\n\n## Example\nIn this example, a file path taken from a zip archive item entry is combined with a destination directory. The result is used as the destination file path without verifying that the result is within the destination directory. If provided with a zip file containing an archive path like `..\\sneaky-file`, then this file would be written outside the destination directory.\n\n\n```java\nvoid writeZipEntry(ZipEntry entry, File destinationDir) {\n    File file = new File(destinationDir, entry.getName());\n    FileOutputStream fos = new FileOutputStream(file); // BAD\n    // ... write entry to fos ...\n}\n\n```\nTo fix this vulnerability, we need to verify that the normalized `file` still has `destinationDir` as its prefix, and throw an exception if this is not the case.\n\n\n```java\nvoid writeZipEntry(ZipEntry entry, File destinationDir) {\n    File file = new File(destinationDir, entry.getName());\n    if (!file.toPath().normalize().startsWith(destinationDir.toPath()))\n        throw new Exception(\"Bad zip entry\");\n    FileOutputStream fos = new FileOutputStream(file); // OK\n    // ... write entry to fos ...\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"},"properties":{"tags":["security","external/cwe/cwe-022"],"description":"Extracting files from a malicious ZIP file, or similar type of archive, without\n              validating that the destination file path is within the destination directory\n              can allow an attacker to unexpectedly gain access to resources.","id":"java/zipslip","kind":"path-problem","name":"Arbitrary file access during archive extraction (\"Zip Slip\")","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"java/path-injection","name":"java/path-injection","shortDescription":{"text":"Uncontrolled data used in path expression"},"fullDescription":{"text":"Accessing paths influenced by users can allow an attacker to access unexpected resources."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n","markdown":"# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"},"properties":{"tags":["security","external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073"],"description":"Accessing paths influenced by users can allow an attacker to access unexpected resources.","id":"java/path-injection","kind":"path-problem","name":"Uncontrolled data used in path expression","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"java/groovy-injection","name":"java/groovy-injection","shortDescription":{"text":"Groovy Language injection"},"fullDescription":{"text":"Evaluation of a user-controlled Groovy script may lead to arbitrary code execution."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Groovy Language injection\nApache Groovy is a powerful, optionally typed and dynamic language, with static-typing and static compilation capabilities. It integrates smoothly with any Java program, and immediately delivers to your application powerful features, including scripting capabilities, Domain-Specific Language authoring, runtime and compile-time meta-programming and functional programming. If a Groovy script is built using attacker-controlled data, and then evaluated, then it may allow the attacker to achieve RCE.\n\n\n## Recommendation\nIt is generally recommended to avoid using untrusted input in a Groovy evaluation. If this is not possible, use a sandbox solution. Developers must also take care that Groovy compile-time metaprogramming can also lead to RCE: it is possible to achieve RCE by compiling a Groovy script (see the article \"Abusing Meta Programming for Unauthenticated RCE!\" linked below). Groovy's `SecureASTCustomizer` allows securing source code by controlling what code constructs are permitted. This is typically done when using Groovy for its scripting or domain specific language (DSL) features. The fundamental problem is that Groovy is a dynamic language, yet `SecureASTCustomizer` works by looking at Groovy AST statically. This makes it very easy for an attacker to bypass many of the intended checks (see \\[Groovy SecureASTCustomizer is harmful\\](https://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/)). Therefore, besides `SecureASTCustomizer`, runtime checks are also necessary before calling Groovy methods (see \\[Improved sandboxing of Groovy scripts\\](https://melix.github.io/blog/2015/03/sandboxing.html)). It is also possible to use a block-list method, excluding unwanted classes from being loaded by the JVM. This method is not always recommended, because block-lists can be bypassed by unexpected values.\n\n\n## Example\nThe following example uses untrusted data to evaluate a Groovy script.\n\n\n```java\npublic class GroovyInjection {\n    void injectionViaClassLoader(HttpServletRequest request) {    \n        String script = request.getParameter(\"script\");\n        final GroovyClassLoader classLoader = new GroovyClassLoader();\n        Class groovy = classLoader.parseClass(script);\n        GroovyObject groovyObj = (GroovyObject) groovy.newInstance();\n    }\n\n    void injectionViaEval(HttpServletRequest request) {\n        String script = request.getParameter(\"script\");\n        Eval.me(script);\n    }\n\n    void injectionViaGroovyShell(HttpServletRequest request) {\n        GroovyShell shell = new GroovyShell();\n        String script = request.getParameter(\"script\");\n        shell.evaluate(script);\n    }\n\n    void injectionViaGroovyShellGroovyCodeSource(HttpServletRequest request) {\n        GroovyShell shell = new GroovyShell();\n        String script = request.getParameter(\"script\");\n        GroovyCodeSource gcs = new GroovyCodeSource(script, \"test\", \"Test\");\n        shell.evaluate(gcs);\n    }\n}\n\n\n```\nThe following example uses classloader block-list approach to exclude loading dangerous classes.\n\n\n```java\npublic class SandboxGroovyClassLoader extends ClassLoader {\n    public SandboxGroovyClassLoader(ClassLoader parent) {\n        super(parent);\n    }\n\n    /* override `loadClass` here to prevent loading sensitive classes, such as `java.lang.Runtime`, `java.lang.ProcessBuilder`, `java.lang.System`, etc.  */\n    /* Note we must also block `groovy.transform.ASTTest`, `groovy.lang.GrabConfig` and `org.buildobjects.process.ProcBuilder` to prevent compile-time RCE. */\n\n    static void runWithSandboxGroovyClassLoader() throws Exception {\n        // GOOD: route all class-loading via sand-boxing classloader.\n        SandboxGroovyClassLoader classLoader = new GroovyClassLoader(new SandboxGroovyClassLoader());\n        \n        Class<?> scriptClass = classLoader.parseClass(untrusted.getQueryString());\n        Object scriptInstance = scriptClass.newInstance();\n        Object result = scriptClass.getDeclaredMethod(\"bar\", new Class[]{}).invoke(scriptInstance, new Object[]{});\n    }\n}\n```\n\n## References\n* Orange Tsai: [Abusing Meta Programming for Unauthenticated RCE!](https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html).\n* Cédric Champeau: [Improved sandboxing of Groovy scripts](https://melix.github.io/blog/2015/03/sandboxing.html).\n* Kohsuke Kawaguchi: [Groovy SecureASTCustomizer is harmful](https://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/).\n* Welk1n: [Groovy Injection payloads](https://github.com/welk1n/exploiting-groovy-in-Java/).\n* Charles Chan: [Secure Groovy Script Execution in a Sandbox](https://levelup.gitconnected.com/secure-groovy-script-execution-in-a-sandbox-ea39f80ee87/).\n* Eugene: [Scripting and sandboxing in a JVM environment](https://stringconcat.com/en/scripting-and-sandboxing/).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n","markdown":"# Groovy Language injection\nApache Groovy is a powerful, optionally typed and dynamic language, with static-typing and static compilation capabilities. It integrates smoothly with any Java program, and immediately delivers to your application powerful features, including scripting capabilities, Domain-Specific Language authoring, runtime and compile-time meta-programming and functional programming. If a Groovy script is built using attacker-controlled data, and then evaluated, then it may allow the attacker to achieve RCE.\n\n\n## Recommendation\nIt is generally recommended to avoid using untrusted input in a Groovy evaluation. If this is not possible, use a sandbox solution. Developers must also take care that Groovy compile-time metaprogramming can also lead to RCE: it is possible to achieve RCE by compiling a Groovy script (see the article \"Abusing Meta Programming for Unauthenticated RCE!\" linked below). Groovy's `SecureASTCustomizer` allows securing source code by controlling what code constructs are permitted. This is typically done when using Groovy for its scripting or domain specific language (DSL) features. The fundamental problem is that Groovy is a dynamic language, yet `SecureASTCustomizer` works by looking at Groovy AST statically. This makes it very easy for an attacker to bypass many of the intended checks (see \\[Groovy SecureASTCustomizer is harmful\\](https://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/)). Therefore, besides `SecureASTCustomizer`, runtime checks are also necessary before calling Groovy methods (see \\[Improved sandboxing of Groovy scripts\\](https://melix.github.io/blog/2015/03/sandboxing.html)). It is also possible to use a block-list method, excluding unwanted classes from being loaded by the JVM. This method is not always recommended, because block-lists can be bypassed by unexpected values.\n\n\n## Example\nThe following example uses untrusted data to evaluate a Groovy script.\n\n\n```java\npublic class GroovyInjection {\n    void injectionViaClassLoader(HttpServletRequest request) {    \n        String script = request.getParameter(\"script\");\n        final GroovyClassLoader classLoader = new GroovyClassLoader();\n        Class groovy = classLoader.parseClass(script);\n        GroovyObject groovyObj = (GroovyObject) groovy.newInstance();\n    }\n\n    void injectionViaEval(HttpServletRequest request) {\n        String script = request.getParameter(\"script\");\n        Eval.me(script);\n    }\n\n    void injectionViaGroovyShell(HttpServletRequest request) {\n        GroovyShell shell = new GroovyShell();\n        String script = request.getParameter(\"script\");\n        shell.evaluate(script);\n    }\n\n    void injectionViaGroovyShellGroovyCodeSource(HttpServletRequest request) {\n        GroovyShell shell = new GroovyShell();\n        String script = request.getParameter(\"script\");\n        GroovyCodeSource gcs = new GroovyCodeSource(script, \"test\", \"Test\");\n        shell.evaluate(gcs);\n    }\n}\n\n\n```\nThe following example uses classloader block-list approach to exclude loading dangerous classes.\n\n\n```java\npublic class SandboxGroovyClassLoader extends ClassLoader {\n    public SandboxGroovyClassLoader(ClassLoader parent) {\n        super(parent);\n    }\n\n    /* override `loadClass` here to prevent loading sensitive classes, such as `java.lang.Runtime`, `java.lang.ProcessBuilder`, `java.lang.System`, etc.  */\n    /* Note we must also block `groovy.transform.ASTTest`, `groovy.lang.GrabConfig` and `org.buildobjects.process.ProcBuilder` to prevent compile-time RCE. */\n\n    static void runWithSandboxGroovyClassLoader() throws Exception {\n        // GOOD: route all class-loading via sand-boxing classloader.\n        SandboxGroovyClassLoader classLoader = new GroovyClassLoader(new SandboxGroovyClassLoader());\n        \n        Class<?> scriptClass = classLoader.parseClass(untrusted.getQueryString());\n        Object scriptInstance = scriptClass.newInstance();\n        Object result = scriptClass.getDeclaredMethod(\"bar\", new Class[]{}).invoke(scriptInstance, new Object[]{});\n    }\n}\n```\n\n## References\n* Orange Tsai: [Abusing Meta Programming for Unauthenticated RCE!](https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html).\n* Cédric Champeau: [Improved sandboxing of Groovy scripts](https://melix.github.io/blog/2015/03/sandboxing.html).\n* Kohsuke Kawaguchi: [Groovy SecureASTCustomizer is harmful](https://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/).\n* Welk1n: [Groovy Injection payloads](https://github.com/welk1n/exploiting-groovy-in-Java/).\n* Charles Chan: [Secure Groovy Script Execution in a Sandbox](https://levelup.gitconnected.com/secure-groovy-script-execution-in-a-sandbox-ea39f80ee87/).\n* Eugene: [Scripting and sandboxing in a JVM environment](https://stringconcat.com/en/scripting-and-sandboxing/).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"},"properties":{"tags":["security","external/cwe/cwe-094"],"description":"Evaluation of a user-controlled Groovy script\n              may lead to arbitrary code execution.","id":"java/groovy-injection","kind":"path-problem","name":"Groovy Language injection","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"java/server-side-template-injection","name":"java/server-side-template-injection","shortDescription":{"text":"Server-side template injection"},"fullDescription":{"text":"Untrusted input interpreted as a template can lead to remote code execution."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Server-side template injection\nTemplate injection occurs when user input is embedded in a template's code in an unsafe manner. An attacker can use native template syntax to inject a malicious payload into a template, which is then executed server-side. This permits the attacker to run arbitrary code in the server's context.\n\n\n## Recommendation\nTo fix this, ensure that untrusted input is not used as part of a template's code. If the application requirements do not allow this, use a sandboxed environment where access to unsafe attributes and methods is prohibited.\n\n\n## Example\nIn the example given below, an untrusted HTTP parameter `code` is used as a Velocity template string. This can lead to remote code execution.\n\n\n```java\n@Controller\npublic class VelocitySSTI {\n\n\t@GetMapping(value = \"bad\")\n\tpublic void bad(HttpServletRequest request) {\n\t\tVelocity.init();\n\n\t\tString code = request.getParameter(\"code\");\n\n\t\tVelocityContext context = new VelocityContext();\n\n\t\tcontext.put(\"name\", \"Velocity\");\n\t\tcontext.put(\"project\", \"Jakarta\");\n\n\t\tStringWriter w = new StringWriter();\n\t\t// evaluate( Context context, Writer out, String logTag, String instring )\n\t\tVelocity.evaluate(context, w, \"mystring\", code);\n\t}\n}\n\n```\nIn the next example, the problem is avoided by using a fixed template string `s`. Since the template's code is not attacker-controlled in this case, this solution prevents the execution of untrusted code.\n\n\n```java\n@Controller\npublic class VelocitySSTI {\n\n\t@GetMapping(value = \"good\")\n\tpublic void good(HttpServletRequest request) {\n\t\tVelocity.init();\n\t\tVelocityContext context = new VelocityContext();\n\n\t\tcontext.put(\"name\", \"Velocity\");\n\t\tcontext.put(\"project\", \"Jakarta\");\n\n\t\tString s = \"We are using $project $name to render this.\";\n\t\tStringWriter w = new StringWriter();\n\t\tVelocity.evaluate(context, w, \"mystring\", s);\n\t\tSystem.out.println(\" string : \" + w);\n\t}\n}\n\n```\n\n## References\n* Portswigger: [Server Side Template Injection](https://portswigger.net/web-security/server-side-template-injection).\n* Common Weakness Enumeration: [CWE-1336](https://cwe.mitre.org/data/definitions/1336.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n","markdown":"# Server-side template injection\nTemplate injection occurs when user input is embedded in a template's code in an unsafe manner. An attacker can use native template syntax to inject a malicious payload into a template, which is then executed server-side. This permits the attacker to run arbitrary code in the server's context.\n\n\n## Recommendation\nTo fix this, ensure that untrusted input is not used as part of a template's code. If the application requirements do not allow this, use a sandboxed environment where access to unsafe attributes and methods is prohibited.\n\n\n## Example\nIn the example given below, an untrusted HTTP parameter `code` is used as a Velocity template string. This can lead to remote code execution.\n\n\n```java\n@Controller\npublic class VelocitySSTI {\n\n\t@GetMapping(value = \"bad\")\n\tpublic void bad(HttpServletRequest request) {\n\t\tVelocity.init();\n\n\t\tString code = request.getParameter(\"code\");\n\n\t\tVelocityContext context = new VelocityContext();\n\n\t\tcontext.put(\"name\", \"Velocity\");\n\t\tcontext.put(\"project\", \"Jakarta\");\n\n\t\tStringWriter w = new StringWriter();\n\t\t// evaluate( Context context, Writer out, String logTag, String instring )\n\t\tVelocity.evaluate(context, w, \"mystring\", code);\n\t}\n}\n\n```\nIn the next example, the problem is avoided by using a fixed template string `s`. Since the template's code is not attacker-controlled in this case, this solution prevents the execution of untrusted code.\n\n\n```java\n@Controller\npublic class VelocitySSTI {\n\n\t@GetMapping(value = \"good\")\n\tpublic void good(HttpServletRequest request) {\n\t\tVelocity.init();\n\t\tVelocityContext context = new VelocityContext();\n\n\t\tcontext.put(\"name\", \"Velocity\");\n\t\tcontext.put(\"project\", \"Jakarta\");\n\n\t\tString s = \"We are using $project $name to render this.\";\n\t\tStringWriter w = new StringWriter();\n\t\tVelocity.evaluate(context, w, \"mystring\", s);\n\t\tSystem.out.println(\" string : \" + w);\n\t}\n}\n\n```\n\n## References\n* Portswigger: [Server Side Template Injection](https://portswigger.net/web-security/server-side-template-injection).\n* Common Weakness Enumeration: [CWE-1336](https://cwe.mitre.org/data/definitions/1336.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"},"properties":{"tags":["security","external/cwe/cwe-1336","external/cwe/cwe-094"],"description":"Untrusted input interpreted as a template can lead to remote code execution.","id":"java/server-side-template-injection","kind":"path-problem","name":"Server-side template injection","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"java/mvel-expression-injection","name":"java/mvel-expression-injection","shortDescription":{"text":"Expression language injection (MVEL)"},"fullDescription":{"text":"Evaluation of a user-controlled MVEL expression may lead to remote code execution."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Expression language injection (MVEL)\nMVEL is an expression language based on Java-syntax, which offers many features including invocation of methods available in the JVM. If a MVEL expression is built using attacker-controlled data, and then evaluated, then it may allow attackers to run arbitrary code.\n\n\n## Recommendation\nIncluding user input in a MVEL expression should be avoided.\n\n\n## Example\nIn the following sample, the first example uses untrusted data to build a MVEL expression and then runs it in the default context. In the second example, the untrusted data is validated with a custom method that checks that the expression does not contain unexpected code before evaluating it.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n    new InputStreamReader(socket.getInputStream()))) {\n  \n    String expression = reader.readLine();\n    // BAD: the user-provided expression is directly evaluated\n    MVEL.eval(expression);\n  }\n}\n\npublic void safeEvaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n    new InputStreamReader(socket.getInputStream()))) {\n  \n    String expression = reader.readLine();\n    // GOOD: the user-provided expression is validated before evaluation\n    validateExpression(expression);\n    MVEL.eval(expression);\n  }\n}\n\nprivate void validateExpression(String expression) {\n  // Validate that the expression does not contain unexpected code.\n  // For instance, this can be done with allow-lists or deny-lists of code patterns.\n}\n```\n\n## References\n* MVEL Documentation: [Language Guide for 2.0](http://mvel.documentnode.com/).\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n","markdown":"# Expression language injection (MVEL)\nMVEL is an expression language based on Java-syntax, which offers many features including invocation of methods available in the JVM. If a MVEL expression is built using attacker-controlled data, and then evaluated, then it may allow attackers to run arbitrary code.\n\n\n## Recommendation\nIncluding user input in a MVEL expression should be avoided.\n\n\n## Example\nIn the following sample, the first example uses untrusted data to build a MVEL expression and then runs it in the default context. In the second example, the untrusted data is validated with a custom method that checks that the expression does not contain unexpected code before evaluating it.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n    new InputStreamReader(socket.getInputStream()))) {\n  \n    String expression = reader.readLine();\n    // BAD: the user-provided expression is directly evaluated\n    MVEL.eval(expression);\n  }\n}\n\npublic void safeEvaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n    new InputStreamReader(socket.getInputStream()))) {\n  \n    String expression = reader.readLine();\n    // GOOD: the user-provided expression is validated before evaluation\n    validateExpression(expression);\n    MVEL.eval(expression);\n  }\n}\n\nprivate void validateExpression(String expression) {\n  // Validate that the expression does not contain unexpected code.\n  // For instance, this can be done with allow-lists or deny-lists of code patterns.\n}\n```\n\n## References\n* MVEL Documentation: [Language Guide for 2.0](http://mvel.documentnode.com/).\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"},"properties":{"tags":["security","external/cwe/cwe-094"],"description":"Evaluation of a user-controlled MVEL expression\n              may lead to remote code execution.","id":"java/mvel-expression-injection","kind":"path-problem","name":"Expression language injection (MVEL)","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"java/spel-expression-injection","name":"java/spel-expression-injection","shortDescription":{"text":"Expression language injection (Spring)"},"fullDescription":{"text":"Evaluation of a user-controlled Spring Expression Language (SpEL) expression may lead to remote code execution."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Expression language injection (Spring)\nThe Spring Expression Language (SpEL) is a powerful expression language provided by the Spring Framework. The language offers many features including invocation of methods available in the JVM. If a SpEL expression is built using attacker-controlled data, and then evaluated in a powerful context, then it may allow the attacker to run arbitrary code.\n\nThe `SpelExpressionParser` class parses a SpEL expression string and returns an `Expression` instance that can be then evaluated by calling one of its methods. By default, an expression is evaluated in a powerful `StandardEvaluationContext` that allows the expression to access other methods available in the JVM.\n\n\n## Recommendation\nIn general, including user input in a SpEL expression should be avoided. If user input must be included in the expression, it should be then evaluated in a limited context that doesn't allow arbitrary method invocation.\n\n\n## Example\nThe following example uses untrusted data to build a SpEL expression and then runs it in the default powerful context.\n\n\n```java\npublic Object evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n      new InputStreamReader(socket.getInputStream()))) {\n\n    String string = reader.readLine();\n    ExpressionParser parser = new SpelExpressionParser();\n    Expression expression = parser.parseExpression(string);\n    return expression.getValue();\n  }\n}\n```\nThe next example shows how an untrusted SpEL expression can be run in `SimpleEvaluationContext` that doesn't allow accessing arbitrary methods. However, it's recommended to avoid using untrusted input in SpEL expressions.\n\n\n```java\npublic Object evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n      new InputStreamReader(socket.getInputStream()))) {\n\n    String string = reader.readLine();\n    ExpressionParser parser = new SpelExpressionParser();\n    Expression expression = parser.parseExpression(string);\n    SimpleEvaluationContext context \n        = SimpleEvaluationContext.forReadWriteDataBinding().build();\n    return expression.getValue(context);\n  }\n}\n```\n\n## References\n* Spring Framework Reference Documentation: [Spring Expression Language (SpEL)](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html).\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n","markdown":"# Expression language injection (Spring)\nThe Spring Expression Language (SpEL) is a powerful expression language provided by the Spring Framework. The language offers many features including invocation of methods available in the JVM. If a SpEL expression is built using attacker-controlled data, and then evaluated in a powerful context, then it may allow the attacker to run arbitrary code.\n\nThe `SpelExpressionParser` class parses a SpEL expression string and returns an `Expression` instance that can be then evaluated by calling one of its methods. By default, an expression is evaluated in a powerful `StandardEvaluationContext` that allows the expression to access other methods available in the JVM.\n\n\n## Recommendation\nIn general, including user input in a SpEL expression should be avoided. If user input must be included in the expression, it should be then evaluated in a limited context that doesn't allow arbitrary method invocation.\n\n\n## Example\nThe following example uses untrusted data to build a SpEL expression and then runs it in the default powerful context.\n\n\n```java\npublic Object evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n      new InputStreamReader(socket.getInputStream()))) {\n\n    String string = reader.readLine();\n    ExpressionParser parser = new SpelExpressionParser();\n    Expression expression = parser.parseExpression(string);\n    return expression.getValue();\n  }\n}\n```\nThe next example shows how an untrusted SpEL expression can be run in `SimpleEvaluationContext` that doesn't allow accessing arbitrary methods. However, it's recommended to avoid using untrusted input in SpEL expressions.\n\n\n```java\npublic Object evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n      new InputStreamReader(socket.getInputStream()))) {\n\n    String string = reader.readLine();\n    ExpressionParser parser = new SpelExpressionParser();\n    Expression expression = parser.parseExpression(string);\n    SimpleEvaluationContext context \n        = SimpleEvaluationContext.forReadWriteDataBinding().build();\n    return expression.getValue(context);\n  }\n}\n```\n\n## References\n* Spring Framework Reference Documentation: [Spring Expression Language (SpEL)](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html).\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"},"properties":{"tags":["security","external/cwe/cwe-094"],"description":"Evaluation of a user-controlled Spring Expression Language (SpEL) expression\n              may lead to remote code execution.","id":"java/spel-expression-injection","kind":"path-problem","name":"Expression language injection (Spring)","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"java/insecure-bean-validation","name":"java/insecure-bean-validation","shortDescription":{"text":"Insecure Bean Validation"},"fullDescription":{"text":"User-controlled data may be evaluated as a Java EL expression, leading to arbitrary code execution."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Insecure Bean Validation\nCustom error messages for constraint validators support different types of interpolation, including [Java EL expressions](https://docs.jboss.org/hibernate/validator/5.1/reference/en-US/html/chapter-message-interpolation.html#section-interpolation-with-message-expressions). Controlling part of the message template being passed to `ConstraintValidatorContext.buildConstraintViolationWithTemplate()` argument can lead to arbitrary Java code execution. Unfortunately, it is common that validated (and therefore, normally untrusted) bean properties flow into the custom error message.\n\n\n## Recommendation\nThere are different approaches to remediate the issue:\n\n* Do not include validated bean properties in the custom error message.\n* Use parameterized messages instead of string concatenation. For example:\n```\nHibernateConstraintValidatorContext context =\n   constraintValidatorContext.unwrap(HibernateConstraintValidatorContext.class);\ncontext.addMessageParameter(\"foo\", \"bar\");\ncontext.buildConstraintViolationWithTemplate(\"My violation message contains a parameter {foo}\")\n   .addConstraintViolation();\n```\n* Sanitize the validated bean properties to make sure that there are no EL expressions. An example of valid sanitization logic can be found [here](https://github.com/hibernate/hibernate-validator/blob/master/engine/src/main/java/org/hibernate/validator/internal/engine/messageinterpolation/util/InterpolationHelper.java#L17).\n* Disable the EL interpolation and only use `ParameterMessageInterpolator`:\n```\nValidator validator = Validation.byDefaultProvider()\n   .configure()\n   .messageInterpolator(new ParameterMessageInterpolator())\n   .buildValidatorFactory()\n   .getValidator();\n```\n* Replace Hibernate Validator with Apache BVal, which in its latest version does not interpolate EL expressions by default. Note that this replacement may not be a simple drop-in replacement.\n\n## Example\nThe following validator could result in arbitrary Java code execution:\n\n\n```java\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\nimport org.hibernate.validator.constraintvalidation.HibernateConstraintValidatorContext;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class TestValidator implements ConstraintValidator<Object, String> {\n\n    public static class InterpolationHelper {\n\n        public static final char BEGIN_TERM = '{';\n        public static final char END_TERM = '}';\n        public static final char EL_DESIGNATOR = '$';\n        public static final char ESCAPE_CHARACTER = '\\\\';\n\n        private static final Pattern ESCAPE_MESSAGE_PARAMETER_PATTERN = Pattern.compile( \"([\\\\\" + ESCAPE_CHARACTER + BEGIN_TERM + END_TERM + EL_DESIGNATOR + \"])\" );\n\n        private InterpolationHelper() {\n        }\n\n        public static String escapeMessageParameter(String messageParameter) {\n            if ( messageParameter == null ) {\n                return null;\n            }\n            return ESCAPE_MESSAGE_PARAMETER_PATTERN.matcher( messageParameter ).replaceAll( Matcher.quoteReplacement( String.valueOf( ESCAPE_CHARACTER ) ) + \"$1\" );\n        }\n\n    }\n\n    @Override\n    public boolean isValid(String object, ConstraintValidatorContext constraintContext) {\n        String value = object + \" is invalid\";\n\n        // Bad: Bean properties (normally user-controlled) are passed directly to `buildConstraintViolationWithTemplate`\n        constraintContext.buildConstraintViolationWithTemplate(value).addConstraintViolation().disableDefaultConstraintViolation();\n\n        // Good: Bean properties (normally user-controlled) are escaped \n        String escaped = InterpolationHelper.escapeMessageParameter(value);\n        constraintContext.buildConstraintViolationWithTemplate(escaped).addConstraintViolation().disableDefaultConstraintViolation();\n\n        // Good: Bean properties (normally user-controlled) are parameterized\n        HibernateConstraintValidatorContext context = constraintContext.unwrap( HibernateConstraintValidatorContext.class );\n        context.addMessageParameter( \"prop\", object );\n        context.buildConstraintViolationWithTemplate( \"{prop} is invalid\").addConstraintViolation();\n        return false;\n    }\n\n}\n\n```\n\n## References\n* Hibernate Reference Guide: [ConstraintValidatorContext](https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#_the_code_constraintvalidatorcontext_code).\n* GitHub Security Lab research: [Bean validation](https://securitylab.github.com/research/bean-validation-RCE).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n","markdown":"# Insecure Bean Validation\nCustom error messages for constraint validators support different types of interpolation, including [Java EL expressions](https://docs.jboss.org/hibernate/validator/5.1/reference/en-US/html/chapter-message-interpolation.html#section-interpolation-with-message-expressions). Controlling part of the message template being passed to `ConstraintValidatorContext.buildConstraintViolationWithTemplate()` argument can lead to arbitrary Java code execution. Unfortunately, it is common that validated (and therefore, normally untrusted) bean properties flow into the custom error message.\n\n\n## Recommendation\nThere are different approaches to remediate the issue:\n\n* Do not include validated bean properties in the custom error message.\n* Use parameterized messages instead of string concatenation. For example:\n```\nHibernateConstraintValidatorContext context =\n   constraintValidatorContext.unwrap(HibernateConstraintValidatorContext.class);\ncontext.addMessageParameter(\"foo\", \"bar\");\ncontext.buildConstraintViolationWithTemplate(\"My violation message contains a parameter {foo}\")\n   .addConstraintViolation();\n```\n* Sanitize the validated bean properties to make sure that there are no EL expressions. An example of valid sanitization logic can be found [here](https://github.com/hibernate/hibernate-validator/blob/master/engine/src/main/java/org/hibernate/validator/internal/engine/messageinterpolation/util/InterpolationHelper.java#L17).\n* Disable the EL interpolation and only use `ParameterMessageInterpolator`:\n```\nValidator validator = Validation.byDefaultProvider()\n   .configure()\n   .messageInterpolator(new ParameterMessageInterpolator())\n   .buildValidatorFactory()\n   .getValidator();\n```\n* Replace Hibernate Validator with Apache BVal, which in its latest version does not interpolate EL expressions by default. Note that this replacement may not be a simple drop-in replacement.\n\n## Example\nThe following validator could result in arbitrary Java code execution:\n\n\n```java\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\nimport org.hibernate.validator.constraintvalidation.HibernateConstraintValidatorContext;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class TestValidator implements ConstraintValidator<Object, String> {\n\n    public static class InterpolationHelper {\n\n        public static final char BEGIN_TERM = '{';\n        public static final char END_TERM = '}';\n        public static final char EL_DESIGNATOR = '$';\n        public static final char ESCAPE_CHARACTER = '\\\\';\n\n        private static final Pattern ESCAPE_MESSAGE_PARAMETER_PATTERN = Pattern.compile( \"([\\\\\" + ESCAPE_CHARACTER + BEGIN_TERM + END_TERM + EL_DESIGNATOR + \"])\" );\n\n        private InterpolationHelper() {\n        }\n\n        public static String escapeMessageParameter(String messageParameter) {\n            if ( messageParameter == null ) {\n                return null;\n            }\n            return ESCAPE_MESSAGE_PARAMETER_PATTERN.matcher( messageParameter ).replaceAll( Matcher.quoteReplacement( String.valueOf( ESCAPE_CHARACTER ) ) + \"$1\" );\n        }\n\n    }\n\n    @Override\n    public boolean isValid(String object, ConstraintValidatorContext constraintContext) {\n        String value = object + \" is invalid\";\n\n        // Bad: Bean properties (normally user-controlled) are passed directly to `buildConstraintViolationWithTemplate`\n        constraintContext.buildConstraintViolationWithTemplate(value).addConstraintViolation().disableDefaultConstraintViolation();\n\n        // Good: Bean properties (normally user-controlled) are escaped \n        String escaped = InterpolationHelper.escapeMessageParameter(value);\n        constraintContext.buildConstraintViolationWithTemplate(escaped).addConstraintViolation().disableDefaultConstraintViolation();\n\n        // Good: Bean properties (normally user-controlled) are parameterized\n        HibernateConstraintValidatorContext context = constraintContext.unwrap( HibernateConstraintValidatorContext.class );\n        context.addMessageParameter( \"prop\", object );\n        context.buildConstraintViolationWithTemplate( \"{prop} is invalid\").addConstraintViolation();\n        return false;\n    }\n\n}\n\n```\n\n## References\n* Hibernate Reference Guide: [ConstraintValidatorContext](https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#_the_code_constraintvalidatorcontext_code).\n* GitHub Security Lab research: [Bean validation](https://securitylab.github.com/research/bean-validation-RCE).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"},"properties":{"tags":["security","external/cwe/cwe-094"],"description":"User-controlled data may be evaluated as a Java EL expression, leading to arbitrary code execution.","id":"java/insecure-bean-validation","kind":"path-problem","name":"Insecure Bean Validation","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"java/jexl-expression-injection","name":"java/jexl-expression-injection","shortDescription":{"text":"Expression language injection (JEXL)"},"fullDescription":{"text":"Evaluation of a user-controlled JEXL expression may lead to arbitrary code execution."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Expression language injection (JEXL)\nJava EXpression Language (JEXL) is a simple expression language provided by the Apache Commons JEXL library. The syntax is close to a mix of ECMAScript and shell-script. The language allows invocation of methods available in the JVM. If a JEXL expression is built using attacker-controlled data, and then evaluated, then it may allow the attacker to run arbitrary code.\n\n\n## Recommendation\nIt is generally recommended to avoid using untrusted input in a JEXL expression. If it is not possible, JEXL expressions should be run in a sandbox that allows accessing only explicitly allowed classes.\n\n\n## Example\nThe following example uses untrusted data to build and run a JEXL expression.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n        new InputStreamReader(socket.getInputStream()))) {\n    \n    String input = reader.readLine();\n    JexlEngine jexl = new JexlBuilder().create();\n    JexlExpression expression = jexl.createExpression(input);\n    JexlContext context = new MapContext();\n    expression.evaluate(context);\n  }\n}\n```\nThe next example shows how an untrusted JEXL expression can be run in a sandbox that allows accessing only methods in the `java.lang.Math` class. The sandbox is implemented using `JexlSandbox` class that is provided by Apache Commons JEXL 3.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n        new InputStreamReader(socket.getInputStream()))) {\n    \n    JexlSandbox onlyMath = new JexlSandbox(false);\n    onlyMath.white(\"java.lang.Math\");\n    JexlEngine jexl = new JexlBuilder().sandbox(onlyMath).create();\n      \n    String input = reader.readLine();\n    JexlExpression expression = jexl.createExpression(input);\n    JexlContext context = new MapContext();\n    expression.evaluate(context);\n  }\n}\n```\nThe next example shows another way how a sandbox can be implemented. It uses a custom implementation of `JexlUberspect` that checks if callees are instances of allowed classes.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n        new InputStreamReader(socket.getInputStream()))) {\n    \n    JexlUberspect sandbox = new JexlUberspectSandbox();\n    JexlEngine jexl = new JexlBuilder().uberspect(sandbox).create();\n      \n    String input = reader.readLine();\n    JexlExpression expression = jexl.createExpression(input);\n    JexlContext context = new MapContext();\n    expression.evaluate(context);\n  }\n\n  private static class JexlUberspectSandbox implements JexlUberspect {\n\n    private static final List<String> ALLOWED_CLASSES =\n              Arrays.asList(\"java.lang.Math\", \"java.util.Random\");\n\n    private final JexlUberspect uberspect = new JexlBuilder().create().getUberspect();\n\n    private void checkAccess(Object obj) {\n      if (!ALLOWED_CLASSES.contains(obj.getClass().getCanonicalName())) {\n        throw new AccessControlException(\"Not allowed\");\n      }\n    }\n\n    @Override\n    public JexlMethod getMethod(Object obj, String method, Object... args) {\n      checkAccess(obj);\n      return uberspect.getMethod(obj, method, args);\n    }\n\n    @Override\n    public List<PropertyResolver> getResolvers(JexlOperator op, Object obj) {\n      checkAccess(obj);\n      return uberspect.getResolvers(op, obj);\n    }\n\n    @Override\n    public void setClassLoader(ClassLoader loader) {\n      uberspect.setClassLoader(loader);\n    }\n\n    @Override\n    public int getVersion() {\n      return uberspect.getVersion();\n    }\n\n    @Override\n    public JexlMethod getConstructor(Object obj, Object... args) {\n      checkAccess(obj);\n      return uberspect.getConstructor(obj, args);\n    }\n\n    @Override\n    public JexlPropertyGet getPropertyGet(Object obj, Object identifier) {\n      checkAccess(obj);\n      return uberspect.getPropertyGet(obj, identifier);\n    }\n\n    @Override\n    public JexlPropertyGet getPropertyGet(List<PropertyResolver> resolvers, Object obj, Object identifier) {\n      checkAccess(obj);\n      return uberspect.getPropertyGet(resolvers, obj, identifier);\n    }\n\n    @Override\n    public JexlPropertySet getPropertySet(Object obj, Object identifier, Object arg) {\n      checkAccess(obj);\n      return uberspect.getPropertySet(obj, identifier, arg);\n    }\n\n    @Override\n    public JexlPropertySet getPropertySet(List<PropertyResolver> resolvers, Object obj, Object identifier, Object arg) {\n      checkAccess(obj);\n      return uberspect.getPropertySet(resolvers, obj, identifier, arg);\n    }\n\n    @Override\n    public Iterator<?> getIterator(Object obj) {\n      checkAccess(obj);\n      return uberspect.getIterator(obj);\n    }\n\n    @Override\n    public JexlArithmetic.Uberspect getArithmetic(JexlArithmetic arithmetic) {\n      return uberspect.getArithmetic(arithmetic);\n    } \n  }\n}\n```\n\n## References\n* Apache Commons JEXL: [Project page](https://commons.apache.org/proper/commons-jexl/).\n* Apache Commons JEXL documentation: [JEXL 2.1.1 API](https://commons.apache.org/proper/commons-jexl/javadocs/apidocs-2.1.1/).\n* Apache Commons JEXL documentation: [JEXL 3.1 API](https://commons.apache.org/proper/commons-jexl/apidocs/index.html).\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n","markdown":"# Expression language injection (JEXL)\nJava EXpression Language (JEXL) is a simple expression language provided by the Apache Commons JEXL library. The syntax is close to a mix of ECMAScript and shell-script. The language allows invocation of methods available in the JVM. If a JEXL expression is built using attacker-controlled data, and then evaluated, then it may allow the attacker to run arbitrary code.\n\n\n## Recommendation\nIt is generally recommended to avoid using untrusted input in a JEXL expression. If it is not possible, JEXL expressions should be run in a sandbox that allows accessing only explicitly allowed classes.\n\n\n## Example\nThe following example uses untrusted data to build and run a JEXL expression.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n        new InputStreamReader(socket.getInputStream()))) {\n    \n    String input = reader.readLine();\n    JexlEngine jexl = new JexlBuilder().create();\n    JexlExpression expression = jexl.createExpression(input);\n    JexlContext context = new MapContext();\n    expression.evaluate(context);\n  }\n}\n```\nThe next example shows how an untrusted JEXL expression can be run in a sandbox that allows accessing only methods in the `java.lang.Math` class. The sandbox is implemented using `JexlSandbox` class that is provided by Apache Commons JEXL 3.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n        new InputStreamReader(socket.getInputStream()))) {\n    \n    JexlSandbox onlyMath = new JexlSandbox(false);\n    onlyMath.white(\"java.lang.Math\");\n    JexlEngine jexl = new JexlBuilder().sandbox(onlyMath).create();\n      \n    String input = reader.readLine();\n    JexlExpression expression = jexl.createExpression(input);\n    JexlContext context = new MapContext();\n    expression.evaluate(context);\n  }\n}\n```\nThe next example shows another way how a sandbox can be implemented. It uses a custom implementation of `JexlUberspect` that checks if callees are instances of allowed classes.\n\n\n```java\npublic void evaluate(Socket socket) throws IOException {\n  try (BufferedReader reader = new BufferedReader(\n        new InputStreamReader(socket.getInputStream()))) {\n    \n    JexlUberspect sandbox = new JexlUberspectSandbox();\n    JexlEngine jexl = new JexlBuilder().uberspect(sandbox).create();\n      \n    String input = reader.readLine();\n    JexlExpression expression = jexl.createExpression(input);\n    JexlContext context = new MapContext();\n    expression.evaluate(context);\n  }\n\n  private static class JexlUberspectSandbox implements JexlUberspect {\n\n    private static final List<String> ALLOWED_CLASSES =\n              Arrays.asList(\"java.lang.Math\", \"java.util.Random\");\n\n    private final JexlUberspect uberspect = new JexlBuilder().create().getUberspect();\n\n    private void checkAccess(Object obj) {\n      if (!ALLOWED_CLASSES.contains(obj.getClass().getCanonicalName())) {\n        throw new AccessControlException(\"Not allowed\");\n      }\n    }\n\n    @Override\n    public JexlMethod getMethod(Object obj, String method, Object... args) {\n      checkAccess(obj);\n      return uberspect.getMethod(obj, method, args);\n    }\n\n    @Override\n    public List<PropertyResolver> getResolvers(JexlOperator op, Object obj) {\n      checkAccess(obj);\n      return uberspect.getResolvers(op, obj);\n    }\n\n    @Override\n    public void setClassLoader(ClassLoader loader) {\n      uberspect.setClassLoader(loader);\n    }\n\n    @Override\n    public int getVersion() {\n      return uberspect.getVersion();\n    }\n\n    @Override\n    public JexlMethod getConstructor(Object obj, Object... args) {\n      checkAccess(obj);\n      return uberspect.getConstructor(obj, args);\n    }\n\n    @Override\n    public JexlPropertyGet getPropertyGet(Object obj, Object identifier) {\n      checkAccess(obj);\n      return uberspect.getPropertyGet(obj, identifier);\n    }\n\n    @Override\n    public JexlPropertyGet getPropertyGet(List<PropertyResolver> resolvers, Object obj, Object identifier) {\n      checkAccess(obj);\n      return uberspect.getPropertyGet(resolvers, obj, identifier);\n    }\n\n    @Override\n    public JexlPropertySet getPropertySet(Object obj, Object identifier, Object arg) {\n      checkAccess(obj);\n      return uberspect.getPropertySet(obj, identifier, arg);\n    }\n\n    @Override\n    public JexlPropertySet getPropertySet(List<PropertyResolver> resolvers, Object obj, Object identifier, Object arg) {\n      checkAccess(obj);\n      return uberspect.getPropertySet(resolvers, obj, identifier, arg);\n    }\n\n    @Override\n    public Iterator<?> getIterator(Object obj) {\n      checkAccess(obj);\n      return uberspect.getIterator(obj);\n    }\n\n    @Override\n    public JexlArithmetic.Uberspect getArithmetic(JexlArithmetic arithmetic) {\n      return uberspect.getArithmetic(arithmetic);\n    } \n  }\n}\n```\n\n## References\n* Apache Commons JEXL: [Project page](https://commons.apache.org/proper/commons-jexl/).\n* Apache Commons JEXL documentation: [JEXL 2.1.1 API](https://commons.apache.org/proper/commons-jexl/javadocs/apidocs-2.1.1/).\n* Apache Commons JEXL documentation: [JEXL 3.1 API](https://commons.apache.org/proper/commons-jexl/apidocs/index.html).\n* OWASP: [Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"},"properties":{"tags":["security","external/cwe/cwe-094"],"description":"Evaluation of a user-controlled JEXL expression\n              may lead to arbitrary code execution.","id":"java/jexl-expression-injection","kind":"path-problem","name":"Expression language injection (JEXL)","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"java/improper-intent-verification","name":"java/improper-intent-verification","shortDescription":{"text":"Improper verification of intent by broadcast receiver"},"fullDescription":{"text":"A broadcast receiver that does not verify intents it receives may be susceptible to unintended behavior by third party applications sending it explicit intents."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Improper verification of intent by broadcast receiver\nWhen an Android application uses a `BroadcastReceiver` to receive intents, it is also able to receive explicit intents that are sent directly to it, regardless of its filter. Certain intent actions are only able to be sent by the operating system, not third-party applications. However, a `BroadcastReceiver` that is registered to receive system intents is still able to receive intents from a third-party application, so it should check that the intent received has the expected action. Otherwise, a third-party application could impersonate the system this way to cause unintended behavior, such as a denial of service.\n\n\n## Example\nIn the following code, the `ShutdownReceiver` initiates a shutdown procedure upon receiving an intent, without checking that the received action is indeed `ACTION_SHUTDOWN`. This allows third-party applications to send explicit intents to this receiver to cause a denial of service.\n\n\n```java\npublic class ShutdownReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        mainActivity.saveLocalData();\n        mainActivity.stopActivity();\n    }\n}\n```\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"test\">\n    <application>\n        <receiver android:name=\".BootReceiverXml\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.BOOT_COMPLETED\" />\n            </intent-filter>\n        </receiver>\n    </application>\n</manifest>\n```\n\n## Recommendation\nIn the `onReceive` method of a `BroadcastReceiver`, the action of the received Intent should be checked. The following code demonstrates this.\n\n\n```java\npublic class ShutdownReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        if (!intent.getAction().equals(Intent.ACTION_SHUTDOWN)) {\n            return;\n        }\n        mainActivity.saveLocalData();\n        mainActivity.stopActivity();\n    }\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-925](https://cwe.mitre.org/data/definitions/925.html).\n","markdown":"# Improper verification of intent by broadcast receiver\nWhen an Android application uses a `BroadcastReceiver` to receive intents, it is also able to receive explicit intents that are sent directly to it, regardless of its filter. Certain intent actions are only able to be sent by the operating system, not third-party applications. However, a `BroadcastReceiver` that is registered to receive system intents is still able to receive intents from a third-party application, so it should check that the intent received has the expected action. Otherwise, a third-party application could impersonate the system this way to cause unintended behavior, such as a denial of service.\n\n\n## Example\nIn the following code, the `ShutdownReceiver` initiates a shutdown procedure upon receiving an intent, without checking that the received action is indeed `ACTION_SHUTDOWN`. This allows third-party applications to send explicit intents to this receiver to cause a denial of service.\n\n\n```java\npublic class ShutdownReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        mainActivity.saveLocalData();\n        mainActivity.stopActivity();\n    }\n}\n```\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"test\">\n    <application>\n        <receiver android:name=\".BootReceiverXml\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.BOOT_COMPLETED\" />\n            </intent-filter>\n        </receiver>\n    </application>\n</manifest>\n```\n\n## Recommendation\nIn the `onReceive` method of a `BroadcastReceiver`, the action of the received Intent should be checked. The following code demonstrates this.\n\n\n```java\npublic class ShutdownReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        if (!intent.getAction().equals(Intent.ACTION_SHUTDOWN)) {\n            return;\n        }\n        mainActivity.saveLocalData();\n        mainActivity.stopActivity();\n    }\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-925](https://cwe.mitre.org/data/definitions/925.html).\n"},"properties":{"tags":["security","external/cwe/cwe-925"],"description":"A broadcast receiver that does not verify intents it receives may be susceptible to unintended behavior by third party applications sending it explicit intents.","id":"java/improper-intent-verification","kind":"problem","name":"Improper verification of intent by broadcast receiver","precision":"high","problem.severity":"warning","security-severity":"8.2"}},{"id":"java/unvalidated-url-redirection","name":"java/unvalidated-url-redirection","shortDescription":{"text":"URL redirection from remote source"},"fullDescription":{"text":"URL redirection based on unvalidated user-input may cause redirection to malicious web sites."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# URL redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```java\npublic class UrlRedirect extends HttpServlet {\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    // BAD: a request parameter is incorporated without validation into a URL redirect\n    response.sendRedirect(request.getParameter(\"target\"));\n  }\n}\n```\nOne way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:\n\n\n```java\npublic class UrlRedirect extends HttpServlet {\n  private static final List<String> VALID_REDIRECTS = Arrays.asList(\n    \"http://cwe.mitre.org/data/definitions/601.html\",\n    \"http://cwe.mitre.org/data/definitions/79.html\"\n  );\n\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    // GOOD: the request parameter is validated against a known list of strings\n    String target = request.getParameter(\"target\");\n    if (VALID_REDIRECTS.contains(target)) {\n        response.sendRedirect(target);\n    } else {\n        response.sendRedirect(\"/error.html\");\n    }\n  }\n}\n```\nAlternatively, we can check that the target URL does not redirect to a different host by checking that the URL is either relative or on a known good host:\n\n\n```java\npublic class UrlRedirect extends HttpServlet {\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    try {\n      String urlString = request.getParameter(\"page\");\n      URI url = new URI(urlString);\n\n      if (!url.isAbsolute()) {\n        response.sendRedirect(url.toString()); // GOOD: The redirect is to a relative URL\n      }\n\n      if (\"example.org\".equals(url.getHost())) {\n        response.sendRedirect(url.toString()); // GOOD: The redirect is to a known host\n      }\n    } catch (URISyntaxException e) {\n        // handle exception\n    }\n  }\n}\n```\nNote that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.\n\n\n## References\n* OWASP: [ Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n","markdown":"# URL redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```java\npublic class UrlRedirect extends HttpServlet {\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    // BAD: a request parameter is incorporated without validation into a URL redirect\n    response.sendRedirect(request.getParameter(\"target\"));\n  }\n}\n```\nOne way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:\n\n\n```java\npublic class UrlRedirect extends HttpServlet {\n  private static final List<String> VALID_REDIRECTS = Arrays.asList(\n    \"http://cwe.mitre.org/data/definitions/601.html\",\n    \"http://cwe.mitre.org/data/definitions/79.html\"\n  );\n\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    // GOOD: the request parameter is validated against a known list of strings\n    String target = request.getParameter(\"target\");\n    if (VALID_REDIRECTS.contains(target)) {\n        response.sendRedirect(target);\n    } else {\n        response.sendRedirect(\"/error.html\");\n    }\n  }\n}\n```\nAlternatively, we can check that the target URL does not redirect to a different host by checking that the URL is either relative or on a known good host:\n\n\n```java\npublic class UrlRedirect extends HttpServlet {\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    try {\n      String urlString = request.getParameter(\"page\");\n      URI url = new URI(urlString);\n\n      if (!url.isAbsolute()) {\n        response.sendRedirect(url.toString()); // GOOD: The redirect is to a relative URL\n      }\n\n      if (\"example.org\".equals(url.getHost())) {\n        response.sendRedirect(url.toString()); // GOOD: The redirect is to a known host\n      }\n    } catch (URISyntaxException e) {\n        // handle exception\n    }\n  }\n}\n```\nNote that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.\n\n\n## References\n* OWASP: [ Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"},"properties":{"tags":["security","external/cwe/cwe-601"],"description":"URL redirection based on unvalidated user-input\n              may cause redirection to malicious web sites.","id":"java/unvalidated-url-redirection","kind":"path-problem","name":"URL redirection from remote source","precision":"high","problem.severity":"error","security-severity":"6.1"}},{"id":"java/ognl-injection","name":"java/ognl-injection","shortDescription":{"text":"OGNL Expression Language statement with user-controlled input"},"fullDescription":{"text":"Evaluation of OGNL Expression Language statement with user-controlled input can lead to execution of arbitrary code."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# OGNL Expression Language statement with user-controlled input\nObject-Graph Navigation Language (OGNL) is an open-source Expression Language (EL) for Java. OGNL can create or change executable code, consequently it can introduce critical security flaws to any application that uses it. Evaluation of unvalidated expressions is a common flaw in OGNL. This exposes the properties of Java objects to modification by an attacker and may allow them to execute arbitrary code.\n\n\n## Recommendation\nThe general recommendation is to avoid evaluating untrusted ONGL expressions. If user-provided OGNL expressions must be evaluated, do this in a sandbox and validate the expressions before evaluation.\n\n\n## Example\nIn the following examples, the code accepts an OGNL expression from the user and evaluates it.\n\nIn the first example, the user-provided OGNL expression is parsed and evaluated.\n\nThe second example validates the expression and evaluates it inside a sandbox. You can add a sandbox by setting a system property, as shown in the example, or by adding `-Dognl.security.manager` to JVM arguments.\n\n\n```java\nimport ognl.Ognl;\nimport ognl.OgnlException;\n\npublic void evaluate(HttpServletRequest request, Object root) throws OgnlException {\n  String expression = request.getParameter(\"expression\");\n\n  // BAD: User provided expression is evaluated\n  Ognl.getValue(expression, root);\n  \n  // GOOD: The name is validated and expression is evaluated in sandbox\n  System.setProperty(\"ognl.security.manager\", \"\"); // Or add -Dognl.security.manager to JVM args\n  if (isValid(expression)) {\n    Ognl.getValue(expression, root);\n  } else {\n    // Reject the request\n  }\n}\n\npublic void isValid(Strig expression) {\n  // Custom method to validate the expression.\n  // For instance, make sure it doesn't include unexpected code.\n}\n\n```\n\n## References\n* Apache Commons: [Apache Commons OGNL](https://commons.apache.org/proper/commons-ognl/).\n* Struts security: [Proactively protect from OGNL Expression Injections attacks](https://struts.apache.org/security/#proactively-protect-from-ognl-expression-injections-attacks-if-easily-applicable).\n* Common Weakness Enumeration: [CWE-917](https://cwe.mitre.org/data/definitions/917.html).\n","markdown":"# OGNL Expression Language statement with user-controlled input\nObject-Graph Navigation Language (OGNL) is an open-source Expression Language (EL) for Java. OGNL can create or change executable code, consequently it can introduce critical security flaws to any application that uses it. Evaluation of unvalidated expressions is a common flaw in OGNL. This exposes the properties of Java objects to modification by an attacker and may allow them to execute arbitrary code.\n\n\n## Recommendation\nThe general recommendation is to avoid evaluating untrusted ONGL expressions. If user-provided OGNL expressions must be evaluated, do this in a sandbox and validate the expressions before evaluation.\n\n\n## Example\nIn the following examples, the code accepts an OGNL expression from the user and evaluates it.\n\nIn the first example, the user-provided OGNL expression is parsed and evaluated.\n\nThe second example validates the expression and evaluates it inside a sandbox. You can add a sandbox by setting a system property, as shown in the example, or by adding `-Dognl.security.manager` to JVM arguments.\n\n\n```java\nimport ognl.Ognl;\nimport ognl.OgnlException;\n\npublic void evaluate(HttpServletRequest request, Object root) throws OgnlException {\n  String expression = request.getParameter(\"expression\");\n\n  // BAD: User provided expression is evaluated\n  Ognl.getValue(expression, root);\n  \n  // GOOD: The name is validated and expression is evaluated in sandbox\n  System.setProperty(\"ognl.security.manager\", \"\"); // Or add -Dognl.security.manager to JVM args\n  if (isValid(expression)) {\n    Ognl.getValue(expression, root);\n  } else {\n    // Reject the request\n  }\n}\n\npublic void isValid(Strig expression) {\n  // Custom method to validate the expression.\n  // For instance, make sure it doesn't include unexpected code.\n}\n\n```\n\n## References\n* Apache Commons: [Apache Commons OGNL](https://commons.apache.org/proper/commons-ognl/).\n* Struts security: [Proactively protect from OGNL Expression Injections attacks](https://struts.apache.org/security/#proactively-protect-from-ognl-expression-injections-attacks-if-easily-applicable).\n* Common Weakness Enumeration: [CWE-917](https://cwe.mitre.org/data/definitions/917.html).\n"},"properties":{"tags":["security","external/cwe/cwe-917"],"description":"Evaluation of OGNL Expression Language statement with user-controlled input can\n                lead to execution of arbitrary code.","id":"java/ognl-injection","kind":"path-problem","name":"OGNL Expression Language statement with user-controlled input","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"java/android/fragment-injection","name":"java/android/fragment-injection","shortDescription":{"text":"Android fragment injection"},"fullDescription":{"text":"Instantiating an Android fragment from a user-provided value may allow a malicious application to bypass access controls, exposing the application to unintended effects."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Android fragment injection\nWhen fragments are instantiated with externally provided names, this exposes any exported activity that dynamically creates and hosts the fragment to fragment injection. A malicious application could provide the name of an arbitrary fragment, even one not designed to be externally accessible, and inject it into the activity. This can bypass access controls and expose the application to unintended effects.\n\nFragments are reusable parts of an Android application's user interface. Even though a fragment controls its own lifecycle and layout, and handles its input events, it cannot exist on its own: it must be hosted either by an activity or another fragment. This means that, normally, a fragment will be accessible by third-party applications (that is, exported) only if its hosting activity is itself exported.\n\n\n## Recommendation\nIn general, do not instantiate classes (including fragments) with user-provided names unless the name has been properly validated. Also, if an exported activity is extending the `PreferenceActivity` class, make sure that the `isValidFragment` method is overriden and only returns `true` when the provided `fragmentName` points to an intended fragment.\n\n\n## Example\nThe following example shows two cases: in the first one, untrusted data is used to instantiate and add a fragment to an activity, while in the second one, a fragment is safely added with a static name.\n\n\n```java\npublic class MyActivity extends FragmentActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstance) {\n        try {\n            super.onCreate(savedInstance);\n            // BAD: Fragment instantiated from user input without validation\n            {\n                String fName = getIntent().getStringExtra(\"fragmentName\");\n                getFragmentManager().beginTransaction().replace(com.android.internal.R.id.prefs,\n                        Fragment.instantiate(this, fName, null)).commit();\n            }\n            // GOOD: Fragment instantiated statically\n            {\n                getFragmentManager().beginTransaction()\n                        .replace(com.android.internal.R.id.prefs, new MyFragment()).commit();\n            }\n        } catch (Exception e) {\n        }\n    }\n\n}\n\n```\nThe next example shows two activities that extend `PreferenceActivity`. The first activity overrides `isValidFragment`, but it wrongly returns `true` unconditionally. The second activity correctly overrides `isValidFragment` so that it only returns `true` when `fragmentName` is a trusted fragment name.\n\n\n```java\nclass UnsafeActivity extends PreferenceActivity {\n\n    @Override\n    protected boolean isValidFragment(String fragmentName) {\n        // BAD: any Fragment name can be provided.\n        return true;\n    }\n}\n\n\nclass SafeActivity extends PreferenceActivity {\n    @Override\n    protected boolean isValidFragment(String fragmentName) {\n        // Good: only trusted Fragment names are allowed.\n        return SafeFragment1.class.getName().equals(fragmentName)\n                || SafeFragment2.class.getName().equals(fragmentName)\n                || SafeFragment3.class.getName().equals(fragmentName);\n    }\n\n}\n\n\n```\n\n## References\n* Google Help: [How to fix Fragment Injection vulnerability](https://support.google.com/faqs/answer/7188427?hl=en).\n* IBM Security Systems: [Android collapses into Fragments](https://securityintelligence.com/wp-content/uploads/2013/12/android-collapses-into-fragments.pdf).\n* Android Developers: [Fragments](https://developer.android.com/guide/fragments)\n* Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).\n","markdown":"# Android fragment injection\nWhen fragments are instantiated with externally provided names, this exposes any exported activity that dynamically creates and hosts the fragment to fragment injection. A malicious application could provide the name of an arbitrary fragment, even one not designed to be externally accessible, and inject it into the activity. This can bypass access controls and expose the application to unintended effects.\n\nFragments are reusable parts of an Android application's user interface. Even though a fragment controls its own lifecycle and layout, and handles its input events, it cannot exist on its own: it must be hosted either by an activity or another fragment. This means that, normally, a fragment will be accessible by third-party applications (that is, exported) only if its hosting activity is itself exported.\n\n\n## Recommendation\nIn general, do not instantiate classes (including fragments) with user-provided names unless the name has been properly validated. Also, if an exported activity is extending the `PreferenceActivity` class, make sure that the `isValidFragment` method is overriden and only returns `true` when the provided `fragmentName` points to an intended fragment.\n\n\n## Example\nThe following example shows two cases: in the first one, untrusted data is used to instantiate and add a fragment to an activity, while in the second one, a fragment is safely added with a static name.\n\n\n```java\npublic class MyActivity extends FragmentActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstance) {\n        try {\n            super.onCreate(savedInstance);\n            // BAD: Fragment instantiated from user input without validation\n            {\n                String fName = getIntent().getStringExtra(\"fragmentName\");\n                getFragmentManager().beginTransaction().replace(com.android.internal.R.id.prefs,\n                        Fragment.instantiate(this, fName, null)).commit();\n            }\n            // GOOD: Fragment instantiated statically\n            {\n                getFragmentManager().beginTransaction()\n                        .replace(com.android.internal.R.id.prefs, new MyFragment()).commit();\n            }\n        } catch (Exception e) {\n        }\n    }\n\n}\n\n```\nThe next example shows two activities that extend `PreferenceActivity`. The first activity overrides `isValidFragment`, but it wrongly returns `true` unconditionally. The second activity correctly overrides `isValidFragment` so that it only returns `true` when `fragmentName` is a trusted fragment name.\n\n\n```java\nclass UnsafeActivity extends PreferenceActivity {\n\n    @Override\n    protected boolean isValidFragment(String fragmentName) {\n        // BAD: any Fragment name can be provided.\n        return true;\n    }\n}\n\n\nclass SafeActivity extends PreferenceActivity {\n    @Override\n    protected boolean isValidFragment(String fragmentName) {\n        // Good: only trusted Fragment names are allowed.\n        return SafeFragment1.class.getName().equals(fragmentName)\n                || SafeFragment2.class.getName().equals(fragmentName)\n                || SafeFragment3.class.getName().equals(fragmentName);\n    }\n\n}\n\n\n```\n\n## References\n* Google Help: [How to fix Fragment Injection vulnerability](https://support.google.com/faqs/answer/7188427?hl=en).\n* IBM Security Systems: [Android collapses into Fragments](https://securityintelligence.com/wp-content/uploads/2013/12/android-collapses-into-fragments.pdf).\n* Android Developers: [Fragments](https://developer.android.com/guide/fragments)\n* Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).\n"},"properties":{"tags":["security","external/cwe/cwe-470"],"description":"Instantiating an Android fragment from a user-provided value\n              may allow a malicious application to bypass access controls,  exposing the application to unintended effects.","id":"java/android/fragment-injection","kind":"path-problem","name":"Android fragment injection","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"java/android/fragment-injection-preference-activity","name":"java/android/fragment-injection-preference-activity","shortDescription":{"text":"Android fragment injection in PreferenceActivity"},"fullDescription":{"text":"An insecure implementation of the 'isValidFragment' method of the 'PreferenceActivity' class may allow a malicious application to bypass access controls, exposing the application to unintended effects."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Android fragment injection in PreferenceActivity\nWhen fragments are instantiated with externally provided names, this exposes any exported activity that dynamically creates and hosts the fragment to fragment injection. A malicious application could provide the name of an arbitrary fragment, even one not designed to be externally accessible, and inject it into the activity. This can bypass access controls and expose the application to unintended effects.\n\nFragments are reusable parts of an Android application's user interface. Even though a fragment controls its own lifecycle and layout, and handles its input events, it cannot exist on its own: it must be hosted either by an activity or another fragment. This means that, normally, a fragment will be accessible by third-party applications (that is, exported) only if its hosting activity is itself exported.\n\n\n## Recommendation\nIn general, do not instantiate classes (including fragments) with user-provided names unless the name has been properly validated. Also, if an exported activity is extending the `PreferenceActivity` class, make sure that the `isValidFragment` method is overriden and only returns `true` when the provided `fragmentName` points to an intended fragment.\n\n\n## Example\nThe following example shows two cases: in the first one, untrusted data is used to instantiate and add a fragment to an activity, while in the second one, a fragment is safely added with a static name.\n\n\n```java\npublic class MyActivity extends FragmentActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstance) {\n        try {\n            super.onCreate(savedInstance);\n            // BAD: Fragment instantiated from user input without validation\n            {\n                String fName = getIntent().getStringExtra(\"fragmentName\");\n                getFragmentManager().beginTransaction().replace(com.android.internal.R.id.prefs,\n                        Fragment.instantiate(this, fName, null)).commit();\n            }\n            // GOOD: Fragment instantiated statically\n            {\n                getFragmentManager().beginTransaction()\n                        .replace(com.android.internal.R.id.prefs, new MyFragment()).commit();\n            }\n        } catch (Exception e) {\n        }\n    }\n\n}\n\n```\nThe next example shows two activities that extend `PreferenceActivity`. The first activity overrides `isValidFragment`, but it wrongly returns `true` unconditionally. The second activity correctly overrides `isValidFragment` so that it only returns `true` when `fragmentName` is a trusted fragment name.\n\n\n```java\nclass UnsafeActivity extends PreferenceActivity {\n\n    @Override\n    protected boolean isValidFragment(String fragmentName) {\n        // BAD: any Fragment name can be provided.\n        return true;\n    }\n}\n\n\nclass SafeActivity extends PreferenceActivity {\n    @Override\n    protected boolean isValidFragment(String fragmentName) {\n        // Good: only trusted Fragment names are allowed.\n        return SafeFragment1.class.getName().equals(fragmentName)\n                || SafeFragment2.class.getName().equals(fragmentName)\n                || SafeFragment3.class.getName().equals(fragmentName);\n    }\n\n}\n\n\n```\n\n## References\n* Google Help: [How to fix Fragment Injection vulnerability](https://support.google.com/faqs/answer/7188427?hl=en).\n* IBM Security Systems: [Android collapses into Fragments](https://securityintelligence.com/wp-content/uploads/2013/12/android-collapses-into-fragments.pdf).\n* Android Developers: [Fragments](https://developer.android.com/guide/fragments)\n* Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).\n","markdown":"# Android fragment injection in PreferenceActivity\nWhen fragments are instantiated with externally provided names, this exposes any exported activity that dynamically creates and hosts the fragment to fragment injection. A malicious application could provide the name of an arbitrary fragment, even one not designed to be externally accessible, and inject it into the activity. This can bypass access controls and expose the application to unintended effects.\n\nFragments are reusable parts of an Android application's user interface. Even though a fragment controls its own lifecycle and layout, and handles its input events, it cannot exist on its own: it must be hosted either by an activity or another fragment. This means that, normally, a fragment will be accessible by third-party applications (that is, exported) only if its hosting activity is itself exported.\n\n\n## Recommendation\nIn general, do not instantiate classes (including fragments) with user-provided names unless the name has been properly validated. Also, if an exported activity is extending the `PreferenceActivity` class, make sure that the `isValidFragment` method is overriden and only returns `true` when the provided `fragmentName` points to an intended fragment.\n\n\n## Example\nThe following example shows two cases: in the first one, untrusted data is used to instantiate and add a fragment to an activity, while in the second one, a fragment is safely added with a static name.\n\n\n```java\npublic class MyActivity extends FragmentActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstance) {\n        try {\n            super.onCreate(savedInstance);\n            // BAD: Fragment instantiated from user input without validation\n            {\n                String fName = getIntent().getStringExtra(\"fragmentName\");\n                getFragmentManager().beginTransaction().replace(com.android.internal.R.id.prefs,\n                        Fragment.instantiate(this, fName, null)).commit();\n            }\n            // GOOD: Fragment instantiated statically\n            {\n                getFragmentManager().beginTransaction()\n                        .replace(com.android.internal.R.id.prefs, new MyFragment()).commit();\n            }\n        } catch (Exception e) {\n        }\n    }\n\n}\n\n```\nThe next example shows two activities that extend `PreferenceActivity`. The first activity overrides `isValidFragment`, but it wrongly returns `true` unconditionally. The second activity correctly overrides `isValidFragment` so that it only returns `true` when `fragmentName` is a trusted fragment name.\n\n\n```java\nclass UnsafeActivity extends PreferenceActivity {\n\n    @Override\n    protected boolean isValidFragment(String fragmentName) {\n        // BAD: any Fragment name can be provided.\n        return true;\n    }\n}\n\n\nclass SafeActivity extends PreferenceActivity {\n    @Override\n    protected boolean isValidFragment(String fragmentName) {\n        // Good: only trusted Fragment names are allowed.\n        return SafeFragment1.class.getName().equals(fragmentName)\n                || SafeFragment2.class.getName().equals(fragmentName)\n                || SafeFragment3.class.getName().equals(fragmentName);\n    }\n\n}\n\n\n```\n\n## References\n* Google Help: [How to fix Fragment Injection vulnerability](https://support.google.com/faqs/answer/7188427?hl=en).\n* IBM Security Systems: [Android collapses into Fragments](https://securityintelligence.com/wp-content/uploads/2013/12/android-collapses-into-fragments.pdf).\n* Android Developers: [Fragments](https://developer.android.com/guide/fragments)\n* Common Weakness Enumeration: [CWE-470](https://cwe.mitre.org/data/definitions/470.html).\n"},"properties":{"tags":["security","external/cwe/cwe-470"],"description":"An insecure implementation of the 'isValidFragment' method\n              of the 'PreferenceActivity' class may allow a malicious application to bypass access controls,\n              exposing the application to unintended effects.","id":"java/android/fragment-injection-preference-activity","kind":"problem","name":"Android fragment injection in PreferenceActivity","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"java/android/implicit-pendingintents","name":"java/android/implicit-pendingintents","shortDescription":{"text":"Use of implicit PendingIntents"},"fullDescription":{"text":"Sending an implicit and mutable 'PendingIntent' to an unspecified third party component may provide an attacker with access to internal components of the application or cause other unintended effects."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Use of implicit PendingIntents\nA `PendingIntent` is used to wrap an `Intent` that will be supplied and executed by another application. When the `Intent` is executed, it behaves as if it were run directly by the supplying application, using the privileges of that application.\n\nIf a `PendingIntent` is configured to be mutable, the fields of its internal `Intent` can be changed by the receiving application if they were not previously set. This means that a mutable `PendingIntent` that has not defined a destination component (that is, an implicit `PendingIntent`) can be altered to execute an arbitrary action with the privileges of the application that created it.\n\nA malicious application can access an implicit `PendingIntent` as follows:\n\n* It is wrapped and sent as an extra of another implicit `Intent`.\n* It is sent as the action of a `Slide`.\n* It is sent as the action of a `Notification`.\n\n\nOn gaining access, the attacker can modify the underlying `Intent` and execute an arbitrary action with elevated privileges. This could give the malicious application access to private components of the victim application, or the ability to perform actions without having the necessary permissions.\n\n\n## Recommendation\nAvoid creating implicit `PendingIntent`s. This means that the underlying `Intent` should always have an explicit destination component.\n\nWhen you add the `PendingIntent` as an extra of another `Intent`, make sure that this second `Intent` also has an explicit destination component, so that it is not delivered to untrusted applications.\n\nCreate the `PendingIntent` using the flag `FLAG_IMMUTABLE` whenever possible, to prevent the destination component from modifying empty fields of the underlying `Intent`.\n\n\n## Example\nIn the following examples, a `PendingIntent` is created and wrapped as an extra of another `Intent`.\n\nIn the first example, both the `PendingIntent` and the `Intent` it is wrapped in are implicit, making them vulnerable to attack.\n\nIn the second example, the issue is avoided by adding explicit destination components to the `PendingIntent` and the wrapping `Intent`.\n\nThe third example uses the `FLAG_IMMUTABLE` flag to prevent the underlying `Intent` from being modified by the destination component.\n\n\n```java\nimport android.app.Activity;\nimport android.app.PendingIntent;\nimport android.content.Intent;\nimport android.os.Bundle;\n\npublic class ImplicitPendingIntents extends Activity {\n\n\tpublic void onCreate(Bundle savedInstance) {\n\t\t{\n\t\t\t// BAD: an implicit Intent is used to create a PendingIntent.\n\t\t\t// The PendingIntent is then added to another implicit Intent\n\t\t\t// and started.\n\t\t\tIntent baseIntent = new Intent();\n\t\t\tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, baseIntent, PendingIntent.FLAG_ONE_SHOT);\n\t\t\tIntent fwdIntent = new Intent(\"SOME_ACTION\");\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tsendBroadcast(fwdIntent);\n\t\t}\n\n\t\t{\n\t\t\t// GOOD: both the PendingIntent and the wrapping Intent are explicit.\n\t\t\tIntent safeIntent = new Intent(this, AnotherActivity.class);\n\t\t\tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, safeIntent, PendingIntent.FLAG_ONE_SHOT);\n\t\t\tIntent fwdIntent = new Intent();\n\t\t\tfwdIntent.setClassName(\"destination.package\", \"DestinationClass\");\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tstartActivity(fwdIntent);\n\t\t}\n\n\t\t{\n\t\t\t// GOOD: The PendingIntent is created with FLAG_IMMUTABLE.\n\t\t\tIntent baseIntent = new Intent(\"SOME_ACTION\");\n\t\t\tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, baseIntent, PendingIntent.FLAG_IMMUTABLE);\n\t\t\tIntent fwdIntent = new Intent();\n\t\t\tfwdIntent.setClassName(\"destination.package\", \"DestinationClass\");\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tstartActivity(fwdIntent);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Google Help: [ Remediation for Implicit PendingIntent Vulnerability ](https://support.google.com/faqs/answer/10437428?hl=en)\n* University of Potsdam: [ PIAnalyzer: A precise approach for PendingIntent vulnerability analysis ](https://www.cs.uni-potsdam.de/se/papers/esorics18.pdf)\n* Common Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n","markdown":"# Use of implicit PendingIntents\nA `PendingIntent` is used to wrap an `Intent` that will be supplied and executed by another application. When the `Intent` is executed, it behaves as if it were run directly by the supplying application, using the privileges of that application.\n\nIf a `PendingIntent` is configured to be mutable, the fields of its internal `Intent` can be changed by the receiving application if they were not previously set. This means that a mutable `PendingIntent` that has not defined a destination component (that is, an implicit `PendingIntent`) can be altered to execute an arbitrary action with the privileges of the application that created it.\n\nA malicious application can access an implicit `PendingIntent` as follows:\n\n* It is wrapped and sent as an extra of another implicit `Intent`.\n* It is sent as the action of a `Slide`.\n* It is sent as the action of a `Notification`.\n\n\nOn gaining access, the attacker can modify the underlying `Intent` and execute an arbitrary action with elevated privileges. This could give the malicious application access to private components of the victim application, or the ability to perform actions without having the necessary permissions.\n\n\n## Recommendation\nAvoid creating implicit `PendingIntent`s. This means that the underlying `Intent` should always have an explicit destination component.\n\nWhen you add the `PendingIntent` as an extra of another `Intent`, make sure that this second `Intent` also has an explicit destination component, so that it is not delivered to untrusted applications.\n\nCreate the `PendingIntent` using the flag `FLAG_IMMUTABLE` whenever possible, to prevent the destination component from modifying empty fields of the underlying `Intent`.\n\n\n## Example\nIn the following examples, a `PendingIntent` is created and wrapped as an extra of another `Intent`.\n\nIn the first example, both the `PendingIntent` and the `Intent` it is wrapped in are implicit, making them vulnerable to attack.\n\nIn the second example, the issue is avoided by adding explicit destination components to the `PendingIntent` and the wrapping `Intent`.\n\nThe third example uses the `FLAG_IMMUTABLE` flag to prevent the underlying `Intent` from being modified by the destination component.\n\n\n```java\nimport android.app.Activity;\nimport android.app.PendingIntent;\nimport android.content.Intent;\nimport android.os.Bundle;\n\npublic class ImplicitPendingIntents extends Activity {\n\n\tpublic void onCreate(Bundle savedInstance) {\n\t\t{\n\t\t\t// BAD: an implicit Intent is used to create a PendingIntent.\n\t\t\t// The PendingIntent is then added to another implicit Intent\n\t\t\t// and started.\n\t\t\tIntent baseIntent = new Intent();\n\t\t\tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, baseIntent, PendingIntent.FLAG_ONE_SHOT);\n\t\t\tIntent fwdIntent = new Intent(\"SOME_ACTION\");\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tsendBroadcast(fwdIntent);\n\t\t}\n\n\t\t{\n\t\t\t// GOOD: both the PendingIntent and the wrapping Intent are explicit.\n\t\t\tIntent safeIntent = new Intent(this, AnotherActivity.class);\n\t\t\tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, safeIntent, PendingIntent.FLAG_ONE_SHOT);\n\t\t\tIntent fwdIntent = new Intent();\n\t\t\tfwdIntent.setClassName(\"destination.package\", \"DestinationClass\");\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tstartActivity(fwdIntent);\n\t\t}\n\n\t\t{\n\t\t\t// GOOD: The PendingIntent is created with FLAG_IMMUTABLE.\n\t\t\tIntent baseIntent = new Intent(\"SOME_ACTION\");\n\t\t\tPendingIntent pi =\n\t\t\t\t\tPendingIntent.getActivity(this, 0, baseIntent, PendingIntent.FLAG_IMMUTABLE);\n\t\t\tIntent fwdIntent = new Intent();\n\t\t\tfwdIntent.setClassName(\"destination.package\", \"DestinationClass\");\n\t\t\tfwdIntent.putExtra(\"fwdIntent\", pi);\n\t\t\tstartActivity(fwdIntent);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Google Help: [ Remediation for Implicit PendingIntent Vulnerability ](https://support.google.com/faqs/answer/10437428?hl=en)\n* University of Potsdam: [ PIAnalyzer: A precise approach for PendingIntent vulnerability analysis ](https://www.cs.uni-potsdam.de/se/papers/esorics18.pdf)\n* Common Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n"},"properties":{"tags":["security","external/cwe/cwe-927"],"description":"Sending an implicit and mutable 'PendingIntent' to an unspecified third party\n              component may provide an attacker with access to internal components of the\n              application or cause other unintended effects.","id":"java/android/implicit-pendingintents","kind":"path-problem","name":"Use of implicit PendingIntents","precision":"high","problem.severity":"error","security-severity":"8.2"}},{"id":"java/tainted-permissions-check","name":"java/tainted-permissions-check","shortDescription":{"text":"User-controlled data used in permissions check"},"fullDescription":{"text":"Using user-controlled data in a permissions check may result in inappropriate permissions being granted."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# User-controlled data used in permissions check\nUsing user-controlled data in a permissions check may allow a user to gain unauthorized access to protected functionality or data.\n\n\n## Recommendation\nWhen checking whether a user is authorized for a particular activity, do not use data that is controlled by that user in the permissions check. If necessary, always validate the input, ideally against a fixed list of expected values.\n\nSimilarly, do not decide which permission to check for based on user data. In particular, avoid using computation to decide which permissions to check for. Use fixed permissions for particular actions, rather than generating the permission to check for.\n\n\n## Example\nThis example, using the Apache Shiro security framework, shows two ways to specify the permissions to check. The first way uses a string, `whatDoTheyWantToDo`, to specify the permissions to check. However, this string is built from user input. This can allow an attacker to force a check against a permission that they know they have, rather than the permission that should be checked. For example, while trying to access the account details of another user, the attacker could force the system to check whether they had permissions to access their *own* account details, which is incorrect, and would allow them to perform the action. The second, more secure way uses a fixed check that does not depend on data that is controlled by the user.\n\n\n```java\npublic static void main(String[] args) {\n\tString whatDoTheyWantToDo = args[0];\n\tSubject subject = SecurityUtils.getSubject();\n\n\t// BAD: permissions decision made using tainted data\n\tif(subject.isPermitted(\"domain:sublevel:\" + whatDoTheyWantToDo))\n\t\tdoIt();\n\n\t// GOOD: use fixed checks\n\tif(subject.isPermitted(\"domain:sublevel:whatTheMethodDoes\"))\n\t\tdoIt();\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SEC02-J. Do not base security checks on untrusted sources](https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources).\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n","markdown":"# User-controlled data used in permissions check\nUsing user-controlled data in a permissions check may allow a user to gain unauthorized access to protected functionality or data.\n\n\n## Recommendation\nWhen checking whether a user is authorized for a particular activity, do not use data that is controlled by that user in the permissions check. If necessary, always validate the input, ideally against a fixed list of expected values.\n\nSimilarly, do not decide which permission to check for based on user data. In particular, avoid using computation to decide which permissions to check for. Use fixed permissions for particular actions, rather than generating the permission to check for.\n\n\n## Example\nThis example, using the Apache Shiro security framework, shows two ways to specify the permissions to check. The first way uses a string, `whatDoTheyWantToDo`, to specify the permissions to check. However, this string is built from user input. This can allow an attacker to force a check against a permission that they know they have, rather than the permission that should be checked. For example, while trying to access the account details of another user, the attacker could force the system to check whether they had permissions to access their *own* account details, which is incorrect, and would allow them to perform the action. The second, more secure way uses a fixed check that does not depend on data that is controlled by the user.\n\n\n```java\npublic static void main(String[] args) {\n\tString whatDoTheyWantToDo = args[0];\n\tSubject subject = SecurityUtils.getSubject();\n\n\t// BAD: permissions decision made using tainted data\n\tif(subject.isPermitted(\"domain:sublevel:\" + whatDoTheyWantToDo))\n\t\tdoIt();\n\n\t// GOOD: use fixed checks\n\tif(subject.isPermitted(\"domain:sublevel:whatTheMethodDoes\"))\n\t\tdoIt();\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SEC02-J. Do not base security checks on untrusted sources](https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources).\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n"},"properties":{"tags":["security","external/cwe/cwe-807","external/cwe/cwe-290"],"description":"Using user-controlled data in a permissions check may result in inappropriate\n              permissions being granted.","id":"java/tainted-permissions-check","kind":"path-problem","name":"User-controlled data used in permissions check","precision":"high","problem.severity":"error","security-severity":"7.8"}},{"id":"java/unsafe-deserialization","name":"java/unsafe-deserialization","shortDescription":{"text":"Deserialization of user-controlled data"},"fullDescription":{"text":"Deserializing user-controlled data may allow attackers to execute arbitrary code."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Deserialization of user-controlled data\nDeserializing untrusted data using any deserialization framework that allows the construction of arbitrary serializable objects is easily exploitable and in many cases allows an attacker to execute arbitrary code. Even before a deserialized object is returned to the caller of a deserialization method a lot of code may have been executed, including static initializers, constructors, and finalizers. Automatic deserialization of fields means that an attacker may craft a nested combination of objects on which the executed initialization code may have unforeseen effects, such as the execution of arbitrary code.\n\nThere are many different serialization frameworks. This query currently supports Kryo, XmlDecoder, XStream, SnakeYaml, JYaml, JsonIO, YAMLBeans, HessianBurlap, Castor, Burlap, Jackson, Jabsorb, Jodd JSON, Flexjson, Gson, JMS, and Java IO serialization through `ObjectInputStream`/`ObjectOutputStream`.\n\n\n## Recommendation\nAvoid deserialization of untrusted data if at all possible. If the architecture permits it then use other formats instead of serialized objects, for example JSON or XML. However, these formats should not be deserialized into complex objects because this provides further opportunities for attack. For example, XML-based deserialization attacks are possible through libraries such as XStream and XmlDecoder.\n\nAlternatively, a tightly controlled whitelist can limit the vulnerability of code, but be aware of the existence of so-called Bypass Gadgets, which can circumvent such protection measures.\n\nRecommendations specific to particular frameworks supported by this query:\n\n**FastJson** - `com.alibaba:fastjson`\n\n* **Secure by Default**: Partially\n* **Recommendation**: Call `com.alibaba.fastjson.parser.ParserConfig#setSafeMode` with the argument `true` before deserializing untrusted data.\n\n\n**FasterXML** - `com.fasterxml.jackson.core:jackson-databind`\n\n* **Secure by Default**: Yes\n* **Recommendation**: Don't call `com.fasterxml.jackson.databind.ObjectMapper#enableDefaultTyping` and don't annotate any object fields with `com.fasterxml.jackson.annotation.JsonTypeInfo` passing either the `CLASS` or `MINIMAL_CLASS` values to the annotation. Read [this guide](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba).\n\n\n**Kryo** - `com.esotericsoftware:kryo` and `com.esotericsoftware:kryo5`\n\n* **Secure by Default**: Yes for `com.esotericsoftware:kryo5` and for `com.esotericsoftware:kryo` &gt;= v5.0.0\n* **Recommendation**: Don't call `com.esotericsoftware.kryo(5).Kryo#setRegistrationRequired` with the argument `false` on any `Kryo` instance that may deserialize untrusted data.\n\n\n**ObjectInputStream** - `Java Standard Library`\n\n* **Secure by Default**: No\n* **Recommendation**: Use a validating input stream, such as `org.apache.commons.io.serialization.ValidatingObjectInputStream`.\n\n\n**SnakeYAML** - `org.yaml:snakeyaml`\n\n* **Secure by Default**: No\n* **Recommendation**: Pass an instance of `org.yaml.snakeyaml.constructor.SafeConstructor` to `org.yaml.snakeyaml.Yaml`'s constructor before using it to deserialize untrusted data.\n\n\n**XML Decoder** - `Standard Java Library`\n\n* **Secure by Default**: No\n* **Recommendation**: Do not use with untrusted user input.\n\n\n**ObjectMesssage** - `Java EE/Jakarta EE`\n\n* **Secure by Default**: Depends on the JMS implementation.\n* **Recommendation**: Do not use with untrusted user input.\n\n\n\n## Example\nThe following example calls `readObject` directly on an `ObjectInputStream` that is constructed from untrusted data, and is therefore inherently unsafe.\n\n\n```java\npublic MyObject {\n  public int field;\n  MyObject(int field) {\n    this.field = field;\n  }\n}\n\npublic MyObject deserialize(Socket sock) {\n  try(ObjectInputStream in = new ObjectInputStream(sock.getInputStream())) {\n    return (MyObject)in.readObject(); // unsafe\n  }\n}\n\n```\nRewriting the communication protocol to only rely on reading primitive types from the input stream removes the vulnerability.\n\n\n```java\npublic MyObject deserialize(Socket sock) {\n  try(DataInputStream in = new DataInputStream(sock.getInputStream())) {\n    return new MyObject(in.readInt());\n  }\n}\n\n```\n\n## References\n* OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).\n* Talks by Chris Frohoff &amp; Gabriel Lawrence: [ AppSecCali 2015: Marshalling Pickles - how deserializing objects will ruin your day](http://frohoff.github.io/appseccali-marshalling-pickles/), [OWASP SD: Deserialize My Shorts: Or How I Learned to Start Worrying and Hate Java Object Deserialization](http://frohoff.github.io/owaspsd-deserialize-my-shorts/).\n* Alvaro Muñoz &amp; Christian Schneider, RSAConference 2016: [Serial Killer: Silently Pwning Your Java Endpoints](https://speakerdeck.com/pwntester/serial-killer-silently-pwning-your-java-endpoints).\n* SnakeYaml documentation on deserialization: [SnakeYaml deserialization](https://bitbucket.org/snakeyaml/snakeyaml/wiki/Documentation#markdown-header-loading-yaml).\n* Hessian deserialization and related gadget chains: [Hessian deserialization](https://paper.seebug.org/1137/).\n* Castor and Hessian java deserialization vulnerabilities: [Castor and Hessian deserialization](https://securitylab.github.com/research/hessian-java-deserialization-castor-vulnerabilities/).\n* Remote code execution in JYaml library: [JYaml deserialization](https://www.cybersecurity-help.cz/vdb/SB2020022512).\n* JsonIO deserialization vulnerabilities: [JsonIO deserialization](https://klezvirus.github.io/Advanced-Web-Hacking/Serialisation/).\n* Research by Moritz Bechler: [Java Unmarshaller Security - Turning your data into code execution](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)\n* Blog posts by the developer of Jackson libraries: [On Jackson CVEs: Don’t Panic — Here is what you need to know](https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062) [Jackson 2.10: Safe Default Typing](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba)\n* Jabsorb documentation on deserialization: [Jabsorb JSON Serializer](https://github.com/Servoy/jabsorb/blob/master/src/org/jabsorb/).\n* Jodd JSON documentation on deserialization: [JoddJson Parser](https://json.jodd.org/parser).\n* RCE in Flexjson: [Flexjson deserialization](https://codewhitesec.blogspot.com/2020/03/liferay-portal-json-vulns.html).\n* Android Intent deserialization vulnerabilities with GSON parser: [Insecure use of JSON parsers](https://blog.oversecured.com/Exploiting-memory-corruption-vulnerabilities-on-Android/#insecure-use-of-json-parsers).\n* Research by Matthias Kaiser: [Pwning Your Java Messaging With Deserialization Vulnerabilities](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n","markdown":"# Deserialization of user-controlled data\nDeserializing untrusted data using any deserialization framework that allows the construction of arbitrary serializable objects is easily exploitable and in many cases allows an attacker to execute arbitrary code. Even before a deserialized object is returned to the caller of a deserialization method a lot of code may have been executed, including static initializers, constructors, and finalizers. Automatic deserialization of fields means that an attacker may craft a nested combination of objects on which the executed initialization code may have unforeseen effects, such as the execution of arbitrary code.\n\nThere are many different serialization frameworks. This query currently supports Kryo, XmlDecoder, XStream, SnakeYaml, JYaml, JsonIO, YAMLBeans, HessianBurlap, Castor, Burlap, Jackson, Jabsorb, Jodd JSON, Flexjson, Gson, JMS, and Java IO serialization through `ObjectInputStream`/`ObjectOutputStream`.\n\n\n## Recommendation\nAvoid deserialization of untrusted data if at all possible. If the architecture permits it then use other formats instead of serialized objects, for example JSON or XML. However, these formats should not be deserialized into complex objects because this provides further opportunities for attack. For example, XML-based deserialization attacks are possible through libraries such as XStream and XmlDecoder.\n\nAlternatively, a tightly controlled whitelist can limit the vulnerability of code, but be aware of the existence of so-called Bypass Gadgets, which can circumvent such protection measures.\n\nRecommendations specific to particular frameworks supported by this query:\n\n**FastJson** - `com.alibaba:fastjson`\n\n* **Secure by Default**: Partially\n* **Recommendation**: Call `com.alibaba.fastjson.parser.ParserConfig#setSafeMode` with the argument `true` before deserializing untrusted data.\n\n\n**FasterXML** - `com.fasterxml.jackson.core:jackson-databind`\n\n* **Secure by Default**: Yes\n* **Recommendation**: Don't call `com.fasterxml.jackson.databind.ObjectMapper#enableDefaultTyping` and don't annotate any object fields with `com.fasterxml.jackson.annotation.JsonTypeInfo` passing either the `CLASS` or `MINIMAL_CLASS` values to the annotation. Read [this guide](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba).\n\n\n**Kryo** - `com.esotericsoftware:kryo` and `com.esotericsoftware:kryo5`\n\n* **Secure by Default**: Yes for `com.esotericsoftware:kryo5` and for `com.esotericsoftware:kryo` &gt;= v5.0.0\n* **Recommendation**: Don't call `com.esotericsoftware.kryo(5).Kryo#setRegistrationRequired` with the argument `false` on any `Kryo` instance that may deserialize untrusted data.\n\n\n**ObjectInputStream** - `Java Standard Library`\n\n* **Secure by Default**: No\n* **Recommendation**: Use a validating input stream, such as `org.apache.commons.io.serialization.ValidatingObjectInputStream`.\n\n\n**SnakeYAML** - `org.yaml:snakeyaml`\n\n* **Secure by Default**: No\n* **Recommendation**: Pass an instance of `org.yaml.snakeyaml.constructor.SafeConstructor` to `org.yaml.snakeyaml.Yaml`'s constructor before using it to deserialize untrusted data.\n\n\n**XML Decoder** - `Standard Java Library`\n\n* **Secure by Default**: No\n* **Recommendation**: Do not use with untrusted user input.\n\n\n**ObjectMesssage** - `Java EE/Jakarta EE`\n\n* **Secure by Default**: Depends on the JMS implementation.\n* **Recommendation**: Do not use with untrusted user input.\n\n\n\n## Example\nThe following example calls `readObject` directly on an `ObjectInputStream` that is constructed from untrusted data, and is therefore inherently unsafe.\n\n\n```java\npublic MyObject {\n  public int field;\n  MyObject(int field) {\n    this.field = field;\n  }\n}\n\npublic MyObject deserialize(Socket sock) {\n  try(ObjectInputStream in = new ObjectInputStream(sock.getInputStream())) {\n    return (MyObject)in.readObject(); // unsafe\n  }\n}\n\n```\nRewriting the communication protocol to only rely on reading primitive types from the input stream removes the vulnerability.\n\n\n```java\npublic MyObject deserialize(Socket sock) {\n  try(DataInputStream in = new DataInputStream(sock.getInputStream())) {\n    return new MyObject(in.readInt());\n  }\n}\n\n```\n\n## References\n* OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).\n* Talks by Chris Frohoff &amp; Gabriel Lawrence: [ AppSecCali 2015: Marshalling Pickles - how deserializing objects will ruin your day](http://frohoff.github.io/appseccali-marshalling-pickles/), [OWASP SD: Deserialize My Shorts: Or How I Learned to Start Worrying and Hate Java Object Deserialization](http://frohoff.github.io/owaspsd-deserialize-my-shorts/).\n* Alvaro Muñoz &amp; Christian Schneider, RSAConference 2016: [Serial Killer: Silently Pwning Your Java Endpoints](https://speakerdeck.com/pwntester/serial-killer-silently-pwning-your-java-endpoints).\n* SnakeYaml documentation on deserialization: [SnakeYaml deserialization](https://bitbucket.org/snakeyaml/snakeyaml/wiki/Documentation#markdown-header-loading-yaml).\n* Hessian deserialization and related gadget chains: [Hessian deserialization](https://paper.seebug.org/1137/).\n* Castor and Hessian java deserialization vulnerabilities: [Castor and Hessian deserialization](https://securitylab.github.com/research/hessian-java-deserialization-castor-vulnerabilities/).\n* Remote code execution in JYaml library: [JYaml deserialization](https://www.cybersecurity-help.cz/vdb/SB2020022512).\n* JsonIO deserialization vulnerabilities: [JsonIO deserialization](https://klezvirus.github.io/Advanced-Web-Hacking/Serialisation/).\n* Research by Moritz Bechler: [Java Unmarshaller Security - Turning your data into code execution](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)\n* Blog posts by the developer of Jackson libraries: [On Jackson CVEs: Don’t Panic — Here is what you need to know](https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062) [Jackson 2.10: Safe Default Typing](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba)\n* Jabsorb documentation on deserialization: [Jabsorb JSON Serializer](https://github.com/Servoy/jabsorb/blob/master/src/org/jabsorb/).\n* Jodd JSON documentation on deserialization: [JoddJson Parser](https://json.jodd.org/parser).\n* RCE in Flexjson: [Flexjson deserialization](https://codewhitesec.blogspot.com/2020/03/liferay-portal-json-vulns.html).\n* Android Intent deserialization vulnerabilities with GSON parser: [Insecure use of JSON parsers](https://blog.oversecured.com/Exploiting-memory-corruption-vulnerabilities-on-Android/#insecure-use-of-json-parsers).\n* Research by Matthias Kaiser: [Pwning Your Java Messaging With Deserialization Vulnerabilities](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"},"properties":{"tags":["security","external/cwe/cwe-502"],"description":"Deserializing user-controlled data may allow attackers to\n              execute arbitrary code.","id":"java/unsafe-deserialization","kind":"path-problem","name":"Deserialization of user-controlled data","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"java/error-message-exposure","name":"java/error-message-exposure","shortDescription":{"text":"Information exposure through an error message"},"fullDescription":{"text":"Information from an error message propagates to an external user. Error messages can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Information exposure through an error message\nThe error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the error message entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user using the `getMessage()` method. As such, the user is able to see a detailed error message, which may contain sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) {\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// BAD: printing a exception message back to the response\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\t\t\tex.getMessage());\n\t\treturn;\n\t}\n\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// GOOD: log the exception message, and send back a non-revealing response\n\t\tlog(\"Exception occurred\", ex.getMessage);\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\t\t\t\"Exception occurred\");\n\t\treturn;\n\t}\n}\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* CERT Java Coding Standard: [ERR01-J. Do not allow exceptions to expose sensitive information](https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n","markdown":"# Information exposure through an error message\nThe error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the error message entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user using the `getMessage()` method. As such, the user is able to see a detailed error message, which may contain sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) {\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// BAD: printing a exception message back to the response\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\t\t\tex.getMessage());\n\t\treturn;\n\t}\n\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// GOOD: log the exception message, and send back a non-revealing response\n\t\tlog(\"Exception occurred\", ex.getMessage);\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\t\t\t\"Exception occurred\");\n\t\treturn;\n\t}\n}\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* CERT Java Coding Standard: [ERR01-J. Do not allow exceptions to expose sensitive information](https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n"},"properties":{"tags":["security","external/cwe/cwe-209"],"description":"Information from an error message propagates to an external user.\n              Error messages can unintentionally reveal implementation details\n              that are useful to an attacker for developing a subsequent exploit.","id":"java/error-message-exposure","kind":"problem","name":"Information exposure through an error message","precision":"high","problem.severity":"error","security-severity":"5.4"}},{"id":"java/stack-trace-exposure","name":"java/stack-trace-exposure","shortDescription":{"text":"Information exposure through a stack trace"},"fullDescription":{"text":"Information from a stack trace propagates to an external user. Stack traces can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user using the `sendError()` method. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) {\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// BAD: printing a stack trace back to the response\n\t\tex.printStackTrace(response.getWriter());\n\t\treturn;\n\t}\n\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// GOOD: log the stack trace, and send back a non-revealing response\n\t\tlog(\"Exception occurred\", ex);\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\t\t\t\"Exception occurred\");\n\t\treturn;\n\t}\n}\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* CERT Java Coding Standard: [ERR01-J. Do not allow exceptions to expose sensitive information](https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n","markdown":"# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user using the `sendError()` method. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) {\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// BAD: printing a stack trace back to the response\n\t\tex.printStackTrace(response.getWriter());\n\t\treturn;\n\t}\n\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// GOOD: log the stack trace, and send back a non-revealing response\n\t\tlog(\"Exception occurred\", ex);\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\t\t\t\"Exception occurred\");\n\t\treturn;\n\t}\n}\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* CERT Java Coding Standard: [ERR01-J. Do not allow exceptions to expose sensitive information](https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"},"properties":{"tags":["security","external/cwe/cwe-209","external/cwe/cwe-497"],"description":"Information from a stack trace propagates to an external user.\n              Stack traces can unintentionally reveal implementation details\n              that are useful to an attacker for developing a subsequent exploit.","id":"java/stack-trace-exposure","kind":"problem","name":"Information exposure through a stack trace","precision":"high","problem.severity":"error","security-severity":"5.4"}},{"id":"java/jndi-injection","name":"java/jndi-injection","shortDescription":{"text":"JNDI lookup with user-controlled name"},"fullDescription":{"text":"Performing a JNDI lookup with a user-controlled name can lead to the download of an untrusted object and to execution of arbitrary code."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# JNDI lookup with user-controlled name\nThe Java Naming and Directory Interface (JNDI) is a Java API for a directory service that allows Java software clients to discover and look up data and resources (in the form of Java objects) via a name. If the name being used to look up the data is controlled by the user, it can point to a malicious server, which can return an arbitrary object. In the worst case, this can allow remote code execution.\n\n\n## Recommendation\nThe general recommendation is to avoid passing untrusted data to the `InitialContext.lookup ` method. If the name being used to look up the object must be provided by the user, make sure that it's not in the form of an absolute URL or that it's the URL pointing to a trusted server.\n\n\n## Example\nIn the following examples, the code accepts a name from the user, which it uses to look up an object.\n\nIn the first example, the user provided name is used to look up an object.\n\nThe second example validates the name before using it to look up an object.\n\n\n```java\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\n\npublic void jndiLookup(HttpServletRequest request) throws NamingException {\n  String name = request.getParameter(\"name\");\n\n  Hashtable<String, String> env = new Hashtable<String, String>();\n  env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\");\n  env.put(Context.PROVIDER_URL, \"rmi://trusted-server:1099\");\n  InitialContext ctx = new InitialContext(env);\n\n  // BAD: User input used in lookup\n  ctx.lookup(name);\n\n  // GOOD: The name is validated before being used in lookup\n  if (isValid(name)) {\n    ctx.lookup(name);\n  } else {\n    // Reject the request\n  }\n}\n```\n\n## References\n* Oracle: [Java Naming and Directory Interface (JNDI)](https://docs.oracle.com/javase/8/docs/technotes/guides/jndi/).\n* Black Hat materials: [A Journey from JNDI/LDAP Manipulation to Remote Code Execution Dream Land](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf).\n* Veracode: [Exploiting JNDI Injections in Java](https://www.veracode.com/blog/research/exploiting-jndi-injections-java).\n* Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n","markdown":"# JNDI lookup with user-controlled name\nThe Java Naming and Directory Interface (JNDI) is a Java API for a directory service that allows Java software clients to discover and look up data and resources (in the form of Java objects) via a name. If the name being used to look up the data is controlled by the user, it can point to a malicious server, which can return an arbitrary object. In the worst case, this can allow remote code execution.\n\n\n## Recommendation\nThe general recommendation is to avoid passing untrusted data to the `InitialContext.lookup ` method. If the name being used to look up the object must be provided by the user, make sure that it's not in the form of an absolute URL or that it's the URL pointing to a trusted server.\n\n\n## Example\nIn the following examples, the code accepts a name from the user, which it uses to look up an object.\n\nIn the first example, the user provided name is used to look up an object.\n\nThe second example validates the name before using it to look up an object.\n\n\n```java\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\n\npublic void jndiLookup(HttpServletRequest request) throws NamingException {\n  String name = request.getParameter(\"name\");\n\n  Hashtable<String, String> env = new Hashtable<String, String>();\n  env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\");\n  env.put(Context.PROVIDER_URL, \"rmi://trusted-server:1099\");\n  InitialContext ctx = new InitialContext(env);\n\n  // BAD: User input used in lookup\n  ctx.lookup(name);\n\n  // GOOD: The name is validated before being used in lookup\n  if (isValid(name)) {\n    ctx.lookup(name);\n  } else {\n    // Reject the request\n  }\n}\n```\n\n## References\n* Oracle: [Java Naming and Directory Interface (JNDI)](https://docs.oracle.com/javase/8/docs/technotes/guides/jndi/).\n* Black Hat materials: [A Journey from JNDI/LDAP Manipulation to Remote Code Execution Dream Land](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf).\n* Veracode: [Exploiting JNDI Injections in Java](https://www.veracode.com/blog/research/exploiting-jndi-injections-java).\n* Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n"},"properties":{"tags":["security","external/cwe/cwe-074"],"description":"Performing a JNDI lookup with a user-controlled name can lead to the download of an untrusted\n              object and to execution of arbitrary code.","id":"java/jndi-injection","kind":"path-problem","name":"JNDI lookup with user-controlled name","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"java/xslt-injection","name":"java/xslt-injection","shortDescription":{"text":"XSLT transformation with user-controlled stylesheet"},"fullDescription":{"text":"Performing an XSLT transformation with user-controlled stylesheets can lead to information disclosure or execution of arbitrary code."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# XSLT transformation with user-controlled stylesheet\nXSLT (Extensible Stylesheet Language Transformations) is a language for transforming XML documents into other XML documents or other formats. Processing unvalidated XSLT stylesheets can allow attackers to read arbitrary files from the filesystem or to execute arbitrary code.\n\n\n## Recommendation\nThe general recommendation is to not process untrusted XSLT stylesheets. If user-provided stylesheets must be processed, enable the secure processing mode.\n\n\n## Example\nIn the following examples, the code accepts an XSLT stylesheet from the user and processes it.\n\nIn the first example, the user-provided XSLT stylesheet is parsed and processed.\n\nIn the second example, secure processing mode is enabled.\n\n\n```java\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\npublic void transform(Socket socket, String inputXml) throws Exception {\n  StreamSource xslt = new StreamSource(socket.getInputStream());\n  StreamSource xml = new StreamSource(new StringReader(inputXml));\n  StringWriter result = new StringWriter();\n  TransformerFactory factory = TransformerFactory.newInstance();\n\n  // BAD: User provided XSLT stylesheet is processed\n  factory.newTransformer(xslt).transform(xml, new StreamResult(result));\n\n  // GOOD: The secure processing mode is enabled\n  factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n  factory.newTransformer(xslt).transform(xml, new StreamResult(result));\n}  \n```\n\n## References\n* Wikipedia: [XSLT](https://en.wikipedia.org/wiki/XSLT).\n* The Java Tutorials: [Transforming XML Data with XSLT](https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html).\n* [XSLT Injection Basics](https://blog.hunniccyber.com/ektron-cms-remote-code-execution-xslt-transform-injection-java/).\n* Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n","markdown":"# XSLT transformation with user-controlled stylesheet\nXSLT (Extensible Stylesheet Language Transformations) is a language for transforming XML documents into other XML documents or other formats. Processing unvalidated XSLT stylesheets can allow attackers to read arbitrary files from the filesystem or to execute arbitrary code.\n\n\n## Recommendation\nThe general recommendation is to not process untrusted XSLT stylesheets. If user-provided stylesheets must be processed, enable the secure processing mode.\n\n\n## Example\nIn the following examples, the code accepts an XSLT stylesheet from the user and processes it.\n\nIn the first example, the user-provided XSLT stylesheet is parsed and processed.\n\nIn the second example, secure processing mode is enabled.\n\n\n```java\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\npublic void transform(Socket socket, String inputXml) throws Exception {\n  StreamSource xslt = new StreamSource(socket.getInputStream());\n  StreamSource xml = new StreamSource(new StringReader(inputXml));\n  StringWriter result = new StringWriter();\n  TransformerFactory factory = TransformerFactory.newInstance();\n\n  // BAD: User provided XSLT stylesheet is processed\n  factory.newTransformer(xslt).transform(xml, new StreamResult(result));\n\n  // GOOD: The secure processing mode is enabled\n  factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n  factory.newTransformer(xslt).transform(xml, new StreamResult(result));\n}  \n```\n\n## References\n* Wikipedia: [XSLT](https://en.wikipedia.org/wiki/XSLT).\n* The Java Tutorials: [Transforming XML Data with XSLT](https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html).\n* [XSLT Injection Basics](https://blog.hunniccyber.com/ektron-cms-remote-code-execution-xslt-transform-injection-java/).\n* Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n"},"properties":{"tags":["security","external/cwe/cwe-074"],"description":"Performing an XSLT transformation with user-controlled stylesheets can lead to\n              information disclosure or execution of arbitrary code.","id":"java/xslt-injection","kind":"path-problem","name":"XSLT transformation with user-controlled stylesheet","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"java/unsafe-hostname-verification","name":"java/unsafe-hostname-verification","shortDescription":{"text":"Unsafe hostname verification"},"fullDescription":{"text":"Marking a certificate as valid for a host without checking the certificate hostname allows an attacker to perform a machine-in-the-middle attack."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Unsafe hostname verification\nIf a `HostnameVerifier` always returns `true` it will not verify the hostname at all. This stops Transport Layer Security (TLS) providing any security and allows an attacker to perform a man-in-the-middle attack against the application.\n\nAn attack might look like this:\n\n1. The program connects to `https://example.com`.\n1. The attacker intercepts this connection and presents an apparently-valid certificate of their choosing.\n1. The `TrustManager` of the program verifies that the certificate has been issued by a trusted certificate authority.\n1. The Java HTTPS library checks whether the certificate has been issued for the host `example.com`. This check fails because the certificate has been issued for a domain controlled by the attacker, for example: `malicious.domain`.\n1. The HTTPS library wants to reject the certificate because the hostname does not match. Before doing this it checks whether a `HostnameVerifier` exists.\n1. Your `HostnameVerifier` is called which returns `true` for any certificate so also for this one.\n1. The program proceeds with the connection since your `HostnameVerifier` accepted it.\n1. The attacker can now read the data your program sends to `https://example.com` and/or alter its replies while the program thinks the connection is secure.\n\n## Recommendation\nDo not use an open `HostnameVerifier`. If you have a configuration problem with TLS/HTTPS, you should always solve the configuration problem instead of using an open verifier.\n\n\n## Example\nIn the first (bad) example, the `HostnameVerifier` always returns `true`. This allows an attacker to perform a man-in-the-middle attack, because any certificate is accepted despite an incorrect hostname. In the second (good) example, the `HostnameVerifier` only returns `true` when the certificate has been correctly checked.\n\n\n```java\npublic static void main(String[] args) {\n\n\t{\n\t\tHostnameVerifier verifier = new HostnameVerifier() {\n\t\t\t@Override\n\t\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\t\treturn true; // BAD: accept even if the hostname doesn't match\n\t\t\t}\n\t\t};\n\t\tHttpsURLConnection.setDefaultHostnameVerifier(verifier);\n\t}\n\n\t{\n\t\tHostnameVerifier verifier = new HostnameVerifier() {\n\t\t\t@Override\n\t\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\t\ttry { // GOOD: verify the certificate\n\t\t\t\t\tCertificate[] certs = session.getPeerCertificates();\n\t\t\t\t\tX509Certificate x509 = (X509Certificate) certs[0];\n\t\t\t\t\tcheck(new String[]{host}, x509);\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (SSLException e) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tHttpsURLConnection.setDefaultHostnameVerifier(verifier);\n\t}\n\n}\n```\n\n## References\n* Android developers: [Security with HTTPS and SSL](https://developer.android.com/training/articles/security-ssl).\n* Terse systems blog: [Fixing Hostname Verification](https://tersesystems.com/blog/2014/03/23/fixing-hostname-verification/).\n* Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n","markdown":"# Unsafe hostname verification\nIf a `HostnameVerifier` always returns `true` it will not verify the hostname at all. This stops Transport Layer Security (TLS) providing any security and allows an attacker to perform a man-in-the-middle attack against the application.\n\nAn attack might look like this:\n\n1. The program connects to `https://example.com`.\n1. The attacker intercepts this connection and presents an apparently-valid certificate of their choosing.\n1. The `TrustManager` of the program verifies that the certificate has been issued by a trusted certificate authority.\n1. The Java HTTPS library checks whether the certificate has been issued for the host `example.com`. This check fails because the certificate has been issued for a domain controlled by the attacker, for example: `malicious.domain`.\n1. The HTTPS library wants to reject the certificate because the hostname does not match. Before doing this it checks whether a `HostnameVerifier` exists.\n1. Your `HostnameVerifier` is called which returns `true` for any certificate so also for this one.\n1. The program proceeds with the connection since your `HostnameVerifier` accepted it.\n1. The attacker can now read the data your program sends to `https://example.com` and/or alter its replies while the program thinks the connection is secure.\n\n## Recommendation\nDo not use an open `HostnameVerifier`. If you have a configuration problem with TLS/HTTPS, you should always solve the configuration problem instead of using an open verifier.\n\n\n## Example\nIn the first (bad) example, the `HostnameVerifier` always returns `true`. This allows an attacker to perform a man-in-the-middle attack, because any certificate is accepted despite an incorrect hostname. In the second (good) example, the `HostnameVerifier` only returns `true` when the certificate has been correctly checked.\n\n\n```java\npublic static void main(String[] args) {\n\n\t{\n\t\tHostnameVerifier verifier = new HostnameVerifier() {\n\t\t\t@Override\n\t\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\t\treturn true; // BAD: accept even if the hostname doesn't match\n\t\t\t}\n\t\t};\n\t\tHttpsURLConnection.setDefaultHostnameVerifier(verifier);\n\t}\n\n\t{\n\t\tHostnameVerifier verifier = new HostnameVerifier() {\n\t\t\t@Override\n\t\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\t\ttry { // GOOD: verify the certificate\n\t\t\t\t\tCertificate[] certs = session.getPeerCertificates();\n\t\t\t\t\tX509Certificate x509 = (X509Certificate) certs[0];\n\t\t\t\t\tcheck(new String[]{host}, x509);\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (SSLException e) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tHttpsURLConnection.setDefaultHostnameVerifier(verifier);\n\t}\n\n}\n```\n\n## References\n* Android developers: [Security with HTTPS and SSL](https://developer.android.com/training/articles/security-ssl).\n* Terse systems blog: [Fixing Hostname Verification](https://tersesystems.com/blog/2014/03/23/fixing-hostname-verification/).\n* Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n"},"properties":{"tags":["security","external/cwe/cwe-297"],"description":"Marking a certificate as valid for a host without checking the certificate hostname allows an attacker to perform a machine-in-the-middle attack.","id":"java/unsafe-hostname-verification","kind":"path-problem","name":"Unsafe hostname verification","precision":"high","problem.severity":"error","security-severity":"5.9"}},{"id":"java/android/unsafe-content-uri-resolution","name":"java/android/unsafe-content-uri-resolution","shortDescription":{"text":"Uncontrolled data used in content resolution"},"fullDescription":{"text":"Resolving externally-provided content URIs without validation can allow an attacker to access unexpected resources."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Uncontrolled data used in content resolution\nWhen an Android application wants to access data in a content provider, it uses the `ContentResolver` object. `ContentResolver`s communicate with an instance of a class that implements the `ContentProvider` interface via URIs with the `content://` scheme. The authority part (the first path segment) of the URI, passed as parameter to the `ContentResolver`, determines which content provider is contacted for the operation. Specific operations that act on files also support the `file://` scheme, in which case the local filesystem is queried instead. If an external component, like a malicious or compromised application, controls the URI for a `ContentResolver` operation, it can trick the vulnerable application into accessing its own private files or non-exported content providers. The attacking application might be able to get access to the file by forcing it to be copied to a public directory, like external storage, or tamper with the contents by making the application overwrite the file with unexpected data.\n\n\n## Recommendation\nIf possible, avoid using externally-provided data to determine the URI for a `ContentResolver` to use. If that is not an option, validate that the incoming URI can only reference trusted components, like an allow list of content providers and/or applications, or alternatively make sure that the URI does not reference private directories like `/data/`.\n\n\n## Example\nThis example shows three ways of opening a file using a `ContentResolver`. In the first case, externally-provided data from an intent is used directly in the file-reading operation. This allows an attacker to provide a URI of the form `/data/data/(vulnerable app package)/(private file)` to trick the application into reading it and copying it to the external storage. In the second case, an insufficient check is performed on the externally-provided URI, still leaving room for exploitation. In the third case, the URI is correctly validated before being used, making sure it does not reference any internal application files.\n\n\n```java\nimport android.content.ContentResolver;\nimport android.net.Uri;\n\npublic class Example extends Activity {\n    public void onCreate() {\n        // BAD: Externally-provided URI directly used in content resolution\n        {\n            ContentResolver contentResolver = getContentResolver();\n            Uri uri = (Uri) getIntent().getParcelableExtra(\"URI_EXTRA\");\n            InputStream is = contentResolver.openInputStream(uri);\n            copyToExternalCache(is);\n        }\n        // BAD: input URI is not normalized, and check can be bypassed with \"..\" characters\n        {\n            ContentResolver contentResolver = getContentResolver();\n            Uri uri = (Uri) getIntent().getParcelableExtra(\"URI_EXTRA\");\n            String path = uri.getPath();\n            if (path.startsWith(\"/data\"))\n                throw new SecurityException();\n            InputStream is = contentResolver.openInputStream(uri);\n            copyToExternalCache(is);\n        }\n        // GOOD: URI is properly validated to block access to internal files\n        {\n            ContentResolver contentResolver = getContentResolver();\n            Uri uri = (Uri) getIntent().getParcelableExtra(\"URI_EXTRA\");\n            String path = uri.getPath();\n            java.nio.file.Path normalized =\n                    java.nio.file.FileSystems.getDefault().getPath(path).normalize();\n            if (normalized.startsWith(\"/data\"))\n                throw new SecurityException();\n            InputStream is = contentResolver.openInputStream(uri);\n            copyToExternalCache(is);\n        }\n    }\n\n    private void copyToExternalCache(InputStream is) {\n        // Reads the contents of is and writes a file in the app's external\n        // cache directory, which can be read publicly by applications in the same device.\n    }\n}\n\n```\n\n## References\n* Android developers: [Content provider basics](https://developer.android.com/guide/topics/providers/content-provider-basics)\n* [The ContentResolver class](https://developer.android.com/reference/android/content/ContentResolver)\n* Common Weakness Enumeration: [CWE-441](https://cwe.mitre.org/data/definitions/441.html).\n* Common Weakness Enumeration: [CWE-610](https://cwe.mitre.org/data/definitions/610.html).\n","markdown":"# Uncontrolled data used in content resolution\nWhen an Android application wants to access data in a content provider, it uses the `ContentResolver` object. `ContentResolver`s communicate with an instance of a class that implements the `ContentProvider` interface via URIs with the `content://` scheme. The authority part (the first path segment) of the URI, passed as parameter to the `ContentResolver`, determines which content provider is contacted for the operation. Specific operations that act on files also support the `file://` scheme, in which case the local filesystem is queried instead. If an external component, like a malicious or compromised application, controls the URI for a `ContentResolver` operation, it can trick the vulnerable application into accessing its own private files or non-exported content providers. The attacking application might be able to get access to the file by forcing it to be copied to a public directory, like external storage, or tamper with the contents by making the application overwrite the file with unexpected data.\n\n\n## Recommendation\nIf possible, avoid using externally-provided data to determine the URI for a `ContentResolver` to use. If that is not an option, validate that the incoming URI can only reference trusted components, like an allow list of content providers and/or applications, or alternatively make sure that the URI does not reference private directories like `/data/`.\n\n\n## Example\nThis example shows three ways of opening a file using a `ContentResolver`. In the first case, externally-provided data from an intent is used directly in the file-reading operation. This allows an attacker to provide a URI of the form `/data/data/(vulnerable app package)/(private file)` to trick the application into reading it and copying it to the external storage. In the second case, an insufficient check is performed on the externally-provided URI, still leaving room for exploitation. In the third case, the URI is correctly validated before being used, making sure it does not reference any internal application files.\n\n\n```java\nimport android.content.ContentResolver;\nimport android.net.Uri;\n\npublic class Example extends Activity {\n    public void onCreate() {\n        // BAD: Externally-provided URI directly used in content resolution\n        {\n            ContentResolver contentResolver = getContentResolver();\n            Uri uri = (Uri) getIntent().getParcelableExtra(\"URI_EXTRA\");\n            InputStream is = contentResolver.openInputStream(uri);\n            copyToExternalCache(is);\n        }\n        // BAD: input URI is not normalized, and check can be bypassed with \"..\" characters\n        {\n            ContentResolver contentResolver = getContentResolver();\n            Uri uri = (Uri) getIntent().getParcelableExtra(\"URI_EXTRA\");\n            String path = uri.getPath();\n            if (path.startsWith(\"/data\"))\n                throw new SecurityException();\n            InputStream is = contentResolver.openInputStream(uri);\n            copyToExternalCache(is);\n        }\n        // GOOD: URI is properly validated to block access to internal files\n        {\n            ContentResolver contentResolver = getContentResolver();\n            Uri uri = (Uri) getIntent().getParcelableExtra(\"URI_EXTRA\");\n            String path = uri.getPath();\n            java.nio.file.Path normalized =\n                    java.nio.file.FileSystems.getDefault().getPath(path).normalize();\n            if (normalized.startsWith(\"/data\"))\n                throw new SecurityException();\n            InputStream is = contentResolver.openInputStream(uri);\n            copyToExternalCache(is);\n        }\n    }\n\n    private void copyToExternalCache(InputStream is) {\n        // Reads the contents of is and writes a file in the app's external\n        // cache directory, which can be read publicly by applications in the same device.\n    }\n}\n\n```\n\n## References\n* Android developers: [Content provider basics](https://developer.android.com/guide/topics/providers/content-provider-basics)\n* [The ContentResolver class](https://developer.android.com/reference/android/content/ContentResolver)\n* Common Weakness Enumeration: [CWE-441](https://cwe.mitre.org/data/definitions/441.html).\n* Common Weakness Enumeration: [CWE-610](https://cwe.mitre.org/data/definitions/610.html).\n"},"properties":{"tags":["security","external/cwe/cwe-441","external/cwe/cwe-610"],"description":"Resolving externally-provided content URIs without validation can allow an attacker\n              to access unexpected resources.","id":"java/android/unsafe-content-uri-resolution","kind":"path-problem","name":"Uncontrolled data used in content resolution","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/unvalidated-url-forward","name":"java/unvalidated-url-forward","shortDescription":{"text":"URL forward from a remote source"},"fullDescription":{"text":"URL forward based on unvalidated user input may cause file information disclosure."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# URL forward from a remote source\nDirectly incorporating user input into a URL forward request without validating the input can cause file information disclosure by allowing an attacker to access unauthorized URLs.\n\n\n## Recommendation\nTo guard against untrusted URL forwarding, you should avoid putting user input directly into a forwarded URL. Instead, you should maintain a list of authorized URLs on the server, then choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL forward without validating the input, which may cause file information disclosure. It also shows how to remedy the problem by validating the user input against a known fixed string.\n\n\n```java\npublic class UrlForward extends HttpServlet {\n\tprivate static final String VALID_FORWARD = \"https://cwe.mitre.org/data/definitions/552.html\";\n\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tServletConfig cfg = getServletConfig();\n\t\tServletContext sc = cfg.getServletContext();\n\n\t\t// BAD: a request parameter is incorporated without validation into a URL forward\n\t\tsc.getRequestDispatcher(request.getParameter(\"target\")).forward(request, response);\n\n\t\t// GOOD: the request parameter is validated against a known fixed string\n\t\tif (VALID_FORWARD.equals(request.getParameter(\"target\"))) {\n\t\t\tsc.getRequestDispatcher(VALID_FORWARD).forward(request, response);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* OWASP: [Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-552](https://cwe.mitre.org/data/definitions/552.html).\n","markdown":"# URL forward from a remote source\nDirectly incorporating user input into a URL forward request without validating the input can cause file information disclosure by allowing an attacker to access unauthorized URLs.\n\n\n## Recommendation\nTo guard against untrusted URL forwarding, you should avoid putting user input directly into a forwarded URL. Instead, you should maintain a list of authorized URLs on the server, then choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL forward without validating the input, which may cause file information disclosure. It also shows how to remedy the problem by validating the user input against a known fixed string.\n\n\n```java\npublic class UrlForward extends HttpServlet {\n\tprivate static final String VALID_FORWARD = \"https://cwe.mitre.org/data/definitions/552.html\";\n\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tServletConfig cfg = getServletConfig();\n\t\tServletContext sc = cfg.getServletContext();\n\n\t\t// BAD: a request parameter is incorporated without validation into a URL forward\n\t\tsc.getRequestDispatcher(request.getParameter(\"target\")).forward(request, response);\n\n\t\t// GOOD: the request parameter is validated against a known fixed string\n\t\tif (VALID_FORWARD.equals(request.getParameter(\"target\"))) {\n\t\t\tsc.getRequestDispatcher(VALID_FORWARD).forward(request, response);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* OWASP: [Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-552](https://cwe.mitre.org/data/definitions/552.html).\n"},"properties":{"tags":["security","external/cwe/cwe-552"],"description":"URL forward based on unvalidated user input\n              may cause file information disclosure.","id":"java/unvalidated-url-forward","kind":"path-problem","name":"URL forward from a remote source","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"java/polynomial-redos","name":"java/polynomial-redos","shortDescription":{"text":"Polynomial regular expression used on uncontrolled data"},"fullDescription":{"text":"A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\nNote that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```java\n\nPattern.compile(\"^\\\\s+|\\\\s+$\").matcher(text).replaceAll(\"\") // BAD\n```\nThe sub-expression `\"\\\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`\"^\\\\s+|(?<!\\\\s)\\\\s+$\"`), or just by using the built-in trim method (`text.trim()`).\n\nNote that the sub-expression `\"^\\\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```java\n\n\"^0\\\\.\\\\d+E?\\\\d+$\"\" \n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `\"^0\\\\.\\\\d+(E\\\\d+)?$\"`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```java\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```java\n\nif (str.length() > 1000) {\n    throw new IllegalArgumentException(\"Input too long\");\n}\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n","markdown":"# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\nNote that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```java\n\nPattern.compile(\"^\\\\s+|\\\\s+$\").matcher(text).replaceAll(\"\") // BAD\n```\nThe sub-expression `\"\\\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`\"^\\\\s+|(?<!\\\\s)\\\\s+$\"`), or just by using the built-in trim method (`text.trim()`).\n\nNote that the sub-expression `\"^\\\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```java\n\n\"^0\\\\.\\\\d+E?\\\\d+$\"\" \n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `\"^0\\\\.\\\\d+(E\\\\d+)?$\"`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```java\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```java\n\nif (str.length() > 1000) {\n    throw new IllegalArgumentException(\"Input too long\");\n}\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"},"properties":{"tags":["security","external/cwe/cwe-1333","external/cwe/cwe-730","external/cwe/cwe-400"],"description":"A regular expression that can require polynomial time\n              to match may be vulnerable to denial-of-service attacks.","id":"java/polynomial-redos","kind":"path-problem","name":"Polynomial regular expression used on uncontrolled data","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/redos","name":"java/redos","shortDescription":{"text":"Inefficient regular expression"},"fullDescription":{"text":"A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Inefficient regular expression\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\nNote that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.\n\n\n## Example\nConsider this regular expression:\n\n```java\n\n^_(__|.)+_$\n```\nIts sub-expression `\"(__|.)+?\"` can match the string `\"__\"` either by the first alternative `\"__\"` to the left of the `\"|\"` operator, or by two repetitions of the second alternative `\".\"` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.\n\nThis problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:\n\n```java\n\n^_(__|[^_])+_$\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n","markdown":"# Inefficient regular expression\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\nNote that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.\n\n\n## Example\nConsider this regular expression:\n\n```java\n\n^_(__|.)+_$\n```\nIts sub-expression `\"(__|.)+?\"` can match the string `\"__\"` either by the first alternative `\"__\"` to the left of the `\"|\"` operator, or by two repetitions of the second alternative `\".\"` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.\n\nThis problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:\n\n```java\n\n^_(__|[^_])+_$\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"},"properties":{"tags":["security","external/cwe/cwe-1333","external/cwe/cwe-730","external/cwe/cwe-400"],"description":"A regular expression that requires exponential time to match certain inputs\n              can be a performance bottleneck, and may be vulnerable to denial-of-service\n              attacks.","id":"java/redos","kind":"problem","name":"Inefficient regular expression","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"java/regex-injection","name":"java/regex-injection","shortDescription":{"text":"Regular expression injection"},"fullDescription":{"text":"User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to provide a regex that could require exponential time on certain inputs."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nBefore embedding user input into a regular expression, use a sanitization function such as `Pattern.quote` to escape meta-characters that have special meaning.\n\n\n## Example\nThe following example shows an HTTP request parameter that is used to construct a regular expression.\n\nIn the first case the user-provided regex is not escaped. If a malicious user provides a regex whose worst-case performance is exponential, then this could lead to a Denial of Service.\n\nIn the second case, the user input is escaped using `Pattern.quote` before being included in the regular expression. This ensures that the user cannot insert characters which have a special meaning in regular expressions.\n\n\n```java\nimport java.util.regex.Pattern;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class RegexInjectionDemo extends HttpServlet {\n\n  public boolean badExample(javax.servlet.http.HttpServletRequest request) {\n    String regex = request.getParameter(\"regex\");\n    String input = request.getParameter(\"input\");\n\n    // BAD: Unsanitized user input is used to construct a regular expression\n    return input.matches(regex);\n  }\n\n  public boolean goodExample(javax.servlet.http.HttpServletRequest request) {\n    String regex = request.getParameter(\"regex\");\n    String input = request.getParameter(\"input\");\n\n    // GOOD: User input is sanitized before constructing the regex\n    return input.matches(Pattern.quote(regex));\n  }\n}\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Java API Specification: [Pattern.quote](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html#quote(java.lang.String)).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n","markdown":"# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nBefore embedding user input into a regular expression, use a sanitization function such as `Pattern.quote` to escape meta-characters that have special meaning.\n\n\n## Example\nThe following example shows an HTTP request parameter that is used to construct a regular expression.\n\nIn the first case the user-provided regex is not escaped. If a malicious user provides a regex whose worst-case performance is exponential, then this could lead to a Denial of Service.\n\nIn the second case, the user input is escaped using `Pattern.quote` before being included in the regular expression. This ensures that the user cannot insert characters which have a special meaning in regular expressions.\n\n\n```java\nimport java.util.regex.Pattern;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class RegexInjectionDemo extends HttpServlet {\n\n  public boolean badExample(javax.servlet.http.HttpServletRequest request) {\n    String regex = request.getParameter(\"regex\");\n    String input = request.getParameter(\"input\");\n\n    // BAD: Unsanitized user input is used to construct a regular expression\n    return input.matches(regex);\n  }\n\n  public boolean goodExample(javax.servlet.http.HttpServletRequest request) {\n    String regex = request.getParameter(\"regex\");\n    String input = request.getParameter(\"input\");\n\n    // GOOD: User input is sanitized before constructing the regex\n    return input.matches(Pattern.quote(regex));\n  }\n}\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Java API Specification: [Pattern.quote](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html#quote(java.lang.String)).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"},"properties":{"tags":["security","external/cwe/cwe-730","external/cwe/cwe-400"],"description":"User input should not be used in regular expressions without first being escaped,\n              otherwise a malicious user may be able to provide a regex that could require\n              exponential time on certain inputs.","id":"java/regex-injection","kind":"path-problem","name":"Regular expression injection","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"java/weak-cryptographic-algorithm","name":"java/weak-cryptographic-algorithm","shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"},"fullDescription":{"text":"Using broken or weak cryptographic algorithms can allow an attacker to compromise security."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of a broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048. Do not use the ECB encryption mode since it is vulnerable to replay and other attacks.\n\n\n## Example\nThe following code shows an example of using a java `Cipher` to encrypt some data. When creating a `Cipher` instance, you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```java\n// BAD: DES is a weak algorithm \nCipher des = Cipher.getInstance(\"DES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n\nbyte[] encrypted = cipher.doFinal(input.getBytes(\"UTF-8\"));\n\n// ...\n\n// GOOD: AES is a strong algorithm\nCipher aes = Cipher.getInstance(\"AES\");\n\n// ...\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n","markdown":"# Use of a broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048. Do not use the ECB encryption mode since it is vulnerable to replay and other attacks.\n\n\n## Example\nThe following code shows an example of using a java `Cipher` to encrypt some data. When creating a `Cipher` instance, you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```java\n// BAD: DES is a weak algorithm \nCipher des = Cipher.getInstance(\"DES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n\nbyte[] encrypted = cipher.doFinal(input.getBytes(\"UTF-8\"));\n\n// ...\n\n// GOOD: AES is a strong algorithm\nCipher aes = Cipher.getInstance(\"AES\");\n\n// ...\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n"},"properties":{"tags":["security","external/cwe/cwe-327","external/cwe/cwe-328"],"description":"Using broken or weak cryptographic algorithms can allow an attacker to compromise security.","id":"java/weak-cryptographic-algorithm","kind":"path-problem","name":"Use of a broken or risky cryptographic algorithm","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/cleartext-storage-in-cookie","name":"java/cleartext-storage-in-cookie","shortDescription":{"text":"Cleartext storage of sensitive information in cookie"},"fullDescription":{"text":"Storing sensitive information in cleartext can expose it to an attacker."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Cleartext storage of sensitive information in cookie\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. It may be wise to encrypt information before it is put into a heap data structure (such as `Java.util.Properties`) that may be written to disk later. Objects that are serializable or marshallable should also always contain encrypted information unless you are certain that they are not ever going to be serialized.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a cookie. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are hashed before storing them.\n\n\n```java\npublic static void main(String[] args) {\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"BP@ssw0rd\".toCharArray());\n\t\tdata = credentials.getUserName() + \":\" + new String(credentials.getPassword());\n\t\n\t\t// BAD: store data in a cookie in cleartext form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n\t\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"GP@ssw0rd\".toCharArray());\n\t\tString salt = \"ThisIsMySalt\";\n\t\tMessageDigest messageDigest = MessageDigest.getInstance(\"SHA-512\");\n\t\tmessageDigest.reset();\n\t\tString credentialsToHash =\n\t\t\t\tcredentials.getUserName() + \":\" + credentials.getPassword();\n\t\tbyte[] hashedCredsAsBytes =\n\t\t\t\tmessageDigest.digest((salt+credentialsToHash).getBytes(\"UTF-8\"));\n\t\tdata = bytesToString(hashedCredsAsBytes);\n\t\t\n\t\t// GOOD: store data in a cookie in encrypted form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n","markdown":"# Cleartext storage of sensitive information in cookie\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. It may be wise to encrypt information before it is put into a heap data structure (such as `Java.util.Properties`) that may be written to disk later. Objects that are serializable or marshallable should also always contain encrypted information unless you are certain that they are not ever going to be serialized.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a cookie. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are hashed before storing them.\n\n\n```java\npublic static void main(String[] args) {\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"BP@ssw0rd\".toCharArray());\n\t\tdata = credentials.getUserName() + \":\" + new String(credentials.getPassword());\n\t\n\t\t// BAD: store data in a cookie in cleartext form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n\t\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"GP@ssw0rd\".toCharArray());\n\t\tString salt = \"ThisIsMySalt\";\n\t\tMessageDigest messageDigest = MessageDigest.getInstance(\"SHA-512\");\n\t\tmessageDigest.reset();\n\t\tString credentialsToHash =\n\t\t\t\tcredentials.getUserName() + \":\" + credentials.getPassword();\n\t\tbyte[] hashedCredsAsBytes =\n\t\t\t\tmessageDigest.digest((salt+credentialsToHash).getBytes(\"UTF-8\"));\n\t\tdata = bytesToString(hashedCredsAsBytes);\n\t\t\n\t\t// GOOD: store data in a cookie in encrypted form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n"},"properties":{"tags":["security","external/cwe/cwe-315"],"description":"Storing sensitive information in cleartext can expose it to an attacker.","id":"java/cleartext-storage-in-cookie","kind":"problem","name":"Cleartext storage of sensitive information in cookie","precision":"high","problem.severity":"error","security-severity":"5.0"}},{"id":"java/android/backup-enabled","name":"java/android/backup-enabled","shortDescription":{"text":"Application backup allowed"},"fullDescription":{"text":"Allowing application backups may allow an attacker to extract sensitive data."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Application backup allowed\nIn the Android manifest file, you can use the `android:allowBackup` attribute of the `application` element to define whether the application will have automatic backups or not.\n\nIf your application uses any sensitive data, you should disable automatic backups to prevent attackers from extracting it.\n\n\n## Recommendation\nFor Android applications which process sensitive data, set `android:allowBackup` to `false` in the manifest file.\n\nNote: Since Android 6.0 (Marshmallow), automatic backups for applications are switched on by default.\n\n\n## Example\nIn the following two (bad) examples, the `android:allowBackup` setting is enabled:\n\n\n```xml\n<manifest ... >\n    <!-- BAD: 'android:allowBackup' set to 'true' -->\n    <application\n        android:allowBackup=\"true\">\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\n\n```xml\n<manifest ... >\n    <!-- BAD: no 'android:allowBackup' set, defaults to 'true' -->\n    <application>\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\nIn the following (good) example, `android:allowBackup` is set to `false`:\n\n\n```xml\n<manifest ... >\n    <!-- GOOD: 'android:allowBackup' set to 'false' -->\n    <application\n        android:allowBackup=\"false\">\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\n\n## References\n* Android Documentation: [Back up user data with Auto Backup](https://developer.android.com/guide/topics/data/autobackup#EnablingAutoBackup)\n* OWASP Mobile Security Testing Guide: [ Android Backups ](https://github.com/OWASP/owasp-mstg/blob/b7a93a2e5e0557cc9a12e55fc3f6675f6986bb86/Document/0x05d-Testing-Data-Storage.md#backups)\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n","markdown":"# Application backup allowed\nIn the Android manifest file, you can use the `android:allowBackup` attribute of the `application` element to define whether the application will have automatic backups or not.\n\nIf your application uses any sensitive data, you should disable automatic backups to prevent attackers from extracting it.\n\n\n## Recommendation\nFor Android applications which process sensitive data, set `android:allowBackup` to `false` in the manifest file.\n\nNote: Since Android 6.0 (Marshmallow), automatic backups for applications are switched on by default.\n\n\n## Example\nIn the following two (bad) examples, the `android:allowBackup` setting is enabled:\n\n\n```xml\n<manifest ... >\n    <!-- BAD: 'android:allowBackup' set to 'true' -->\n    <application\n        android:allowBackup=\"true\">\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\n\n```xml\n<manifest ... >\n    <!-- BAD: no 'android:allowBackup' set, defaults to 'true' -->\n    <application>\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\nIn the following (good) example, `android:allowBackup` is set to `false`:\n\n\n```xml\n<manifest ... >\n    <!-- GOOD: 'android:allowBackup' set to 'false' -->\n    <application\n        android:allowBackup=\"false\">\n        <activity ... >\n        </activity>\n    </application>\n</manifest>\n\n```\n\n## References\n* Android Documentation: [Back up user data with Auto Backup](https://developer.android.com/guide/topics/data/autobackup#EnablingAutoBackup)\n* OWASP Mobile Security Testing Guide: [ Android Backups ](https://github.com/OWASP/owasp-mstg/blob/b7a93a2e5e0557cc9a12e55fc3f6675f6986bb86/Document/0x05d-Testing-Data-Storage.md#backups)\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"},"properties":{"tags":["security","external/cwe/cwe-312"],"description":"Allowing application backups may allow an attacker to extract sensitive data.","id":"java/android/backup-enabled","kind":"problem","name":"Application backup allowed","precision":"very-high","problem.severity":"recommendation","security-severity":"7.5"}},{"id":"java/partial-path-traversal-from-remote","name":"java/partial-path-traversal-from-remote","shortDescription":{"text":"Partial path traversal vulnerability from remote"},"fullDescription":{"text":"A prefix used to check that a canonicalised path falls within another must be slash-terminated."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Partial path traversal vulnerability from remote\nA common way to check that a user-supplied path `SUBDIR` falls inside a directory `DIR` is to use `getCanonicalPath()` to remove any path-traversal elements and then check that `DIR` is a prefix. However, if `DIR` is not slash-terminated, this can unexpectedly allow accessing siblings of `DIR`.\n\nSee also `java/partial-path-traversal`, which is similar to this query, but may also flag non-remotely-exploitable instances of partial path traversal vulnerabilities.\n\n\n## Recommendation\nIf the user should only access items within a certain directory `DIR`, ensure that `DIR` is slash-terminated before checking that `DIR` is a prefix of the user-provided path, `SUBDIR`. Note, Java's `getCanonicalPath()` returns a **non**-slash-terminated path string, so a slash must be added to `DIR` if that method is used.\n\n\n## Example\nIn this example, the `if` statement checks if `parent.getCanonicalPath()` is a prefix of `dir.getCanonicalPath()`. However, `parent.getCanonicalPath()` is not slash-terminated. This means that users that supply `dir` may be also allowed to access siblings of `parent` and not just children of `parent`, which is a security issue.\n\n\n```java\npublic class PartialPathTraversalBad {\n    public void example(File dir, File parent) throws IOException {\n        if (!dir.getCanonicalPath().startsWith(parent.getCanonicalPath())) {\n            throw new IOException(\"Path traversal attempt: \" + dir.getCanonicalPath());\n        }\n    }\n}\n\n```\nIn this example, the `if` statement checks if `parent.toPath()` is a prefix of `dir.normalize()`. Because `Path#startsWith` does the correct check that `dir` is a child of `parent`, users will not be able to access siblings of `parent`, as desired.\n\n\n```java\nimport java.io.File;\n\npublic class PartialPathTraversalGood {\n    public void example(File dir, File parent) throws IOException {\n        if (!dir.toPath().normalize().startsWith(parent.toPath())) {\n            throw new IOException(\"Path traversal attempt: \" + dir.getCanonicalPath());\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Partial Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* CVE-2022-23457: [ ESAPI Vulnerability Report](https://github.com/ESAPI/esapi-java-legacy/blob/develop/documentation/GHSL-2022-008_The_OWASP_Enterprise_Security_API.md).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n","markdown":"# Partial path traversal vulnerability from remote\nA common way to check that a user-supplied path `SUBDIR` falls inside a directory `DIR` is to use `getCanonicalPath()` to remove any path-traversal elements and then check that `DIR` is a prefix. However, if `DIR` is not slash-terminated, this can unexpectedly allow accessing siblings of `DIR`.\n\nSee also `java/partial-path-traversal`, which is similar to this query, but may also flag non-remotely-exploitable instances of partial path traversal vulnerabilities.\n\n\n## Recommendation\nIf the user should only access items within a certain directory `DIR`, ensure that `DIR` is slash-terminated before checking that `DIR` is a prefix of the user-provided path, `SUBDIR`. Note, Java's `getCanonicalPath()` returns a **non**-slash-terminated path string, so a slash must be added to `DIR` if that method is used.\n\n\n## Example\nIn this example, the `if` statement checks if `parent.getCanonicalPath()` is a prefix of `dir.getCanonicalPath()`. However, `parent.getCanonicalPath()` is not slash-terminated. This means that users that supply `dir` may be also allowed to access siblings of `parent` and not just children of `parent`, which is a security issue.\n\n\n```java\npublic class PartialPathTraversalBad {\n    public void example(File dir, File parent) throws IOException {\n        if (!dir.getCanonicalPath().startsWith(parent.getCanonicalPath())) {\n            throw new IOException(\"Path traversal attempt: \" + dir.getCanonicalPath());\n        }\n    }\n}\n\n```\nIn this example, the `if` statement checks if `parent.toPath()` is a prefix of `dir.normalize()`. Because `Path#startsWith` does the correct check that `dir` is a child of `parent`, users will not be able to access siblings of `parent`, as desired.\n\n\n```java\nimport java.io.File;\n\npublic class PartialPathTraversalGood {\n    public void example(File dir, File parent) throws IOException {\n        if (!dir.toPath().normalize().startsWith(parent.toPath())) {\n            throw new IOException(\"Path traversal attempt: \" + dir.getCanonicalPath());\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Partial Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* CVE-2022-23457: [ ESAPI Vulnerability Report](https://github.com/ESAPI/esapi-java-legacy/blob/develop/documentation/GHSL-2022-008_The_OWASP_Enterprise_Security_API.md).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n"},"properties":{"tags":["security","external/cwe/cwe-023"],"description":"A prefix used to check that a canonicalised path falls within another must be slash-terminated.","id":"java/partial-path-traversal-from-remote","kind":"path-problem","name":"Partial path traversal vulnerability from remote","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"java/jhipster-prng","name":"java/jhipster-prng","shortDescription":{"text":"Detect JHipster Generator Vulnerability CVE-2019-16303"},"fullDescription":{"text":"Using a vulnerable version of JHipster to generate random numbers makes it easier for attackers to take over accounts."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Detect JHipster Generator Vulnerability CVE-2019-16303\nThis query detects instances of `RandomUtil.java` that were generated by a [JHipster](https://www.jhipster.tech/) version that is vulnerable to [CVE-2019-16303](https://github.com/jhipster/jhipster-kotlin/security/advisories/GHSA-j3rh-8vwq-wh84).\n\nIf an app uses `RandomUtil.java` generated by a vulnerable version of JHipster, attackers can request a password reset token and use this to predict the value of future reset tokens generated by this server. Using this information, they can create a reset link that allows them to take over any account.\n\nThis vulnerability has a [ CVSS v3.0 Base Score of 9.8/10 ](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?name=CVE-2019-16303&vector=AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H&version=3.1&source=NIST).\n\n\n## Example\nThe example below shows the vulnerable `RandomUtil` class generated by [JHipster prior to version 6.3.0](https://www.jhipster.tech/2019/09/13/jhipster-release-6.3.0.html).\n\n\n```java\nimport org.apache.commons.lang3.RandomStringUtils;\n\n/**\n * Utility class for generating random Strings.\n */\npublic final class RandomUtil {\n\n    private static final int DEF_COUNT = 20;\n\n    private RandomUtil() {\n    }\n\n    /**\n     * Generate a password.\n     *\n     * @return the generated password.\n     */\n    public static String generatePassword() {\n        return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n\n    /**\n     * Generate an activation key.\n     *\n     * @return the generated activation key.\n     */\n    public static String generateActivationKey() {\n        return RandomStringUtils.randomNumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n\n    /**\n     * Generate a reset key.\n     *\n     * @return the generated reset key.\n     */\n    public static String generateResetKey() {\n        return RandomStringUtils.randomNumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n\n    /**\n     * Generate a unique series to validate a persistent token, used in the\n     * authentication remember-me mechanism.\n     *\n     * @return the generated series data.\n     */\n    public static String generateSeriesData() {\n        return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n\n    /**\n     * Generate a persistent token, used in the authentication remember-me mechanism.\n     *\n     * @return the generated token data.\n     */\n    public static String generateTokenData() {\n        return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n}\n\n```\nBelow is a fixed version of the `RandomUtil` class.\n\n\n```java\nimport org.apache.commons.lang3.RandomStringUtils;\n\nimport java.security.SecureRandom;\n\n/**\n * Utility class for generating random Strings.\n */\npublic final class RandomUtil {\n    private static final SecureRandom SECURE_RANDOM = new SecureRandom(); // GOOD: Using SecureRandom\n\n    private static final int DEF_COUNT = 20;\n\n    static {\n        SECURE_RANDOM.nextBytes(new byte[64]);\n    }\n\n    private RandomUtil() {\n    }\n\n    private static String generateRandomAlphanumericString() {\n        // GOOD: Passing Secure Random to RandomStringUtils::random\n        return RandomStringUtils.random(DEF_COUNT, 0, 0, true, true, null, SECURE_RANDOM);\n    }\n\n    /**\n     * Generate a password.\n     *\n     * @return the generated password.\n     */\n    public static String generatePassword() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate an activation key.\n     *\n     * @return the generated activation key.\n     */\n    public static String generateActivationKey() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a reset key.\n     *\n     * @return the generated reset key.\n     */\n    public static String generateResetKey() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a unique series to validate a persistent token, used in the\n     * authentication remember-me mechanism.\n     *\n     * @return the generated series data.\n     */\n    public static String generateSeriesData() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a persistent token, used in the authentication remember-me mechanism.\n     *\n     * @return the generated token data.\n     */\n    public static String generateTokenData() {\n        return generateRandomAlphanumericString();\n    }\n}\n\n```\n\n## Recommendation\nYou should refactor the `RandomUtil` class and replace every call to `RandomStringUtils.randomAlphaNumeric`. You could regenerate the class using the latest version of JHipster, or use an automated refactoring. For example, using the [Patching JHipster CWE-338](https://github.com/moderneinc/jhipster-cwe-338) for the [Rewrite project](https://github.com/openrewrite/rewrite).\n\n\n## References\n* Cloudflare Blog: [ Why secure systems require random numbers ](https://blog.cloudflare.com/why-randomness-matters/)\n* Hacker News: [ How I Hacked Hacker News (with arc security advisory) ](https://news.ycombinator.com/item?id=639976)\n* Posts by Pucara Information Security Team: [ The Java Soothsayer: A practical application for insecure randomness. (Includes free 0day) ](https://blog.pucarasec.com/2020/05/09/the-java-soothsayer-a-practical-application-for-insecure-randomness-includes-free-0day/)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n","markdown":"# Detect JHipster Generator Vulnerability CVE-2019-16303\nThis query detects instances of `RandomUtil.java` that were generated by a [JHipster](https://www.jhipster.tech/) version that is vulnerable to [CVE-2019-16303](https://github.com/jhipster/jhipster-kotlin/security/advisories/GHSA-j3rh-8vwq-wh84).\n\nIf an app uses `RandomUtil.java` generated by a vulnerable version of JHipster, attackers can request a password reset token and use this to predict the value of future reset tokens generated by this server. Using this information, they can create a reset link that allows them to take over any account.\n\nThis vulnerability has a [ CVSS v3.0 Base Score of 9.8/10 ](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?name=CVE-2019-16303&vector=AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H&version=3.1&source=NIST).\n\n\n## Example\nThe example below shows the vulnerable `RandomUtil` class generated by [JHipster prior to version 6.3.0](https://www.jhipster.tech/2019/09/13/jhipster-release-6.3.0.html).\n\n\n```java\nimport org.apache.commons.lang3.RandomStringUtils;\n\n/**\n * Utility class for generating random Strings.\n */\npublic final class RandomUtil {\n\n    private static final int DEF_COUNT = 20;\n\n    private RandomUtil() {\n    }\n\n    /**\n     * Generate a password.\n     *\n     * @return the generated password.\n     */\n    public static String generatePassword() {\n        return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n\n    /**\n     * Generate an activation key.\n     *\n     * @return the generated activation key.\n     */\n    public static String generateActivationKey() {\n        return RandomStringUtils.randomNumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n\n    /**\n     * Generate a reset key.\n     *\n     * @return the generated reset key.\n     */\n    public static String generateResetKey() {\n        return RandomStringUtils.randomNumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n\n    /**\n     * Generate a unique series to validate a persistent token, used in the\n     * authentication remember-me mechanism.\n     *\n     * @return the generated series data.\n     */\n    public static String generateSeriesData() {\n        return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n\n    /**\n     * Generate a persistent token, used in the authentication remember-me mechanism.\n     *\n     * @return the generated token data.\n     */\n    public static String generateTokenData() {\n        return RandomStringUtils.randomAlphanumeric(DEF_COUNT); // BAD: RandomStringUtils does not use SecureRandom\n    }\n}\n\n```\nBelow is a fixed version of the `RandomUtil` class.\n\n\n```java\nimport org.apache.commons.lang3.RandomStringUtils;\n\nimport java.security.SecureRandom;\n\n/**\n * Utility class for generating random Strings.\n */\npublic final class RandomUtil {\n    private static final SecureRandom SECURE_RANDOM = new SecureRandom(); // GOOD: Using SecureRandom\n\n    private static final int DEF_COUNT = 20;\n\n    static {\n        SECURE_RANDOM.nextBytes(new byte[64]);\n    }\n\n    private RandomUtil() {\n    }\n\n    private static String generateRandomAlphanumericString() {\n        // GOOD: Passing Secure Random to RandomStringUtils::random\n        return RandomStringUtils.random(DEF_COUNT, 0, 0, true, true, null, SECURE_RANDOM);\n    }\n\n    /**\n     * Generate a password.\n     *\n     * @return the generated password.\n     */\n    public static String generatePassword() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate an activation key.\n     *\n     * @return the generated activation key.\n     */\n    public static String generateActivationKey() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a reset key.\n     *\n     * @return the generated reset key.\n     */\n    public static String generateResetKey() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a unique series to validate a persistent token, used in the\n     * authentication remember-me mechanism.\n     *\n     * @return the generated series data.\n     */\n    public static String generateSeriesData() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a persistent token, used in the authentication remember-me mechanism.\n     *\n     * @return the generated token data.\n     */\n    public static String generateTokenData() {\n        return generateRandomAlphanumericString();\n    }\n}\n\n```\n\n## Recommendation\nYou should refactor the `RandomUtil` class and replace every call to `RandomStringUtils.randomAlphaNumeric`. You could regenerate the class using the latest version of JHipster, or use an automated refactoring. For example, using the [Patching JHipster CWE-338](https://github.com/moderneinc/jhipster-cwe-338) for the [Rewrite project](https://github.com/openrewrite/rewrite).\n\n\n## References\n* Cloudflare Blog: [ Why secure systems require random numbers ](https://blog.cloudflare.com/why-randomness-matters/)\n* Hacker News: [ How I Hacked Hacker News (with arc security advisory) ](https://news.ycombinator.com/item?id=639976)\n* Posts by Pucara Information Security Team: [ The Java Soothsayer: A practical application for insecure randomness. (Includes free 0day) ](https://blog.pucarasec.com/2020/05/09/the-java-soothsayer-a-practical-application-for-insecure-randomness-includes-free-0day/)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"},"properties":{"tags":["security","external/cwe/cwe-338"],"description":"Using a vulnerable version of JHipster to generate random numbers makes it easier for attackers to take over accounts.","id":"java/jhipster-prng","kind":"problem","name":"Detect JHipster Generator Vulnerability CVE-2019-16303","precision":"very-high","problem.severity":"error","security-severity":"7.8"}},{"id":"java/tainted-numeric-cast","name":"java/tainted-numeric-cast","shortDescription":{"text":"User-controlled data in numeric cast"},"fullDescription":{"text":"Casting user-controlled numeric data to a narrower type without validation can cause unexpected truncation."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# User-controlled data in numeric cast\nCasting a user-controlled numeric value to a narrower type can result in truncated values unless the input is validated.\n\nNarrowing conversions may cause potentially unintended results. For example, casting the positive integer value `128` to type `byte` yields the negative value `-128`.\n\n\n## Recommendation\nGuard against unexpected truncation of user-controlled arithmetic data by doing one of the following:\n\n* Validate the user input.\n* Define a guard on the cast expression, so that the cast is performed only if the input is known to be within the range of the resulting type.\n* Avoid casting to a narrower type, and instead continue to use a wider type.\n\n## Example\nIn this example, a value is read from standard input into a `long`. Because the value is a user-controlled value, it could be extremely large. Casting this value to a narrower type could therefore cause unexpected truncation. The `scaled2` example uses a guard to avoid this problem and checks the range of the input before performing the cast. If the value is too large to cast to type `int` it is rejected as invalid.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) throws IOException {\n\t\t{\n\t\t\tlong data;\n\n\t\t\tBufferedReader readerBuffered = new BufferedReader(\n\t\t\t\t\tnew InputStreamReader(System.in, \"UTF-8\"));\n\t\t\tString stringNumber = readerBuffered.readLine();\n\t\t\tif (stringNumber != null) {\n\t\t\t\tdata = Long.parseLong(stringNumber.trim());\n\t\t\t} else {\n\t\t\t\tdata = 0;\n\t\t\t}\n\n\t\t\t// AVOID: potential truncation if input data is very large,\n\t\t\t// for example 'Long.MAX_VALUE'\n\t\t\tint scaled = (int)data;\n\n\t\t\t//...\n\n\t\t\t// GOOD: use a guard to ensure no truncation occurs\n\t\t\tint scaled2;\n\t\t\tif (data > Integer.MIN_VALUE && data < Integer.MAX_VALUE)\n\t\t\t\tscaled2 = (int)data;\n\t\t\telse\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid input\");\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM12-J. Ensure conversions of numeric types to narrower types do not result in lost or misinterpreted data](https://wiki.sei.cmu.edu/confluence/display/java/NUM12-J.+Ensure+conversions+of+numeric+types+to+narrower+types+do+not+result+in+lost+or+misinterpreted+data).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n","markdown":"# User-controlled data in numeric cast\nCasting a user-controlled numeric value to a narrower type can result in truncated values unless the input is validated.\n\nNarrowing conversions may cause potentially unintended results. For example, casting the positive integer value `128` to type `byte` yields the negative value `-128`.\n\n\n## Recommendation\nGuard against unexpected truncation of user-controlled arithmetic data by doing one of the following:\n\n* Validate the user input.\n* Define a guard on the cast expression, so that the cast is performed only if the input is known to be within the range of the resulting type.\n* Avoid casting to a narrower type, and instead continue to use a wider type.\n\n## Example\nIn this example, a value is read from standard input into a `long`. Because the value is a user-controlled value, it could be extremely large. Casting this value to a narrower type could therefore cause unexpected truncation. The `scaled2` example uses a guard to avoid this problem and checks the range of the input before performing the cast. If the value is too large to cast to type `int` it is rejected as invalid.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) throws IOException {\n\t\t{\n\t\t\tlong data;\n\n\t\t\tBufferedReader readerBuffered = new BufferedReader(\n\t\t\t\t\tnew InputStreamReader(System.in, \"UTF-8\"));\n\t\t\tString stringNumber = readerBuffered.readLine();\n\t\t\tif (stringNumber != null) {\n\t\t\t\tdata = Long.parseLong(stringNumber.trim());\n\t\t\t} else {\n\t\t\t\tdata = 0;\n\t\t\t}\n\n\t\t\t// AVOID: potential truncation if input data is very large,\n\t\t\t// for example 'Long.MAX_VALUE'\n\t\t\tint scaled = (int)data;\n\n\t\t\t//...\n\n\t\t\t// GOOD: use a guard to ensure no truncation occurs\n\t\t\tint scaled2;\n\t\t\tif (data > Integer.MIN_VALUE && data < Integer.MAX_VALUE)\n\t\t\t\tscaled2 = (int)data;\n\t\t\telse\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid input\");\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM12-J. Ensure conversions of numeric types to narrower types do not result in lost or misinterpreted data](https://wiki.sei.cmu.edu/confluence/display/java/NUM12-J.+Ensure+conversions+of+numeric+types+to+narrower+types+do+not+result+in+lost+or+misinterpreted+data).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n"},"properties":{"tags":["security","external/cwe/cwe-197","external/cwe/cwe-681"],"description":"Casting user-controlled numeric data to a narrower type without validation\n              can cause unexpected truncation.","id":"java/tainted-numeric-cast","kind":"path-problem","name":"User-controlled data in numeric cast","precision":"high","problem.severity":"error","security-severity":"9.0"}},{"id":"java/insecure-randomness","name":"java/insecure-randomness","shortDescription":{"text":"Insecure randomness"},"fullDescription":{"text":"Using a cryptographically Insecure pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Insecure randomness\nIf you use a cryptographically weak pseudo-random number generator to generate security-sensitive values, such as passwords, attackers can more easily predict those values.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values (the seed). If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nThe `java.util.Random` random number generator is not cryptographically secure. Use a secure random number generator such as `java.security.SecureRandom` instead.\n\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a general rule, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\n\n## Example\nThe following examples show different ways of generating a cookie with a random value.\n\nIn the first (BAD) case, we generate a fresh cookie by appending a random integer to the end of a static string. The random number generator used (`Random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated cookie.\n\n\n```java\nRandom r = new Random();\n\nbyte[] bytes = new byte[16];\nr.nextBytes(bytes);\n\nString cookieValue = encode(bytes);\n\nCookie cookie = new Cookie(\"name\", cookieValue);\nresponse.addCookie(cookie);\n\n```\nIn the second (GOOD) case, we generate a fresh cookie by appending a random integer to the end of a static string. The random number generator used (`SecureRandom`) is cryptographically secure, so it is not possible for an attacker to predict the generated cookie.\n\n\n```java\nSecureRandom r = new SecureRandom();\n\nbyte[] bytes = new byte[16];\nr.nextBytes(bytes);\n\nString cookieValue = encode(bytes);\n\nCookie cookie = new Cookie(\"name\", cookieValue);\nresponse.addCookie(cookie);\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Java Docs: [Random](http://docs.oracle.com/javase/8/docs/api/java/util/Random.html).\n* Java Docs: [SecureRandom](http://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html).\n* Common Weakness Enumeration: [CWE-330](https://cwe.mitre.org/data/definitions/330.html).\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n","markdown":"# Insecure randomness\nIf you use a cryptographically weak pseudo-random number generator to generate security-sensitive values, such as passwords, attackers can more easily predict those values.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values (the seed). If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nThe `java.util.Random` random number generator is not cryptographically secure. Use a secure random number generator such as `java.security.SecureRandom` instead.\n\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a general rule, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\n\n## Example\nThe following examples show different ways of generating a cookie with a random value.\n\nIn the first (BAD) case, we generate a fresh cookie by appending a random integer to the end of a static string. The random number generator used (`Random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated cookie.\n\n\n```java\nRandom r = new Random();\n\nbyte[] bytes = new byte[16];\nr.nextBytes(bytes);\n\nString cookieValue = encode(bytes);\n\nCookie cookie = new Cookie(\"name\", cookieValue);\nresponse.addCookie(cookie);\n\n```\nIn the second (GOOD) case, we generate a fresh cookie by appending a random integer to the end of a static string. The random number generator used (`SecureRandom`) is cryptographically secure, so it is not possible for an attacker to predict the generated cookie.\n\n\n```java\nSecureRandom r = new SecureRandom();\n\nbyte[] bytes = new byte[16];\nr.nextBytes(bytes);\n\nString cookieValue = encode(bytes);\n\nCookie cookie = new Cookie(\"name\", cookieValue);\nresponse.addCookie(cookie);\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Java Docs: [Random](http://docs.oracle.com/javase/8/docs/api/java/util/Random.html).\n* Java Docs: [SecureRandom](http://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html).\n* Common Weakness Enumeration: [CWE-330](https://cwe.mitre.org/data/definitions/330.html).\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"},"properties":{"tags":["security","external/cwe/cwe-330","external/cwe/cwe-338"],"description":"Using a cryptographically Insecure pseudo-random number generator to generate a\n              security-sensitive value may allow an attacker to predict what value will\n              be generated.","id":"java/insecure-randomness","kind":"path-problem","name":"Insecure randomness","precision":"high","problem.severity":"warning","security-severity":"7.8"}},{"id":"java/insecure-ldap-auth","name":"java/insecure-ldap-auth","shortDescription":{"text":"Insecure LDAP authentication"},"fullDescription":{"text":"LDAP authentication with credentials sent in cleartext makes sensitive information vulnerable to remote attackers"},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Insecure LDAP authentication\nWhen using the Java LDAP API to perform LDAPv3-style extended operations and controls, a context with connection properties including user credentials is started. Transmission of LDAP credentials in cleartext allows remote attackers to obtain sensitive information by sniffing the network.\n\n\n## Recommendation\nUse the `ldaps://` protocol to send credentials through SSL or use SASL authentication.\n\n\n## Example\nIn the following (bad) example, a `ldap://` URL is used and credentials will be sent in plaintext.\n\n\n```java\nString ldapUrl = \"ldap://ad.your-server.com:389\";\nHashtable<String, String> environment = new Hashtable<String, String>();\nenvironment.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenvironment.put(Context.PROVIDER_URL, ldapUrl);\nenvironment.put(Context.REFERRAL, \"follow\");\nenvironment.put(Context.SECURITY_AUTHENTICATION, \"simple\");\nenvironment.put(Context.SECURITY_PRINCIPAL, ldapUserName);\nenvironment.put(Context.SECURITY_CREDENTIALS, password);\nDirContext dirContext = new InitialDirContext(environment);\n\n```\nIn the following (good) example, a `ldaps://` URL is used so credentials will be encrypted with SSL.\n\n\n```java\nString ldapUrl = \"ldaps://ad.your-server.com:636\";\nHashtable<String, String> environment = new Hashtable<String, String>();\nenvironment.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenvironment.put(Context.PROVIDER_URL, ldapUrl);\nenvironment.put(Context.REFERRAL, \"follow\");\nenvironment.put(Context.SECURITY_AUTHENTICATION, \"simple\");\nenvironment.put(Context.SECURITY_PRINCIPAL, ldapUserName);\nenvironment.put(Context.SECURITY_CREDENTIALS, password);\nDirContext dirContext = new InitialDirContext(environment);\n\n```\nIn the following (good) example, a `ldap://` URL is used, but SASL authentication is enabled so that the credentials will be encrypted.\n\n\n```java\nString ldapUrl = \"ldap://ad.your-server.com:389\";\nHashtable<String, String> environment = new Hashtable<String, String>();\nenvironment.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenvironment.put(Context.PROVIDER_URL, ldapUrl);\nenvironment.put(Context.REFERRAL, \"follow\");\nenvironment.put(Context.SECURITY_AUTHENTICATION, \"DIGEST-MD5 GSSAPI\");\nenvironment.put(Context.SECURITY_PRINCIPAL, ldapUserName);\nenvironment.put(Context.SECURITY_CREDENTIALS, password);\nDirContext dirContext = new InitialDirContext(environment);\n\n```\n\n## References\n* Oracle: [LDAP and LDAPS URLs](https://docs.oracle.com/javase/jndi/tutorial/ldap/misc/url.html)\n* Oracle: [Simple authentication](https://docs.oracle.com/javase/tutorial/jndi/ldap/simple.html)\n* Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n","markdown":"# Insecure LDAP authentication\nWhen using the Java LDAP API to perform LDAPv3-style extended operations and controls, a context with connection properties including user credentials is started. Transmission of LDAP credentials in cleartext allows remote attackers to obtain sensitive information by sniffing the network.\n\n\n## Recommendation\nUse the `ldaps://` protocol to send credentials through SSL or use SASL authentication.\n\n\n## Example\nIn the following (bad) example, a `ldap://` URL is used and credentials will be sent in plaintext.\n\n\n```java\nString ldapUrl = \"ldap://ad.your-server.com:389\";\nHashtable<String, String> environment = new Hashtable<String, String>();\nenvironment.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenvironment.put(Context.PROVIDER_URL, ldapUrl);\nenvironment.put(Context.REFERRAL, \"follow\");\nenvironment.put(Context.SECURITY_AUTHENTICATION, \"simple\");\nenvironment.put(Context.SECURITY_PRINCIPAL, ldapUserName);\nenvironment.put(Context.SECURITY_CREDENTIALS, password);\nDirContext dirContext = new InitialDirContext(environment);\n\n```\nIn the following (good) example, a `ldaps://` URL is used so credentials will be encrypted with SSL.\n\n\n```java\nString ldapUrl = \"ldaps://ad.your-server.com:636\";\nHashtable<String, String> environment = new Hashtable<String, String>();\nenvironment.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenvironment.put(Context.PROVIDER_URL, ldapUrl);\nenvironment.put(Context.REFERRAL, \"follow\");\nenvironment.put(Context.SECURITY_AUTHENTICATION, \"simple\");\nenvironment.put(Context.SECURITY_PRINCIPAL, ldapUserName);\nenvironment.put(Context.SECURITY_CREDENTIALS, password);\nDirContext dirContext = new InitialDirContext(environment);\n\n```\nIn the following (good) example, a `ldap://` URL is used, but SASL authentication is enabled so that the credentials will be encrypted.\n\n\n```java\nString ldapUrl = \"ldap://ad.your-server.com:389\";\nHashtable<String, String> environment = new Hashtable<String, String>();\nenvironment.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenvironment.put(Context.PROVIDER_URL, ldapUrl);\nenvironment.put(Context.REFERRAL, \"follow\");\nenvironment.put(Context.SECURITY_AUTHENTICATION, \"DIGEST-MD5 GSSAPI\");\nenvironment.put(Context.SECURITY_PRINCIPAL, ldapUserName);\nenvironment.put(Context.SECURITY_CREDENTIALS, password);\nDirContext dirContext = new InitialDirContext(environment);\n\n```\n\n## References\n* Oracle: [LDAP and LDAPS URLs](https://docs.oracle.com/javase/jndi/tutorial/ldap/misc/url.html)\n* Oracle: [Simple authentication](https://docs.oracle.com/javase/tutorial/jndi/ldap/simple.html)\n* Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n"},"properties":{"tags":["security","external/cwe/cwe-522","external/cwe/cwe-319"],"description":"LDAP authentication with credentials sent in cleartext makes sensitive information vulnerable to remote attackers","id":"java/insecure-ldap-auth","kind":"path-problem","name":"Insecure LDAP authentication","precision":"high","problem.severity":"error","security-severity":"8.8"}},{"id":"java/maven/non-https-url","name":"java/maven/non-https-url","shortDescription":{"text":"Failure to use HTTPS or SFTP URL in Maven artifact upload/download"},"fullDescription":{"text":"Non-HTTPS connections can be intercepted by third parties."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Failure to use HTTPS or SFTP URL in Maven artifact upload/download\nUsing an insecure protocol like HTTP or FTP to download your dependencies leaves your Maven build vulnerable to a [Man in the Middle (MITM)](https://en.wikipedia.org/wiki/Man-in-the-middle_attack). This can allow attackers to inject malicious code into the artifacts that you are resolving and infect build artifacts that are being produced. This can be used by attackers to perform a [Supply chain attack](https://en.wikipedia.org/wiki/Supply_chain_attack) against your project's users.\n\nThis vulnerability has a [ CVSS v3.1 base score of 8.1/10 ](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H&version=3.1).\n\n\n## Recommendation\nAlways use HTTPS or SFTP to download artifacts from artifact servers.\n\n\n## Example\nThese examples show examples of locations in Maven POM files where artifact repository upload/download is configured. The first shows the use of HTTP, the second shows the use of HTTPS.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.semmle</groupId>\n    <artifactId>parent</artifactId>\n    <version>1.0</version>\n    <packaging>pom</packaging>\n\n    <name>Security Testing</name>\n    <description>An example of insecure download and upload of dependencies</description>\n\n    <distributionManagement>\n        <repository>\n            <id>insecure-releases</id>\n            <name>Insecure Repository Releases</name>\n            <!-- BAD! Use HTTPS -->\n            <url>http://insecure-repository.example</url>\n        </repository>\n        <snapshotRepository>\n            <id>insecure-snapshots</id>\n            <name>Insecure Repository Snapshots</name>\n            <!-- BAD! Use HTTPS -->\n            <url>http://insecure-repository.example</url>\n        </snapshotRepository>\n    </distributionManagement>\n    <repositories>\n        <repository>\n            <id>insecure</id>\n            <name>Insecure Repository</name>\n            <!-- BAD! Use HTTPS -->\n            <url>http://insecure-repository.example</url>\n        </repository>\n    </repositories>\n    <pluginRepositories>\n        <pluginRepository>\n            <id>insecure-plugins</id>\n            <name>Insecure Repository Releases</name>\n            <!-- BAD! Use HTTPS -->\n            <url>http://insecure-repository.example</url>\n        </pluginRepository>\n    </pluginRepositories>\n</project>\n\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.semmle</groupId>\n    <artifactId>parent</artifactId>\n    <version>1.0</version>\n    <packaging>pom</packaging>\n\n    <name>Security Testing</name>\n    <description>An example of secure download and upload of dependencies</description>\n\n    <distributionManagement>\n        <repository>\n            <id>insecure-releases</id>\n            <name>Secure Repository Releases</name>\n            <!-- GOOD! Use HTTPS -->\n            <url>https://insecure-repository.example</url>\n        </repository>\n        <snapshotRepository>\n            <id>insecure-snapshots</id>\n            <name>Secure Repository Snapshots</name>\n            <!-- GOOD! Use HTTPS -->\n            <url>https://insecure-repository.example</url>\n        </snapshotRepository>\n    </distributionManagement>\n    <repositories>\n        <repository>\n            <id>insecure</id>\n            <name>Secure Repository</name>\n            <!-- GOOD! Use HTTPS -->\n            <url>https://insecure-repository.example</url>\n        </repository>\n    </repositories>\n    <pluginRepositories>\n        <pluginRepository>\n            <id>insecure-plugins</id>\n            <name>Secure Repository Releases</name>\n            <!-- GOOD! Use HTTPS -->\n            <url>https://insecure-repository.example</url>\n        </pluginRepository>\n    </pluginRepositories>\n</project>\n\n```\n\n## References\n* Research: [ Want to take over the Java ecosystem? All you need is a MITM! ](https://medium.com/bugbountywriteup/want-to-take-over-the-java-ecosystem-all-you-need-is-a-mitm-1fc329d898fb?source=friends_link&sk=3c99970c55a899ad9ef41f126efcde0e)\n* Research: [ How to take over the computer of any Java (or Closure or Scala) Developer. ](https://max.computer/blog/how-to-take-over-the-computer-of-any-java-or-clojure-or-scala-developer/)\n* Proof of Concept: [ mveytsman/dilettante ](https://github.com/mveytsman/dilettante)\n* Additional Gradle &amp; Maven plugin: [ Announcing nohttp ](https://spring.io/blog/2019/06/10/announcing-nohttp)\n* Java Ecosystem Announcement: [ HTTP Decommission Artifact Server Announcements ](https://gist.github.com/JLLeitschuh/789e49e3d34092a005031a0a1880af99)\n* Common Weakness Enumeration: [CWE-300](https://cwe.mitre.org/data/definitions/300.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).\n* Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).\n","markdown":"# Failure to use HTTPS or SFTP URL in Maven artifact upload/download\nUsing an insecure protocol like HTTP or FTP to download your dependencies leaves your Maven build vulnerable to a [Man in the Middle (MITM)](https://en.wikipedia.org/wiki/Man-in-the-middle_attack). This can allow attackers to inject malicious code into the artifacts that you are resolving and infect build artifacts that are being produced. This can be used by attackers to perform a [Supply chain attack](https://en.wikipedia.org/wiki/Supply_chain_attack) against your project's users.\n\nThis vulnerability has a [ CVSS v3.1 base score of 8.1/10 ](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H&version=3.1).\n\n\n## Recommendation\nAlways use HTTPS or SFTP to download artifacts from artifact servers.\n\n\n## Example\nThese examples show examples of locations in Maven POM files where artifact repository upload/download is configured. The first shows the use of HTTP, the second shows the use of HTTPS.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.semmle</groupId>\n    <artifactId>parent</artifactId>\n    <version>1.0</version>\n    <packaging>pom</packaging>\n\n    <name>Security Testing</name>\n    <description>An example of insecure download and upload of dependencies</description>\n\n    <distributionManagement>\n        <repository>\n            <id>insecure-releases</id>\n            <name>Insecure Repository Releases</name>\n            <!-- BAD! Use HTTPS -->\n            <url>http://insecure-repository.example</url>\n        </repository>\n        <snapshotRepository>\n            <id>insecure-snapshots</id>\n            <name>Insecure Repository Snapshots</name>\n            <!-- BAD! Use HTTPS -->\n            <url>http://insecure-repository.example</url>\n        </snapshotRepository>\n    </distributionManagement>\n    <repositories>\n        <repository>\n            <id>insecure</id>\n            <name>Insecure Repository</name>\n            <!-- BAD! Use HTTPS -->\n            <url>http://insecure-repository.example</url>\n        </repository>\n    </repositories>\n    <pluginRepositories>\n        <pluginRepository>\n            <id>insecure-plugins</id>\n            <name>Insecure Repository Releases</name>\n            <!-- BAD! Use HTTPS -->\n            <url>http://insecure-repository.example</url>\n        </pluginRepository>\n    </pluginRepositories>\n</project>\n\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.semmle</groupId>\n    <artifactId>parent</artifactId>\n    <version>1.0</version>\n    <packaging>pom</packaging>\n\n    <name>Security Testing</name>\n    <description>An example of secure download and upload of dependencies</description>\n\n    <distributionManagement>\n        <repository>\n            <id>insecure-releases</id>\n            <name>Secure Repository Releases</name>\n            <!-- GOOD! Use HTTPS -->\n            <url>https://insecure-repository.example</url>\n        </repository>\n        <snapshotRepository>\n            <id>insecure-snapshots</id>\n            <name>Secure Repository Snapshots</name>\n            <!-- GOOD! Use HTTPS -->\n            <url>https://insecure-repository.example</url>\n        </snapshotRepository>\n    </distributionManagement>\n    <repositories>\n        <repository>\n            <id>insecure</id>\n            <name>Secure Repository</name>\n            <!-- GOOD! Use HTTPS -->\n            <url>https://insecure-repository.example</url>\n        </repository>\n    </repositories>\n    <pluginRepositories>\n        <pluginRepository>\n            <id>insecure-plugins</id>\n            <name>Secure Repository Releases</name>\n            <!-- GOOD! Use HTTPS -->\n            <url>https://insecure-repository.example</url>\n        </pluginRepository>\n    </pluginRepositories>\n</project>\n\n```\n\n## References\n* Research: [ Want to take over the Java ecosystem? All you need is a MITM! ](https://medium.com/bugbountywriteup/want-to-take-over-the-java-ecosystem-all-you-need-is-a-mitm-1fc329d898fb?source=friends_link&sk=3c99970c55a899ad9ef41f126efcde0e)\n* Research: [ How to take over the computer of any Java (or Closure or Scala) Developer. ](https://max.computer/blog/how-to-take-over-the-computer-of-any-java-or-clojure-or-scala-developer/)\n* Proof of Concept: [ mveytsman/dilettante ](https://github.com/mveytsman/dilettante)\n* Additional Gradle &amp; Maven plugin: [ Announcing nohttp ](https://spring.io/blog/2019/06/10/announcing-nohttp)\n* Java Ecosystem Announcement: [ HTTP Decommission Artifact Server Announcements ](https://gist.github.com/JLLeitschuh/789e49e3d34092a005031a0a1880af99)\n* Common Weakness Enumeration: [CWE-300](https://cwe.mitre.org/data/definitions/300.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).\n* Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).\n"},"properties":{"tags":["security","external/cwe/cwe-300","external/cwe/cwe-319","external/cwe/cwe-494","external/cwe/cwe-829"],"description":"Non-HTTPS connections can be intercepted by third parties.","id":"java/maven/non-https-url","kind":"problem","name":"Failure to use HTTPS or SFTP URL in Maven artifact upload/download","precision":"very-high","problem.severity":"error","security-severity":"8.1"}},{"id":"java/insufficient-key-size","name":"java/insufficient-key-size","shortDescription":{"text":"Use of a cryptographic algorithm with insufficient key size"},"fullDescription":{"text":"Using cryptographic algorithms with too small a key size can allow an attacker to compromise security."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of a cryptographic algorithm with insufficient key size\nModern encryption relies on the computational infeasibility of breaking a cipher and decoding its message without the key. As computational power increases, the ability to break ciphers grows, and key sizes need to become larger as a result. Cryptographic algorithms that use too small of a key size are vulnerable to brute force attacks, which can reveal sensitive data.\n\n\n## Recommendation\nUse a key of the recommended size or larger. The key size should be at least 128 bits for AES encryption, 256 bits for elliptic-curve cryptography (ECC), and 2048 bits for RSA, DSA, or DH encryption.\n\n\n## Example\nThe following code uses cryptographic algorithms with insufficient key sizes.\n\n\n```java\n    KeyPairGenerator keyPairGen1 = KeyPairGenerator.getInstance(\"RSA\");\n    keyPairGen1.initialize(1024); // BAD: Key size is less than 2048\n\n    KeyPairGenerator keyPairGen2 = KeyPairGenerator.getInstance(\"DSA\");\n    keyPairGen2.initialize(1024); // BAD: Key size is less than 2048\n\n    KeyPairGenerator keyPairGen3 = KeyPairGenerator.getInstance(\"DH\");\n    keyPairGen3.initialize(1024); // BAD: Key size is less than 2048\n\n    KeyPairGenerator keyPairGen4 = KeyPairGenerator.getInstance(\"EC\");\n    ECGenParameterSpec ecSpec = new ECGenParameterSpec(\"secp112r1\"); // BAD: Key size is less than 256\n    keyPairGen4.initialize(ecSpec);\n\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n    keyGen.init(64); // BAD: Key size is less than 128\n\n```\nTo fix the code, change the key sizes to be the recommended size or larger for each algorithm.\n\n\n## References\n* Wikipedia: [Key size](http://en.wikipedia.org/wiki/Key_size).\n* Wikipedia: [Strong cryptography](https://en.wikipedia.org/wiki/Strong_cryptography).\n* OWASP: [ Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms).\n* OWASP: [ Testing for Weak Encryption](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/04-Testing_for_Weak_Encryption).\n* NIST: [ Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n","markdown":"# Use of a cryptographic algorithm with insufficient key size\nModern encryption relies on the computational infeasibility of breaking a cipher and decoding its message without the key. As computational power increases, the ability to break ciphers grows, and key sizes need to become larger as a result. Cryptographic algorithms that use too small of a key size are vulnerable to brute force attacks, which can reveal sensitive data.\n\n\n## Recommendation\nUse a key of the recommended size or larger. The key size should be at least 128 bits for AES encryption, 256 bits for elliptic-curve cryptography (ECC), and 2048 bits for RSA, DSA, or DH encryption.\n\n\n## Example\nThe following code uses cryptographic algorithms with insufficient key sizes.\n\n\n```java\n    KeyPairGenerator keyPairGen1 = KeyPairGenerator.getInstance(\"RSA\");\n    keyPairGen1.initialize(1024); // BAD: Key size is less than 2048\n\n    KeyPairGenerator keyPairGen2 = KeyPairGenerator.getInstance(\"DSA\");\n    keyPairGen2.initialize(1024); // BAD: Key size is less than 2048\n\n    KeyPairGenerator keyPairGen3 = KeyPairGenerator.getInstance(\"DH\");\n    keyPairGen3.initialize(1024); // BAD: Key size is less than 2048\n\n    KeyPairGenerator keyPairGen4 = KeyPairGenerator.getInstance(\"EC\");\n    ECGenParameterSpec ecSpec = new ECGenParameterSpec(\"secp112r1\"); // BAD: Key size is less than 256\n    keyPairGen4.initialize(ecSpec);\n\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n    keyGen.init(64); // BAD: Key size is less than 128\n\n```\nTo fix the code, change the key sizes to be the recommended size or larger for each algorithm.\n\n\n## References\n* Wikipedia: [Key size](http://en.wikipedia.org/wiki/Key_size).\n* Wikipedia: [Strong cryptography](https://en.wikipedia.org/wiki/Strong_cryptography).\n* OWASP: [ Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms).\n* OWASP: [ Testing for Weak Encryption](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/04-Testing_for_Weak_Encryption).\n* NIST: [ Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n"},"properties":{"tags":["security","external/cwe/cwe-326"],"description":"Using cryptographic algorithms with too small a key size can\n              allow an attacker to compromise security.","id":"java/insufficient-key-size","kind":"path-problem","name":"Use of a cryptographic algorithm with insufficient key size","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/xml/xpath-injection","name":"java/xml/xpath-injection","shortDescription":{"text":"XPath injection"},"fullDescription":{"text":"Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# XPath injection\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, either sanitize the data or pre-compile the query and use variable references to include the user input.\n\nXPath injection can also be prevented by using XQuery.\n\n\n## Example\nIn the first three examples, the code accepts a name and password specified by the user, and uses this unvalidated and unsanitized value in an XPath expression. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.\n\nIn the fourth example, the code uses `setXPathVariableResolver` which prevents XPath injection.\n\nThe final two examples are for dom4j. They show an example of XPath injection and one method of preventing it.\n\n\n```java\nfinal String xmlStr = \"<users>\" + \n                        \"   <user name=\\\"aaa\\\" pass=\\\"pass1\\\"></user>\" + \n                        \"   <user name=\\\"bbb\\\" pass=\\\"pass2\\\"></user>\" + \n                        \"</users>\";\ntry {\n    DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\n    domFactory.setNamespaceAware(true);\n    DocumentBuilder builder = domFactory.newDocumentBuilder();\n    //Document doc = builder.parse(\"user.xml\");\n    Document doc = builder.parse(new InputSource(new StringReader(xmlStr)));\n\n    XPathFactory factory = XPathFactory.newInstance();\n    XPath xpath = factory.newXPath();\n\n    // Injectable data\n    String user = request.getParameter(\"user\");\n    String pass = request.getParameter(\"pass\");\n    if (user != null && pass != null) {\n        boolean isExist = false;\n\n        // Bad expression\n        String expression1 = \"/users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\";\n        isExist = (boolean)xpath.evaluate(expression1, doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n        // Bad expression\n        XPathExpression expression2 = xpath.compile(\"/users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\");\n        isExist = (boolean)expression2.evaluate(doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n        // Bad expression\n        StringBuffer sb = new StringBuffer(\"/users/user[@name=\");\n        sb.append(user);\n        sb.append(\"' and @pass='\");\n        sb.append(pass);\n        sb.append(\"']\");\n        String query = sb.toString();\n        XPathExpression expression3 = xpath.compile(query);\n        isExist = (boolean)expression3.evaluate(doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n        // Good expression\n        String expression4 = \"/users/user[@name=$user and @pass=$pass]\";\n        xpath.setXPathVariableResolver(v -> {\n        switch (v.getLocalPart()) {\n            case \"user\":\n                return user;\n            case \"pass\":\n                return pass;\n            default:\n                throw new IllegalArgumentException();\n            }\n        });\n        isExist = (boolean)xpath.evaluate(expression4, doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n\n        // Bad Dom4j \n        org.dom4j.io.SAXReader reader = new org.dom4j.io.SAXReader();\n        org.dom4j.Document document = reader.read(new InputSource(new StringReader(xmlStr)));\n        isExist = document.selectSingleNode(\"/users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\") != null;\n        // or document.selectNodes\n        System.out.println(isExist);\n\n        // Good Dom4j\n        org.jaxen.SimpleVariableContext svc = new org.jaxen.SimpleVariableContext();\n        svc.setVariableValue(\"user\", user);\n        svc.setVariableValue(\"pass\", pass);\n        String xpathString = \"/users/user[@name=$user and @pass=$pass]\";\n        org.dom4j.XPath safeXPath = document.createXPath(xpathString);\n        safeXPath.setVariableContext(svc);\n        isExist = safeXPath.selectSingleNode(document) != null;\n        System.out.println(isExist);\n    }\n} catch (ParserConfigurationException e) {\n\n} catch (SAXException e) {\n\n} catch (XPathExpressionException e) {\n\n} catch (org.dom4j.DocumentException e) {\n\n}\n```\n\n## References\n* OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n* OWASP: [XPath Injection](https://owasp.org/www-community/attacks/XPATH_Injection).\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n","markdown":"# XPath injection\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, either sanitize the data or pre-compile the query and use variable references to include the user input.\n\nXPath injection can also be prevented by using XQuery.\n\n\n## Example\nIn the first three examples, the code accepts a name and password specified by the user, and uses this unvalidated and unsanitized value in an XPath expression. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.\n\nIn the fourth example, the code uses `setXPathVariableResolver` which prevents XPath injection.\n\nThe final two examples are for dom4j. They show an example of XPath injection and one method of preventing it.\n\n\n```java\nfinal String xmlStr = \"<users>\" + \n                        \"   <user name=\\\"aaa\\\" pass=\\\"pass1\\\"></user>\" + \n                        \"   <user name=\\\"bbb\\\" pass=\\\"pass2\\\"></user>\" + \n                        \"</users>\";\ntry {\n    DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\n    domFactory.setNamespaceAware(true);\n    DocumentBuilder builder = domFactory.newDocumentBuilder();\n    //Document doc = builder.parse(\"user.xml\");\n    Document doc = builder.parse(new InputSource(new StringReader(xmlStr)));\n\n    XPathFactory factory = XPathFactory.newInstance();\n    XPath xpath = factory.newXPath();\n\n    // Injectable data\n    String user = request.getParameter(\"user\");\n    String pass = request.getParameter(\"pass\");\n    if (user != null && pass != null) {\n        boolean isExist = false;\n\n        // Bad expression\n        String expression1 = \"/users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\";\n        isExist = (boolean)xpath.evaluate(expression1, doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n        // Bad expression\n        XPathExpression expression2 = xpath.compile(\"/users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\");\n        isExist = (boolean)expression2.evaluate(doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n        // Bad expression\n        StringBuffer sb = new StringBuffer(\"/users/user[@name=\");\n        sb.append(user);\n        sb.append(\"' and @pass='\");\n        sb.append(pass);\n        sb.append(\"']\");\n        String query = sb.toString();\n        XPathExpression expression3 = xpath.compile(query);\n        isExist = (boolean)expression3.evaluate(doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n        // Good expression\n        String expression4 = \"/users/user[@name=$user and @pass=$pass]\";\n        xpath.setXPathVariableResolver(v -> {\n        switch (v.getLocalPart()) {\n            case \"user\":\n                return user;\n            case \"pass\":\n                return pass;\n            default:\n                throw new IllegalArgumentException();\n            }\n        });\n        isExist = (boolean)xpath.evaluate(expression4, doc, XPathConstants.BOOLEAN);\n        System.out.println(isExist);\n\n\n        // Bad Dom4j \n        org.dom4j.io.SAXReader reader = new org.dom4j.io.SAXReader();\n        org.dom4j.Document document = reader.read(new InputSource(new StringReader(xmlStr)));\n        isExist = document.selectSingleNode(\"/users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\") != null;\n        // or document.selectNodes\n        System.out.println(isExist);\n\n        // Good Dom4j\n        org.jaxen.SimpleVariableContext svc = new org.jaxen.SimpleVariableContext();\n        svc.setVariableValue(\"user\", user);\n        svc.setVariableValue(\"pass\", pass);\n        String xpathString = \"/users/user[@name=$user and @pass=$pass]\";\n        org.dom4j.XPath safeXPath = document.createXPath(xpathString);\n        safeXPath.setVariableContext(svc);\n        isExist = safeXPath.selectSingleNode(document) != null;\n        System.out.println(isExist);\n    }\n} catch (ParserConfigurationException e) {\n\n} catch (SAXException e) {\n\n} catch (XPathExpressionException e) {\n\n} catch (org.dom4j.DocumentException e) {\n\n}\n```\n\n## References\n* OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n* OWASP: [XPath Injection](https://owasp.org/www-community/attacks/XPATH_Injection).\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n"},"properties":{"tags":["security","external/cwe/cwe-643"],"description":"Building an XPath expression from user-controlled sources is vulnerable to insertion of\n              malicious code by the user.","id":"java/xml/xpath-injection","kind":"path-problem","name":"XPath injection","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"java/spring-disabled-csrf-protection","name":"java/spring-disabled-csrf-protection","shortDescription":{"text":"Disabled Spring CSRF protection"},"fullDescription":{"text":"Disabling CSRF protection makes the application vulnerable to a Cross-Site Request Forgery (CSRF) attack."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Disabled Spring CSRF protection\nWhen you set up a web server to receive a request from a client without any mechanism for verifying that it was intentionally sent, then it is vulnerable to attack. An attacker can trick a client into making an unintended request to the web server that will be treated as an authentic request. This can be done via a URL, image load, XMLHttpRequest, etc. and can result in exposure of data or unintended code execution.\n\n\n## Recommendation\nWhen you use Spring, Cross-Site Request Forgery (CSRF) protection is enabled by default. Spring's recommendation is to use CSRF protection for any request that could be processed by a browser client by normal users.\n\n\n## Example\nThe following example shows the Spring Java configuration with CSRF protection disabled. This type of configuration should only be used if you are creating a service that is used only by non-browser clients.\n\n\n```java\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n@EnableWebSecurity\n@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    http\n      .csrf(csrf ->\n        // BAD - CSRF protection shouldn't be disabled\n        csrf.disable() \n      );\n  }\n}\n\n```\n\n## References\n* OWASP: [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).\n* Spring Security Reference: [ Cross Site Request Forgery (CSRF) ](https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html).\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n","markdown":"# Disabled Spring CSRF protection\nWhen you set up a web server to receive a request from a client without any mechanism for verifying that it was intentionally sent, then it is vulnerable to attack. An attacker can trick a client into making an unintended request to the web server that will be treated as an authentic request. This can be done via a URL, image load, XMLHttpRequest, etc. and can result in exposure of data or unintended code execution.\n\n\n## Recommendation\nWhen you use Spring, Cross-Site Request Forgery (CSRF) protection is enabled by default. Spring's recommendation is to use CSRF protection for any request that could be processed by a browser client by normal users.\n\n\n## Example\nThe following example shows the Spring Java configuration with CSRF protection disabled. This type of configuration should only be used if you are creating a service that is used only by non-browser clients.\n\n\n```java\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n@EnableWebSecurity\n@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    http\n      .csrf(csrf ->\n        // BAD - CSRF protection shouldn't be disabled\n        csrf.disable() \n      );\n  }\n}\n\n```\n\n## References\n* OWASP: [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).\n* Spring Security Reference: [ Cross Site Request Forgery (CSRF) ](https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html).\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"},"properties":{"tags":["security","external/cwe/cwe-352"],"description":"Disabling CSRF protection makes the application vulnerable to\n              a Cross-Site Request Forgery (CSRF) attack.","id":"java/spring-disabled-csrf-protection","kind":"problem","name":"Disabled Spring CSRF protection","precision":"high","problem.severity":"error","security-severity":"8.8"}},{"id":"java/rsa-without-oaep","name":"java/rsa-without-oaep","shortDescription":{"text":"Use of RSA algorithm without OAEP"},"fullDescription":{"text":"Using RSA encryption without OAEP padding can result in a padding oracle attack, leading to a weaker encryption."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of RSA algorithm without OAEP\nCryptographic algorithms often use padding schemes to make the plaintext less predictable. The OAEP (Optimal Asymmetric Encryption Padding) scheme should be used with RSA encryption. Using an outdated padding scheme such as PKCS1, or no padding at all, can weaken the encryption by making it vulnerable to a padding oracle attack.\n\n\n## Recommendation\nUse the OAEP scheme when using RSA encryption.\n\n\n## Example\nIn the following example, the BAD case shows no padding being used, whereas the GOOD case shows an OAEP scheme being used.\n\n\n```java\n// BAD: No padding scheme is used\nCipher rsa = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n...\n\n//GOOD: OAEP padding is used\nCipher rsa = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-1AndMGF1Padding\");\n...\n```\n\n## References\n* [Mobile Security Testing Guide](https://github.com/MobSF/owasp-mstg/blob/master/Document/0x04g-Testing-Cryptography.md#padding-oracle-attacks-due-to-weaker-padding-or-block-operation-implementations).\n* [The Padding Oracle Attack](https://robertheaton.com/2013/07/29/padding-oracle-attack/).\n* Common Weakness Enumeration: [CWE-780](https://cwe.mitre.org/data/definitions/780.html).\n","markdown":"# Use of RSA algorithm without OAEP\nCryptographic algorithms often use padding schemes to make the plaintext less predictable. The OAEP (Optimal Asymmetric Encryption Padding) scheme should be used with RSA encryption. Using an outdated padding scheme such as PKCS1, or no padding at all, can weaken the encryption by making it vulnerable to a padding oracle attack.\n\n\n## Recommendation\nUse the OAEP scheme when using RSA encryption.\n\n\n## Example\nIn the following example, the BAD case shows no padding being used, whereas the GOOD case shows an OAEP scheme being used.\n\n\n```java\n// BAD: No padding scheme is used\nCipher rsa = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n...\n\n//GOOD: OAEP padding is used\nCipher rsa = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-1AndMGF1Padding\");\n...\n```\n\n## References\n* [Mobile Security Testing Guide](https://github.com/MobSF/owasp-mstg/blob/master/Document/0x04g-Testing-Cryptography.md#padding-oracle-attacks-due-to-weaker-padding-or-block-operation-implementations).\n* [The Padding Oracle Attack](https://robertheaton.com/2013/07/29/padding-oracle-attack/).\n* Common Weakness Enumeration: [CWE-780](https://cwe.mitre.org/data/definitions/780.html).\n"},"properties":{"tags":["security","external/cwe/cwe-780"],"description":"Using RSA encryption without OAEP padding can result in a padding oracle attack, leading to a weaker encryption.","id":"java/rsa-without-oaep","kind":"path-problem","name":"Use of RSA algorithm without OAEP","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/tainted-format-string","name":"java/tainted-format-string","shortDescription":{"text":"Use of externally-controlled format string"},"fullDescription":{"text":"Using external input in format strings can lead to exceptions or information leaks."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Use of externally-controlled format string\nThe `String.format` method and related methods, like `PrintStream.printf` and `Formatter.format`, all accept a format string that is used to format the trailing arguments to the format call by providing inline format specifiers. If the format string contains unsanitized input from an untrusted source, then that string may contain extra format specifiers that cause an exception to be thrown or information to be leaked.\n\nThe Java standard library implementation for the format methods throws an exception if either the format specifier does not match the type of the argument, or if there are too few or too many arguments. If unsanitized input is used in the format string, it may contain invalid extra format specifiers which cause an exception to be thrown.\n\nPositional format specifiers may be used to access an argument to the format call by position. Unsanitized input in the format string may use a positional format specifier to access information that was not intended to be visible. For example, when formatting a Calendar instance we may intend to print only the year, but a user-specified format string may include a specifier to access the month and day.\n\n\n## Recommendation\nIf the argument passed as a format string is meant to be a plain string rather than a format string, then pass `%s` as the format string, and pass the original argument as the sole trailing argument.\n\n\n## Example\nThe following program is meant to check a card security code for a stored credit card:\n\n\n```java\npublic class ResponseSplitting extends HttpServlet {\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n  throws ServletException, IOException {\n    Calendar expirationDate = new GregorianCalendar(2017, GregorianCalendar.SEPTEMBER, 1);\n    // User provided value\n    String cardSecurityCode = request.getParameter(\"cardSecurityCode\");\n    \n    if (notValid(cardSecurityCode)) {\n      \n      /*\n       * BAD: user provided value is included in the format string.\n       * A malicious user could provide an extra format specifier, which causes an\n       * exception to be thrown. Or they could provide a %1$tm or %1$te format specifier to\n       * access the month or day of the expiration date.\n       */\n      System.out.format(cardSecurityCode +\n                          \" is not the right value. Hint: the card expires in %1$ty.\",\n                        expirationDate);\n      \n      // GOOD: %s is used to include the user-provided cardSecurityCode in the output\n      System.out.format(\"%s is not the right value. Hint: the card expires in %2$ty.\",\n                        cardSecurityCode,\n                        expirationDate);\n    }\n\n  }\n}\n```\nHowever, in the first format call it uses the cardSecurityCode provided by the user in a format string. If the user includes a format specifier in the cardSecurityCode field, they may be able to cause an exception to be thrown, or to be able to access extra information about the stored card expiration date.\n\nThe second format call shows the correct approach. The user-provided value is passed as an argument to the format call. This prevents any format specifiers in the user provided value from being evaluated.\n\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [IDS06-J. Exclude unsanitized user input from format strings](https://wiki.sei.cmu.edu/confluence/display/java/IDS06-J.+Exclude+unsanitized+user+input+from+format+strings).\n* The Java Tutorials: [Formatting Numeric Print Output](https://docs.oracle.com/javase/tutorial/java/data/numberformat.html).\n* Java API Specification: [Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html).\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n","markdown":"# Use of externally-controlled format string\nThe `String.format` method and related methods, like `PrintStream.printf` and `Formatter.format`, all accept a format string that is used to format the trailing arguments to the format call by providing inline format specifiers. If the format string contains unsanitized input from an untrusted source, then that string may contain extra format specifiers that cause an exception to be thrown or information to be leaked.\n\nThe Java standard library implementation for the format methods throws an exception if either the format specifier does not match the type of the argument, or if there are too few or too many arguments. If unsanitized input is used in the format string, it may contain invalid extra format specifiers which cause an exception to be thrown.\n\nPositional format specifiers may be used to access an argument to the format call by position. Unsanitized input in the format string may use a positional format specifier to access information that was not intended to be visible. For example, when formatting a Calendar instance we may intend to print only the year, but a user-specified format string may include a specifier to access the month and day.\n\n\n## Recommendation\nIf the argument passed as a format string is meant to be a plain string rather than a format string, then pass `%s` as the format string, and pass the original argument as the sole trailing argument.\n\n\n## Example\nThe following program is meant to check a card security code for a stored credit card:\n\n\n```java\npublic class ResponseSplitting extends HttpServlet {\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n  throws ServletException, IOException {\n    Calendar expirationDate = new GregorianCalendar(2017, GregorianCalendar.SEPTEMBER, 1);\n    // User provided value\n    String cardSecurityCode = request.getParameter(\"cardSecurityCode\");\n    \n    if (notValid(cardSecurityCode)) {\n      \n      /*\n       * BAD: user provided value is included in the format string.\n       * A malicious user could provide an extra format specifier, which causes an\n       * exception to be thrown. Or they could provide a %1$tm or %1$te format specifier to\n       * access the month or day of the expiration date.\n       */\n      System.out.format(cardSecurityCode +\n                          \" is not the right value. Hint: the card expires in %1$ty.\",\n                        expirationDate);\n      \n      // GOOD: %s is used to include the user-provided cardSecurityCode in the output\n      System.out.format(\"%s is not the right value. Hint: the card expires in %2$ty.\",\n                        cardSecurityCode,\n                        expirationDate);\n    }\n\n  }\n}\n```\nHowever, in the first format call it uses the cardSecurityCode provided by the user in a format string. If the user includes a format specifier in the cardSecurityCode field, they may be able to cause an exception to be thrown, or to be able to access extra information about the stored card expiration date.\n\nThe second format call shows the correct approach. The user-provided value is passed as an argument to the format call. This prevents any format specifiers in the user provided value from being evaluated.\n\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [IDS06-J. Exclude unsanitized user input from format strings](https://wiki.sei.cmu.edu/confluence/display/java/IDS06-J.+Exclude+unsanitized+user+input+from+format+strings).\n* The Java Tutorials: [Formatting Numeric Print Output](https://docs.oracle.com/javase/tutorial/java/data/numberformat.html).\n* Java API Specification: [Formatter](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html).\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n"},"properties":{"tags":["security","external/cwe/cwe-134"],"description":"Using external input in format strings can lead to exceptions or information leaks.","id":"java/tainted-format-string","kind":"path-problem","name":"Use of externally-controlled format string","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"java/concatenated-command-line","name":"java/concatenated-command-line","shortDescription":{"text":"Building a command line with string concatenation"},"fullDescription":{"text":"Using concatenated strings in a command line is vulnerable to malicious insertion of special characters in the strings."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Building a command line with string concatenation\nCode that builds a command line by concatenating strings that have been entered by a user allows the user to execute malicious code.\n\n\n## Recommendation\nExecute external commands using an array of strings rather than a single string. By using an array, many possible vulnerabilities in the formatting of the string are avoided.\n\n\n## Example\nIn the following example, `latlonCoords` contains a string that has been entered by a user but not validated by the program. This allows the user to, for example, append an ampersand (&amp;) followed by the command for a malicious program to the end of the string. The ampersand instructs Windows to execute another program. In the block marked 'BAD', `latlonCoords` is passed to `exec` as part of a concatenated string, which allows more than one command to be executed. However, in the block marked 'GOOD', `latlonCoords` is passed as part of an array, which means that `exec` treats it only as an argument.\n\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        // BAD: user input might include special characters such as ampersands\n        {\n            String latlonCoords = args[1];\n            Runtime rt = Runtime.getRuntime();\n            Process exec = rt.exec(\"cmd.exe /C latlon2utm.exe \" + latlonCoords);\n        }\n\n        // GOOD: use an array of arguments instead of executing a string\n        {\n            String latlonCoords = args[1];\n            Runtime rt = Runtime.getRuntime();\n            Process exec = rt.exec(new String[] {\n                    \"c:\\\\path\\to\\latlon2utm.exe\",\n                    latlonCoords });\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n","markdown":"# Building a command line with string concatenation\nCode that builds a command line by concatenating strings that have been entered by a user allows the user to execute malicious code.\n\n\n## Recommendation\nExecute external commands using an array of strings rather than a single string. By using an array, many possible vulnerabilities in the formatting of the string are avoided.\n\n\n## Example\nIn the following example, `latlonCoords` contains a string that has been entered by a user but not validated by the program. This allows the user to, for example, append an ampersand (&amp;) followed by the command for a malicious program to the end of the string. The ampersand instructs Windows to execute another program. In the block marked 'BAD', `latlonCoords` is passed to `exec` as part of a concatenated string, which allows more than one command to be executed. However, in the block marked 'GOOD', `latlonCoords` is passed as part of an array, which means that `exec` treats it only as an argument.\n\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        // BAD: user input might include special characters such as ampersands\n        {\n            String latlonCoords = args[1];\n            Runtime rt = Runtime.getRuntime();\n            Process exec = rt.exec(\"cmd.exe /C latlon2utm.exe \" + latlonCoords);\n        }\n\n        // GOOD: use an array of arguments instead of executing a string\n        {\n            String latlonCoords = args[1];\n            Runtime rt = Runtime.getRuntime();\n            Process exec = rt.exec(new String[] {\n                    \"c:\\\\path\\to\\latlon2utm.exe\",\n                    latlonCoords });\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"},"properties":{"tags":["security","external/cwe/cwe-078","external/cwe/cwe-088"],"description":"Using concatenated strings in a command line is vulnerable to malicious\n              insertion of special characters in the strings.","id":"java/concatenated-command-line","kind":"problem","name":"Building a command line with string concatenation","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"java/command-line-injection","name":"java/command-line-injection","shortDescription":{"text":"Uncontrolled command line"},"fullDescription":{"text":"Using externally controlled strings in a command line is vulnerable to malicious changes in the strings."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Uncontrolled command line\nCode that passes user input directly to `Runtime.exec`, or some other library routine that executes a command, allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to `Runtime.exec` without examining it first.\n\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        String script = System.getenv(\"SCRIPTNAME\");\n        if (script != null) {\n            // BAD: The script to be executed is controlled by the user.\n            Runtime.getRuntime().exec(script);\n        }\n    }\n}\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n","markdown":"# Uncontrolled command line\nCode that passes user input directly to `Runtime.exec`, or some other library routine that executes a command, allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to `Runtime.exec` without examining it first.\n\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        String script = System.getenv(\"SCRIPTNAME\");\n        if (script != null) {\n            // BAD: The script to be executed is controlled by the user.\n            Runtime.getRuntime().exec(script);\n        }\n    }\n}\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* SEI CERT Oracle Coding Standard for Java: [IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method](https://wiki.sei.cmu.edu/confluence/display/java/IDS07-J.+Sanitize+untrusted+data+passed+to+the+Runtime.exec()+method).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"},"properties":{"tags":["security","external/cwe/cwe-078","external/cwe/cwe-088"],"description":"Using externally controlled strings in a command line is vulnerable to malicious\n              changes in the strings.","id":"java/command-line-injection","kind":"path-problem","name":"Uncontrolled command line","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"java/netty-http-request-or-response-splitting","name":"java/netty-http-request-or-response-splitting","shortDescription":{"text":"Disabled Netty HTTP header validation"},"fullDescription":{"text":"Disabling HTTP header validation makes code vulnerable to attack by header splitting if user input is written directly to an HTTP header."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Disabled Netty HTTP header validation\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP header can lead to an HTTP request-splitting or response-splitting vulnerability.\n\nHTTP response splitting can lead to vulnerabilities such as XSS and cache poisoning.\n\nHTTP request splitting can allow an attacker to inject an additional HTTP request into a client's outgoing socket connection. This can allow an attacker to perform an SSRF-like attack.\n\nIn the context of a servlet container, if the user input includes blank lines and the servlet container does not escape the blank lines, then a remote user can cause the response to turn into two separate responses. The remote user can then control one or more responses, which is also HTTP response splitting.\n\n\n## Recommendation\nGuard against HTTP header splitting in the same way as guarding against cross-site scripting. Before passing any data into HTTP headers, either check the data for special characters, or escape any special characters that are present.\n\nIf the code calls Netty API's directly, ensure that the `validateHeaders` parameter is set to `true`.\n\n\n## Example\nThe following example shows the 'name' parameter being written to a cookie in two different ways. The first way writes it directly to the cookie, and thus is vulnerable to response-splitting attacks. The second way first removes all special characters, thus avoiding the potential problem.\n\n\n```java\npublic class ResponseSplitting extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\t// BAD: setting a cookie with an unvalidated parameter\n\t\tCookie cookie = new Cookie(\"name\", request.getParameter(\"name\"));\n\t\tresponse.addCookie(cookie);\n\n\t\t// GOOD: remove special characters before putting them in the header\n\t\tString name = removeSpecial(request.getParameter(\"name\"));\n\t\tCookie cookie2 = new Cookie(\"name\", name);\n\t\tresponse.addCookie(cookie2);\n\t}\n\n\tprivate static String removeSpecial(String str) {\n\t\treturn str.replaceAll(\"[^a-zA-Z ]\", \"\");\n\t}\n}\n\n```\n\n## Example\nThe following example shows the use of the library 'netty' with HTTP response-splitting verification configurations. The second way will verify the parameters before using them to build the HTTP response.\n\n\n```java\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\n\npublic class ResponseSplitting {\n    // BAD: Disables the internal response splitting verification\n    private final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD: Disables the internal response splitting verification\n    private final DefaultHttpResponse badResponse = new DefaultHttpResponse(version, httpResponseStatus, false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpResponse goodResponse = new DefaultHttpResponse(version, httpResponseStatus);\n}\n\n```\n\n## Example\nThe following example shows the use of the netty library with configurations for verification of HTTP request splitting. The second recommended approach in the example verifies the parameters before using them to build the HTTP request.\n\n\n```java\npublic class NettyRequestSplitting {\n    // BAD: Disables the internal request splitting verification\n    private final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD: Disables the internal request splitting verification\n    private final DefaultHttpRequest badRequest = new DefaultHttpRequest(httpVersion, method, uri, false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpRequest goodResponse = new DefaultHttpRequest(httpVersion, method, uri);\n}\n\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n* OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n* Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n* CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n* Common Weakness Enumeration: [CWE-93](https://cwe.mitre.org/data/definitions/93.html).\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n","markdown":"# Disabled Netty HTTP header validation\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP header can lead to an HTTP request-splitting or response-splitting vulnerability.\n\nHTTP response splitting can lead to vulnerabilities such as XSS and cache poisoning.\n\nHTTP request splitting can allow an attacker to inject an additional HTTP request into a client's outgoing socket connection. This can allow an attacker to perform an SSRF-like attack.\n\nIn the context of a servlet container, if the user input includes blank lines and the servlet container does not escape the blank lines, then a remote user can cause the response to turn into two separate responses. The remote user can then control one or more responses, which is also HTTP response splitting.\n\n\n## Recommendation\nGuard against HTTP header splitting in the same way as guarding against cross-site scripting. Before passing any data into HTTP headers, either check the data for special characters, or escape any special characters that are present.\n\nIf the code calls Netty API's directly, ensure that the `validateHeaders` parameter is set to `true`.\n\n\n## Example\nThe following example shows the 'name' parameter being written to a cookie in two different ways. The first way writes it directly to the cookie, and thus is vulnerable to response-splitting attacks. The second way first removes all special characters, thus avoiding the potential problem.\n\n\n```java\npublic class ResponseSplitting extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\t// BAD: setting a cookie with an unvalidated parameter\n\t\tCookie cookie = new Cookie(\"name\", request.getParameter(\"name\"));\n\t\tresponse.addCookie(cookie);\n\n\t\t// GOOD: remove special characters before putting them in the header\n\t\tString name = removeSpecial(request.getParameter(\"name\"));\n\t\tCookie cookie2 = new Cookie(\"name\", name);\n\t\tresponse.addCookie(cookie2);\n\t}\n\n\tprivate static String removeSpecial(String str) {\n\t\treturn str.replaceAll(\"[^a-zA-Z ]\", \"\");\n\t}\n}\n\n```\n\n## Example\nThe following example shows the use of the library 'netty' with HTTP response-splitting verification configurations. The second way will verify the parameters before using them to build the HTTP response.\n\n\n```java\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\n\npublic class ResponseSplitting {\n    // BAD: Disables the internal response splitting verification\n    private final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD: Disables the internal response splitting verification\n    private final DefaultHttpResponse badResponse = new DefaultHttpResponse(version, httpResponseStatus, false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpResponse goodResponse = new DefaultHttpResponse(version, httpResponseStatus);\n}\n\n```\n\n## Example\nThe following example shows the use of the netty library with configurations for verification of HTTP request splitting. The second recommended approach in the example verifies the parameters before using them to build the HTTP request.\n\n\n```java\npublic class NettyRequestSplitting {\n    // BAD: Disables the internal request splitting verification\n    private final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD: Disables the internal request splitting verification\n    private final DefaultHttpRequest badRequest = new DefaultHttpRequest(httpVersion, method, uri, false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpRequest goodResponse = new DefaultHttpRequest(httpVersion, method, uri);\n}\n\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n* OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n* Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n* CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n* Common Weakness Enumeration: [CWE-93](https://cwe.mitre.org/data/definitions/93.html).\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n"},"properties":{"tags":["security","external/cwe/cwe-93","external/cwe/cwe-113"],"description":"Disabling HTTP header validation makes code vulnerable to\n              attack by header splitting if user input is written directly to\n              an HTTP header.","id":"java/netty-http-request-or-response-splitting","kind":"problem","name":"Disabled Netty HTTP header validation","precision":"high","problem.severity":"error","security-severity":"6.1"}},{"id":"java/http-response-splitting","name":"java/http-response-splitting","shortDescription":{"text":"HTTP response splitting"},"fullDescription":{"text":"Writing user input directly to an HTTP header makes code vulnerable to attack by header splitting."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# HTTP response splitting\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP header can lead to an HTTP request-splitting or response-splitting vulnerability.\n\nHTTP response splitting can lead to vulnerabilities such as XSS and cache poisoning.\n\nHTTP request splitting can allow an attacker to inject an additional HTTP request into a client's outgoing socket connection. This can allow an attacker to perform an SSRF-like attack.\n\nIn the context of a servlet container, if the user input includes blank lines and the servlet container does not escape the blank lines, then a remote user can cause the response to turn into two separate responses. The remote user can then control one or more responses, which is also HTTP response splitting.\n\n\n## Recommendation\nGuard against HTTP header splitting in the same way as guarding against cross-site scripting. Before passing any data into HTTP headers, either check the data for special characters, or escape any special characters that are present.\n\nIf the code calls Netty API's directly, ensure that the `validateHeaders` parameter is set to `true`.\n\n\n## Example\nThe following example shows the 'name' parameter being written to a cookie in two different ways. The first way writes it directly to the cookie, and thus is vulnerable to response-splitting attacks. The second way first removes all special characters, thus avoiding the potential problem.\n\n\n```java\npublic class ResponseSplitting extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\t// BAD: setting a cookie with an unvalidated parameter\n\t\tCookie cookie = new Cookie(\"name\", request.getParameter(\"name\"));\n\t\tresponse.addCookie(cookie);\n\n\t\t// GOOD: remove special characters before putting them in the header\n\t\tString name = removeSpecial(request.getParameter(\"name\"));\n\t\tCookie cookie2 = new Cookie(\"name\", name);\n\t\tresponse.addCookie(cookie2);\n\t}\n\n\tprivate static String removeSpecial(String str) {\n\t\treturn str.replaceAll(\"[^a-zA-Z ]\", \"\");\n\t}\n}\n\n```\n\n## Example\nThe following example shows the use of the library 'netty' with HTTP response-splitting verification configurations. The second way will verify the parameters before using them to build the HTTP response.\n\n\n```java\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\n\npublic class ResponseSplitting {\n    // BAD: Disables the internal response splitting verification\n    private final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD: Disables the internal response splitting verification\n    private final DefaultHttpResponse badResponse = new DefaultHttpResponse(version, httpResponseStatus, false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpResponse goodResponse = new DefaultHttpResponse(version, httpResponseStatus);\n}\n\n```\n\n## Example\nThe following example shows the use of the netty library with configurations for verification of HTTP request splitting. The second recommended approach in the example verifies the parameters before using them to build the HTTP request.\n\n\n```java\npublic class NettyRequestSplitting {\n    // BAD: Disables the internal request splitting verification\n    private final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD: Disables the internal request splitting verification\n    private final DefaultHttpRequest badRequest = new DefaultHttpRequest(httpVersion, method, uri, false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpRequest goodResponse = new DefaultHttpRequest(httpVersion, method, uri);\n}\n\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n* OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n* Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n* CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n","markdown":"# HTTP response splitting\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP header can lead to an HTTP request-splitting or response-splitting vulnerability.\n\nHTTP response splitting can lead to vulnerabilities such as XSS and cache poisoning.\n\nHTTP request splitting can allow an attacker to inject an additional HTTP request into a client's outgoing socket connection. This can allow an attacker to perform an SSRF-like attack.\n\nIn the context of a servlet container, if the user input includes blank lines and the servlet container does not escape the blank lines, then a remote user can cause the response to turn into two separate responses. The remote user can then control one or more responses, which is also HTTP response splitting.\n\n\n## Recommendation\nGuard against HTTP header splitting in the same way as guarding against cross-site scripting. Before passing any data into HTTP headers, either check the data for special characters, or escape any special characters that are present.\n\nIf the code calls Netty API's directly, ensure that the `validateHeaders` parameter is set to `true`.\n\n\n## Example\nThe following example shows the 'name' parameter being written to a cookie in two different ways. The first way writes it directly to the cookie, and thus is vulnerable to response-splitting attacks. The second way first removes all special characters, thus avoiding the potential problem.\n\n\n```java\npublic class ResponseSplitting extends HttpServlet {\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\t// BAD: setting a cookie with an unvalidated parameter\n\t\tCookie cookie = new Cookie(\"name\", request.getParameter(\"name\"));\n\t\tresponse.addCookie(cookie);\n\n\t\t// GOOD: remove special characters before putting them in the header\n\t\tString name = removeSpecial(request.getParameter(\"name\"));\n\t\tCookie cookie2 = new Cookie(\"name\", name);\n\t\tresponse.addCookie(cookie2);\n\t}\n\n\tprivate static String removeSpecial(String str) {\n\t\treturn str.replaceAll(\"[^a-zA-Z ]\", \"\");\n\t}\n}\n\n```\n\n## Example\nThe following example shows the use of the library 'netty' with HTTP response-splitting verification configurations. The second way will verify the parameters before using them to build the HTTP response.\n\n\n```java\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\n\npublic class ResponseSplitting {\n    // BAD: Disables the internal response splitting verification\n    private final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD: Disables the internal response splitting verification\n    private final DefaultHttpResponse badResponse = new DefaultHttpResponse(version, httpResponseStatus, false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpResponse goodResponse = new DefaultHttpResponse(version, httpResponseStatus);\n}\n\n```\n\n## Example\nThe following example shows the use of the netty library with configurations for verification of HTTP request splitting. The second recommended approach in the example verifies the parameters before using them to build the HTTP request.\n\n\n```java\npublic class NettyRequestSplitting {\n    // BAD: Disables the internal request splitting verification\n    private final DefaultHttpHeaders badHeaders = new DefaultHttpHeaders(false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpHeaders goodHeaders = new DefaultHttpHeaders();\n\n    // BAD: Disables the internal request splitting verification\n    private final DefaultHttpRequest badRequest = new DefaultHttpRequest(httpVersion, method, uri, false);\n\n    // GOOD: Verifies headers passed don't contain CRLF characters\n    private final DefaultHttpRequest goodResponse = new DefaultHttpRequest(httpVersion, method, uri);\n}\n\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n* OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n* Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n* CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n"},"properties":{"tags":["security","external/cwe/cwe-113"],"description":"Writing user input directly to an HTTP header\n              makes code vulnerable to attack by header splitting.","id":"java/http-response-splitting","kind":"path-problem","name":"HTTP response splitting","precision":"high","problem.severity":"error","security-severity":"6.1"}},{"id":"java/unused-parameter","name":"java/unused-parameter","shortDescription":{"text":"Useless parameter"},"fullDescription":{"text":"Parameters that are not used add unnecessary complexity to an interface."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Useless parameter\nParameters that are never read in the body of the method, and are not required due to overriding, are useless and can be removed. Useless parameters unnecessarily complicate the interface for that method, and cause a maintenance and development burden.\n\nMethods with useless parameters indicate that either the method can be simplified by removing the parameter, or that the method is not using a value it should be using. Parameters of methods that override other methods will not be marked as useless, because they are required. Similarly, parameters of methods that are overridden by other methods are not marked as useless if they are used by one of the overriding methods.\n\n\n## Recommendation\nThe method should be inspected to determine whether the parameter should be used within the body. If the method is overridden, also consider whether any override methods should be using the parameter. If the parameter is not required, it should be removed.\n\n\n## Example\nIn the following example, we have a method for determining whether a `String` path is an absolute path:\n\n\n```java\npublic void isAbsolutePath(String path, String name) {\n\treturn path.startsWith(\"/\") || path.startsWith(\"\\\\\");\n}\n```\nThe method uses the parameter `path` to determine the return value. However, the parameter `name` is not used within the body of the method. The parameter will be marked as useless, and can be removed from the program.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n","markdown":"# Useless parameter\nParameters that are never read in the body of the method, and are not required due to overriding, are useless and can be removed. Useless parameters unnecessarily complicate the interface for that method, and cause a maintenance and development burden.\n\nMethods with useless parameters indicate that either the method can be simplified by removing the parameter, or that the method is not using a value it should be using. Parameters of methods that override other methods will not be marked as useless, because they are required. Similarly, parameters of methods that are overridden by other methods are not marked as useless if they are used by one of the overriding methods.\n\n\n## Recommendation\nThe method should be inspected to determine whether the parameter should be used within the body. If the method is overridden, also consider whether any override methods should be using the parameter. If the parameter is not required, it should be removed.\n\n\n## Example\nIn the following example, we have a method for determining whether a `String` path is an absolute path:\n\n\n```java\npublic void isAbsolutePath(String path, String name) {\n\treturn path.startsWith(\"/\") || path.startsWith(\"\\\\\");\n}\n```\nThe method uses the parameter `path` to determine the return value. However, the parameter `name` is not used within the body of the method. The parameter will be marked as useless, and can be removed from the program.\n\n\n## References\n* Wikipedia: [Redundant code](https://en.wikipedia.org/wiki/Redundant_code).\n* CERT Java Coding Standard: [MSC56-J. Detect and remove superfluous code and values](https://www.securecoding.cert.org/confluence/display/java/MSC56-J.+Detect+and+remove+superfluous+code+and+values).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"},"properties":{"tags":["maintainability","useless-code","external/cwe/cwe-561"],"description":"Parameters that are not used add unnecessary complexity to an interface.","id":"java/unused-parameter","kind":"problem","name":"Useless parameter","precision":"high","problem.severity":"recommendation"}},{"id":"java/wait-on-condition-interface","name":"java/wait-on-condition-interface","shortDescription":{"text":"Wait on condition"},"fullDescription":{"text":"Calling 'wait' on a 'Condition' interface may result in unexpected behavior and is probably a typographical error."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Wait on condition\nCalling `wait` on an object of type `java.util.concurrent.locks.Condition` may result in unexpected behavior because `wait` is a method of the `Object` class, not the `Condition` interface itself. Such a call is probably a typographical error: typing \"wait\" instead of \"await\".\n\n\n## Recommendation\nInstead of `Object.wait`, use one of the `Condition.await` methods.\n\n\n## References\n* Java API Specification: [java.util.concurrent.Condition](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html).\n* Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n","markdown":"# Wait on condition\nCalling `wait` on an object of type `java.util.concurrent.locks.Condition` may result in unexpected behavior because `wait` is a method of the `Object` class, not the `Condition` interface itself. Such a call is probably a typographical error: typing \"wait\" instead of \"await\".\n\n\n## Recommendation\nInstead of `Object.wait`, use one of the `Condition.await` methods.\n\n\n## References\n* Java API Specification: [java.util.concurrent.Condition](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html).\n* Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n"},"properties":{"tags":["reliability","correctness","concurrency","external/cwe/cwe-662"],"description":"Calling 'wait' on a 'Condition' interface may result in unexpected behavior and is\n              probably a typographical error.","id":"java/wait-on-condition-interface","kind":"problem","name":"Wait on condition","precision":"medium","problem.severity":"error"}},{"id":"java/notify-instead-of-notify-all","name":"java/notify-instead-of-notify-all","shortDescription":{"text":"notify instead of notifyAll"},"fullDescription":{"text":"Calling 'notify' instead of 'notifyAll' may fail to wake up the correct thread and cannot wake up multiple threads."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# notify instead of notifyAll\nCalls to the `notify` method rather than `notifyAll` may fail to wake up the correct thread if an object's monitor (intrinsic lock) is used for multiple conditions. `notify` only wakes up a single arbitrary thread that is waiting on the object's monitor, whereas `notifyAll` wakes up all such threads.\n\n\n## Recommendation\nEnsure that the call to `notify` instead of `notifyAll` is a correct and desirable optimization. If not, call `notifyAll` instead.\n\n\n## Example\nIn the following example, the methods `produce` and `consume` both use `notify` to tell any waiting threads that an object has been added or removed from the buffer. However, this means that only *one* thread is notified. The woken-up thread might not be able to proceed due to its condition being false, immediately going back to the waiting state. As a result no progress is made.\n\n\n```java\nclass ProducerConsumer {\n    private static final int MAX_SIZE=3;\n    private List<Object> buf = new ArrayList<Object>();\n\n    public synchronized void produce(Object o) {\n        while (buf.size()==MAX_SIZE) {\n            try {\n                wait();\n            }\n            catch (InterruptedException e) {\n               ...\n            }\n        }\n        buf.add(o);\n        notify(); // 'notify' is used\n    }\n\n    public synchronized Object consume() {\n\n        while (buf.size()==0) {\n            try {\n                wait();\n            }\n            catch (InterruptedException e) {\n                ...\n            }\n        }\n        Object o = buf.remove(0);\n        notify(); // 'notify' is used\n        return o;\n    }\n}\n\n```\nWhen using `notifyAll` instead of `notify`, *all* threads are notified, and if there are any threads that could proceed, we can be sure that at least one of them will do so.\n\n\n## References\n* J. Bloch. *Effective Java (second edition)*, p. 277. Addison-Wesley, 2008.\n* Java API Specification: [Object.notify()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notify()), [Object.notifyAll()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notifyAll()).\n* Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n","markdown":"# notify instead of notifyAll\nCalls to the `notify` method rather than `notifyAll` may fail to wake up the correct thread if an object's monitor (intrinsic lock) is used for multiple conditions. `notify` only wakes up a single arbitrary thread that is waiting on the object's monitor, whereas `notifyAll` wakes up all such threads.\n\n\n## Recommendation\nEnsure that the call to `notify` instead of `notifyAll` is a correct and desirable optimization. If not, call `notifyAll` instead.\n\n\n## Example\nIn the following example, the methods `produce` and `consume` both use `notify` to tell any waiting threads that an object has been added or removed from the buffer. However, this means that only *one* thread is notified. The woken-up thread might not be able to proceed due to its condition being false, immediately going back to the waiting state. As a result no progress is made.\n\n\n```java\nclass ProducerConsumer {\n    private static final int MAX_SIZE=3;\n    private List<Object> buf = new ArrayList<Object>();\n\n    public synchronized void produce(Object o) {\n        while (buf.size()==MAX_SIZE) {\n            try {\n                wait();\n            }\n            catch (InterruptedException e) {\n               ...\n            }\n        }\n        buf.add(o);\n        notify(); // 'notify' is used\n    }\n\n    public synchronized Object consume() {\n\n        while (buf.size()==0) {\n            try {\n                wait();\n            }\n            catch (InterruptedException e) {\n                ...\n            }\n        }\n        Object o = buf.remove(0);\n        notify(); // 'notify' is used\n        return o;\n    }\n}\n\n```\nWhen using `notifyAll` instead of `notify`, *all* threads are notified, and if there are any threads that could proceed, we can be sure that at least one of them will do so.\n\n\n## References\n* J. Bloch. *Effective Java (second edition)*, p. 277. Addison-Wesley, 2008.\n* Java API Specification: [Object.notify()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notify()), [Object.notifyAll()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notifyAll()).\n* Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n"},"properties":{"tags":["reliability","correctness","concurrency","external/cwe/cwe-662"],"description":"Calling 'notify' instead of 'notifyAll' may fail to wake up the correct thread and\n              cannot wake up multiple threads.","id":"java/notify-instead-of-notify-all","kind":"problem","name":"notify instead of notifyAll","precision":"medium","problem.severity":"warning"}},{"id":"java/sleep-with-lock-held","name":"java/sleep-with-lock-held","shortDescription":{"text":"Sleep with lock held"},"fullDescription":{"text":"Calling 'Thread.sleep' with a lock held may lead to very poor performance or even deadlock."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Sleep with lock held\nCalling `Thread.sleep` with a lock held may lead to very poor performance or even deadlock. This is because `Thread.sleep` does not cause a thread to release its locks.\n\n\n## Recommendation\n`Thread.sleep` should be called only outside of a `synchronized` block. However, a better way for threads to yield execution time to other threads may be to use either of the following solutions:\n\n* The `java.util.concurrent` library\n* The `wait` and `notifyAll` methods\n\n## Example\nIn the following example of the problem, two threads, `StorageThread` and `OtherThread`, are started. Both threads output a message to show that they have started but then `StorageThread` locks `counter` and goes to sleep. The lock prevents `OtherThread` from locking `counter`, so it has to wait until `StorageThread` has woken up and unlocked `counter` before it can continue.\n\n\n```java\nclass StorageThread implements Runnable{\n    public static Integer counter = 0;\n    private static final Object LOCK = new Object();\n\n    public void run() {\n        System.out.println(\"StorageThread started.\");\n        synchronized(LOCK) {  // \"LOCK\" is locked just before the thread goes to sleep\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) { ... }\n        }\n        System.out.println(\"StorageThread exited.\");\n    }\n}\n\nclass OtherThread implements Runnable{\n    public void run() {\n        System.out.println(\"OtherThread started.\");\n        synchronized(StorageThread.LOCK) {\n            StorageThread.counter++;\n        }\n        System.out.println(\"OtherThread exited.\");\n    }\n}\n\npublic class SleepWithLock {\n    public static void main(String[] args) {\n        new Thread(new StorageThread()).start();\n        new Thread(new OtherThread()).start();\n    }\n}\n\n```\nTo avoid this problem, `StorageThread` should call `Thread.sleep` outside the `synchronized` block instead, so that `counter` is unlocked.\n\n\n## References\n* Java API Specification: [Thread.sleep()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#sleep(long)), [Object.wait()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait()), [Object.notifyAll()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notifyAll()), [java.util.concurrent](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html).\n* Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).\n","markdown":"# Sleep with lock held\nCalling `Thread.sleep` with a lock held may lead to very poor performance or even deadlock. This is because `Thread.sleep` does not cause a thread to release its locks.\n\n\n## Recommendation\n`Thread.sleep` should be called only outside of a `synchronized` block. However, a better way for threads to yield execution time to other threads may be to use either of the following solutions:\n\n* The `java.util.concurrent` library\n* The `wait` and `notifyAll` methods\n\n## Example\nIn the following example of the problem, two threads, `StorageThread` and `OtherThread`, are started. Both threads output a message to show that they have started but then `StorageThread` locks `counter` and goes to sleep. The lock prevents `OtherThread` from locking `counter`, so it has to wait until `StorageThread` has woken up and unlocked `counter` before it can continue.\n\n\n```java\nclass StorageThread implements Runnable{\n    public static Integer counter = 0;\n    private static final Object LOCK = new Object();\n\n    public void run() {\n        System.out.println(\"StorageThread started.\");\n        synchronized(LOCK) {  // \"LOCK\" is locked just before the thread goes to sleep\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) { ... }\n        }\n        System.out.println(\"StorageThread exited.\");\n    }\n}\n\nclass OtherThread implements Runnable{\n    public void run() {\n        System.out.println(\"OtherThread started.\");\n        synchronized(StorageThread.LOCK) {\n            StorageThread.counter++;\n        }\n        System.out.println(\"OtherThread exited.\");\n    }\n}\n\npublic class SleepWithLock {\n    public static void main(String[] args) {\n        new Thread(new StorageThread()).start();\n        new Thread(new OtherThread()).start();\n    }\n}\n\n```\nTo avoid this problem, `StorageThread` should call `Thread.sleep` outside the `synchronized` block instead, so that `counter` is unlocked.\n\n\n## References\n* Java API Specification: [Thread.sleep()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#sleep(long)), [Object.wait()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait()), [Object.notifyAll()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#notifyAll()), [java.util.concurrent](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html).\n* Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).\n"},"properties":{"tags":["reliability","correctness","concurrency","external/cwe/cwe-833"],"description":"Calling 'Thread.sleep' with a lock held may lead to very poor\n              performance or even deadlock.","id":"java/sleep-with-lock-held","kind":"problem","name":"Sleep with lock held","precision":"medium","problem.severity":"error"}},{"id":"java/inconsistent-sync-writeobject","name":"java/inconsistent-sync-writeobject","shortDescription":{"text":"Inconsistent synchronization for writeObject()"},"fullDescription":{"text":"Classes with a synchronized 'writeObject' method but no other synchronized methods usually lack a sufficient level of synchronization."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Inconsistent synchronization for writeObject()\nClasses with a synchronized `writeObject` method but no other synchronized methods usually lack a sufficient level of synchronization. If any mutable state of this class can be modified without proper synchronization, the serialization using the `writeObject` method may result in an inconsistent state.\n\n\n## Recommendation\nSee if synchronization is necessary on methods other than `writeOject` to make the class thread-safe. Any methods that access or modify the state of an object of this class should usually be synchronized as well.\n\n\n## References\n* Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).\n* Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n","markdown":"# Inconsistent synchronization for writeObject()\nClasses with a synchronized `writeObject` method but no other synchronized methods usually lack a sufficient level of synchronization. If any mutable state of this class can be modified without proper synchronization, the serialization using the `writeObject` method may result in an inconsistent state.\n\n\n## Recommendation\nSee if synchronization is necessary on methods other than `writeOject` to make the class thread-safe. Any methods that access or modify the state of an object of this class should usually be synchronized as well.\n\n\n## References\n* Java Language Specification: [Synchronization](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.1).\n* Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n"},"properties":{"tags":["reliability","correctness","concurrency","language-features","external/cwe/cwe-662"],"description":"Classes with a synchronized 'writeObject' method but no other\n              synchronized methods usually lack a sufficient level of synchronization.","id":"java/inconsistent-sync-writeobject","kind":"problem","name":"Inconsistent synchronization for writeObject()","precision":"medium","problem.severity":"warning"}},{"id":"java/thread-unsafe-dateformat","name":"java/thread-unsafe-dateformat","shortDescription":{"text":"Thread-unsafe use of DateFormat"},"fullDescription":{"text":"Static fields of type 'DateFormat' (or its descendants) should be avoided because the class 'DateFormat' is not thread-safe."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Thread-unsafe use of DateFormat\nStatic fields of type `java.text.DateFormat` or its descendants should be avoided because the class `DateFormat` is not thread-safe.\n\n\n## Recommendation\nUse instance fields instead and synchronize access where necessary.\n\n\n## Example\nIn the following example, `DateFormattingThread` declares a static field `dateF` of type `DateFormat`. When instances of `DateFormattingThread` are created and run by `DateFormatThreadUnsafe`, erroneous results are output because `dateF` is shared by all instances of `DateFormattingThread`.\n\n\n```java\nclass DateFormattingThread implements Runnable {\n    public static DateFormat dateF = new SimpleDateFormat(\"yyyyMMdd\");  // Static field declared\n\n    public void run() {\n        for(int i=0; i < 10; i++){\n            try {\n                Date d = dateF.parse(\"20121221\");\n                System.out.println(d);\n            } catch (ParseException e) { }\n        }\n    }\n}\n\npublic class DateFormatThreadUnsafe {\n    \n    public static void main(String[] args) {\n        for(int i=0; i<100; i++){\n            new Thread(new DateFormattingThread()).start();\n        }\n    }\n\n}\n```\nIn the following modification of the above example, `DateFormattingThread` declares an *instance* field `dateF` of type `DateFormat`. When instances of `DateFormattingThread` are created and run by `DateFormatThreadUnsafeFix`, correct results are output because there is a separate instance of `dateF` for each instance of `DateFormattingThread`.\n\n\n```java\nclass DateFormattingThread implements Runnable {\n    private DateFormat dateF = new SimpleDateFormat(\"yyyyMMdd\");  // Instance field declared\n\n    public void run() {\n        for(int i=0; i < 10; i++){\n            try {\n                Date d = dateF.parse(\"20121221\");\n                System.out.println(d);\n            } catch (ParseException e) { }\n        }\n    }\n}\n\npublic class DateFormatThreadUnsafeFix {\n    \n    public static void main(String[] args) {\n        for(int i=0; i<100; i++){\n            new Thread(new DateFormattingThread()).start();\n        }\n    }\n\n}\n```\n\n## References\n* Java API Specification: [java.text.DateFormat synchronization](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DateFormat.html#synchronization).\n","markdown":"# Thread-unsafe use of DateFormat\nStatic fields of type `java.text.DateFormat` or its descendants should be avoided because the class `DateFormat` is not thread-safe.\n\n\n## Recommendation\nUse instance fields instead and synchronize access where necessary.\n\n\n## Example\nIn the following example, `DateFormattingThread` declares a static field `dateF` of type `DateFormat`. When instances of `DateFormattingThread` are created and run by `DateFormatThreadUnsafe`, erroneous results are output because `dateF` is shared by all instances of `DateFormattingThread`.\n\n\n```java\nclass DateFormattingThread implements Runnable {\n    public static DateFormat dateF = new SimpleDateFormat(\"yyyyMMdd\");  // Static field declared\n\n    public void run() {\n        for(int i=0; i < 10; i++){\n            try {\n                Date d = dateF.parse(\"20121221\");\n                System.out.println(d);\n            } catch (ParseException e) { }\n        }\n    }\n}\n\npublic class DateFormatThreadUnsafe {\n    \n    public static void main(String[] args) {\n        for(int i=0; i<100; i++){\n            new Thread(new DateFormattingThread()).start();\n        }\n    }\n\n}\n```\nIn the following modification of the above example, `DateFormattingThread` declares an *instance* field `dateF` of type `DateFormat`. When instances of `DateFormattingThread` are created and run by `DateFormatThreadUnsafeFix`, correct results are output because there is a separate instance of `dateF` for each instance of `DateFormattingThread`.\n\n\n```java\nclass DateFormattingThread implements Runnable {\n    private DateFormat dateF = new SimpleDateFormat(\"yyyyMMdd\");  // Instance field declared\n\n    public void run() {\n        for(int i=0; i < 10; i++){\n            try {\n                Date d = dateF.parse(\"20121221\");\n                System.out.println(d);\n            } catch (ParseException e) { }\n        }\n    }\n}\n\npublic class DateFormatThreadUnsafeFix {\n    \n    public static void main(String[] args) {\n        for(int i=0; i<100; i++){\n            new Thread(new DateFormattingThread()).start();\n        }\n    }\n\n}\n```\n\n## References\n* Java API Specification: [java.text.DateFormat synchronization](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DateFormat.html#synchronization).\n"},"properties":{"tags":["reliability","correctness","concurrency"],"description":"Static fields of type 'DateFormat' (or its descendants) should be avoided\n              because the class 'DateFormat' is not thread-safe.","id":"java/thread-unsafe-dateformat","kind":"problem","name":"Thread-unsafe use of DateFormat","precision":"medium","problem.severity":"warning"}},{"id":"java/unreleased-lock","name":"java/unreleased-lock","shortDescription":{"text":"Unreleased lock"},"fullDescription":{"text":"A lock that is acquired one or more times without a matching number of unlocks may cause a deadlock."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Unreleased lock\nWhen a thread acquires a lock it must make sure to unlock it again; failing to do so can lead to deadlocks. If a lock allows a thread to acquire it multiple times, for example `java.util.concurrent.locks.ReentrantLock`, then the number of locks must match the number of unlocks in order to fully release the lock.\n\n\n## Recommendation\nIt is recommended practice always to immediately follow a call to `lock` with a `try` block and place the call to `unlock` inside the `finally` block. Beware of calls inside the `finally` block that could cause exceptions, as this may result in skipping the call to `unlock`.\n\n\n## Example\nThe typical pattern for using locks safely looks like this:\n\n\n```java\npublic void m() {\n   lock.lock();\n   // A\n   try {\n      // ... method body\n   } finally {\n      // B\n      lock.unlock();\n   }\n}\n```\nIf any code that can cause a premature method exit (for example by throwing an exception) is inserted at either point `A` or `B` then the method might not unlock, so this should be avoided.\n\n\n## References\n* Java API Specification: [java.util.concurrent.locks.Lock](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Lock.html), [java.util.concurrent.locks.ReentrantLock](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html).\n* Common Weakness Enumeration: [CWE-764](https://cwe.mitre.org/data/definitions/764.html).\n* Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).\n","markdown":"# Unreleased lock\nWhen a thread acquires a lock it must make sure to unlock it again; failing to do so can lead to deadlocks. If a lock allows a thread to acquire it multiple times, for example `java.util.concurrent.locks.ReentrantLock`, then the number of locks must match the number of unlocks in order to fully release the lock.\n\n\n## Recommendation\nIt is recommended practice always to immediately follow a call to `lock` with a `try` block and place the call to `unlock` inside the `finally` block. Beware of calls inside the `finally` block that could cause exceptions, as this may result in skipping the call to `unlock`.\n\n\n## Example\nThe typical pattern for using locks safely looks like this:\n\n\n```java\npublic void m() {\n   lock.lock();\n   // A\n   try {\n      // ... method body\n   } finally {\n      // B\n      lock.unlock();\n   }\n}\n```\nIf any code that can cause a premature method exit (for example by throwing an exception) is inserted at either point `A` or `B` then the method might not unlock, so this should be avoided.\n\n\n## References\n* Java API Specification: [java.util.concurrent.locks.Lock](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Lock.html), [java.util.concurrent.locks.ReentrantLock](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html).\n* Common Weakness Enumeration: [CWE-764](https://cwe.mitre.org/data/definitions/764.html).\n* Common Weakness Enumeration: [CWE-833](https://cwe.mitre.org/data/definitions/833.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-764","external/cwe/cwe-833"],"description":"A lock that is acquired one or more times without a matching number of unlocks\n              may cause a deadlock.","id":"java/unreleased-lock","kind":"problem","name":"Unreleased lock","precision":"medium","problem.severity":"error","security-severity":"5.0"}},{"id":"java/thread-start-in-constructor","name":"java/thread-start-in-constructor","shortDescription":{"text":"Start of thread in constructor"},"fullDescription":{"text":"Starting a thread within a constructor may cause the thread to start before any subclass constructor has completed its initialization, causing unexpected results."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Start of thread in constructor\nStarting a thread within a constructor may cause unexpected results. If the class is extended, the thread may start before the subclass constructor has completed its initialization, which may not be intended.\n\n\n## Recommendation\nAvoid starting threads in constructors. Typically, the constructor of a class only *constructs* the thread object, and a separate `start` method should be provided to *start* the thread object created by the constructor.\n\n\n## Example\nIn the following example, because the `Test` constructor implicitly calls the `Super` constructor, the thread created in the `Super` constructor may start before `this.name` has been initialized. Therefore, the program may output \"hello \" followed by a null string.\n\n\n```java\nclass Super {\n    public Super() {\n        new Thread() {\n            public void run() {\n                System.out.println(Super.this.toString());\n            }\n        }.start(); // BAD: The thread is started in the constructor of 'Super'.\n    }\n\n    public String toString() {\n        return \"hello\";\n    }\n}\n\nclass Test extends Super {\n    private String name;\n    public Test(String nm) {\n        // The thread is started before\n        // this line is run\n        this.name = nm;\n    }\n\n    public String toString() {\n        return super.toString() + \" \" + name;\n    }\n\n    public static void main(String[] args) {\n        new Test(\"my friend\");\n    }\n}\n```\nIn the following modified example, the thread created in the `Super` constructor is not started within the constructor; `main` starts the thread after `this.name` has been initialized. This results in the program outputting \"hello my friend\".\n\n\n```java\nclass Super {\n    Thread thread;\n    public Super() {\n        thread = new Thread() {\n            public void run() {\n                System.out.println(Super.this.toString());\n            }\n        };\n    }\n\n    public void start() {  // good\n        thread.start();\n    }\n    \n    public String toString() {\n        return \"hello\";\n    }\n}\n\nclass Test extends Super {\n    private String name;\n    public Test(String nm) {\n        this.name = nm;\n    }\n\n    public String toString() {\n        return super.toString() + \" \" + name;\n    }\n\n    public static void main(String[] args) {\n        Test t = new Test(\"my friend\");\n        t.start();\n    }\n}\n```\n\n## References\n* IBM developerWorks: [Don't start threads from within constructors](https://web.archive.org/web/20200417101823/http://www.ibm.com/developerworks/java/library/j-jtp0618/index.html#4).\n","markdown":"# Start of thread in constructor\nStarting a thread within a constructor may cause unexpected results. If the class is extended, the thread may start before the subclass constructor has completed its initialization, which may not be intended.\n\n\n## Recommendation\nAvoid starting threads in constructors. Typically, the constructor of a class only *constructs* the thread object, and a separate `start` method should be provided to *start* the thread object created by the constructor.\n\n\n## Example\nIn the following example, because the `Test` constructor implicitly calls the `Super` constructor, the thread created in the `Super` constructor may start before `this.name` has been initialized. Therefore, the program may output \"hello \" followed by a null string.\n\n\n```java\nclass Super {\n    public Super() {\n        new Thread() {\n            public void run() {\n                System.out.println(Super.this.toString());\n            }\n        }.start(); // BAD: The thread is started in the constructor of 'Super'.\n    }\n\n    public String toString() {\n        return \"hello\";\n    }\n}\n\nclass Test extends Super {\n    private String name;\n    public Test(String nm) {\n        // The thread is started before\n        // this line is run\n        this.name = nm;\n    }\n\n    public String toString() {\n        return super.toString() + \" \" + name;\n    }\n\n    public static void main(String[] args) {\n        new Test(\"my friend\");\n    }\n}\n```\nIn the following modified example, the thread created in the `Super` constructor is not started within the constructor; `main` starts the thread after `this.name` has been initialized. This results in the program outputting \"hello my friend\".\n\n\n```java\nclass Super {\n    Thread thread;\n    public Super() {\n        thread = new Thread() {\n            public void run() {\n                System.out.println(Super.this.toString());\n            }\n        };\n    }\n\n    public void start() {  // good\n        thread.start();\n    }\n    \n    public String toString() {\n        return \"hello\";\n    }\n}\n\nclass Test extends Super {\n    private String name;\n    public Test(String nm) {\n        this.name = nm;\n    }\n\n    public String toString() {\n        return super.toString() + \" \" + name;\n    }\n\n    public static void main(String[] args) {\n        Test t = new Test(\"my friend\");\n        t.start();\n    }\n}\n```\n\n## References\n* IBM developerWorks: [Don't start threads from within constructors](https://web.archive.org/web/20200417101823/http://www.ibm.com/developerworks/java/library/j-jtp0618/index.html#4).\n"},"properties":{"tags":["reliability","correctness","concurrency"],"description":"Starting a thread within a constructor may cause the thread to start before\n              any subclass constructor has completed its initialization, causing unexpected\n              results.","id":"java/thread-start-in-constructor","kind":"problem","name":"Start of thread in constructor","precision":"medium","problem.severity":"warning"}},{"id":"java/unsafe-sync-on-field","name":"java/unsafe-sync-on-field","shortDescription":{"text":"Futile synchronization on field"},"fullDescription":{"text":"Synchronizing on a field and updating that field while the lock is held is unlikely to provide the desired thread safety."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Futile synchronization on field\nA block of code that synchronizes on a field and updates that field while the lock is held is unlikely to provide the desired thread safety. Such a synchronized block does not prevent multiple unsynchronized assignments to that field because it obtains a lock on the object stored *in* the field rather than the field itself.\n\n\n## Recommendation\nInstead of synchronizing on the field itself, consider synchronizing on a separate lock object when you want to avoid simultaneous updates to the field. You can do this by declaring a synchronized method and using it for any field updates.\n\n\n## Example\nIn the following example, in class A, synchronization takes place on the field that is updated in the body of the `setField` method.\n\n\n```java\npublic class A {\n    private Object field;  \n    \n    public void setField(Object o){\n        synchronized (field){    // BAD: synchronize on the field to be updated\n            field = o;\n            // ... more code ...          \n        }\n    }\n}\n```\nIn class B, the recommended approach is shown, where synchronization takes place on a separate lock object.\n\n\n```java\npublic class B {\n   private final Object lock = new Object();\n   private Object field;\n\n   public void setField(Object o){\n       synchronized (lock){      // GOOD: synchronize on a separate lock object\n           field = o;\n           // ... more code ...\n       }\n   }\n}\n```\n\n## References\n* Java Language Specification: [The synchronized Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.19), [synchronized Methods](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.3.6).\n* The Java Tutorials: [Lock Objects](https://docs.oracle.com/javase/tutorial/essential/concurrency/newlocks.html).\n* Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n","markdown":"# Futile synchronization on field\nA block of code that synchronizes on a field and updates that field while the lock is held is unlikely to provide the desired thread safety. Such a synchronized block does not prevent multiple unsynchronized assignments to that field because it obtains a lock on the object stored *in* the field rather than the field itself.\n\n\n## Recommendation\nInstead of synchronizing on the field itself, consider synchronizing on a separate lock object when you want to avoid simultaneous updates to the field. You can do this by declaring a synchronized method and using it for any field updates.\n\n\n## Example\nIn the following example, in class A, synchronization takes place on the field that is updated in the body of the `setField` method.\n\n\n```java\npublic class A {\n    private Object field;  \n    \n    public void setField(Object o){\n        synchronized (field){    // BAD: synchronize on the field to be updated\n            field = o;\n            // ... more code ...          \n        }\n    }\n}\n```\nIn class B, the recommended approach is shown, where synchronization takes place on a separate lock object.\n\n\n```java\npublic class B {\n   private final Object lock = new Object();\n   private Object field;\n\n   public void setField(Object o){\n       synchronized (lock){      // GOOD: synchronize on a separate lock object\n           field = o;\n           // ... more code ...\n       }\n   }\n}\n```\n\n## References\n* Java Language Specification: [The synchronized Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.19), [synchronized Methods](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.3.6).\n* The Java Tutorials: [Lock Objects](https://docs.oracle.com/javase/tutorial/essential/concurrency/newlocks.html).\n* Common Weakness Enumeration: [CWE-662](https://cwe.mitre.org/data/definitions/662.html).\n"},"properties":{"tags":["reliability","correctness","concurrency","language-features","external/cwe/cwe-662"],"description":"Synchronizing on a field and updating that field while the lock is held is unlikely\n              to provide the desired thread safety.","id":"java/unsafe-sync-on-field","kind":"problem","name":"Futile synchronization on field","precision":"medium","problem.severity":"error"}},{"id":"java/wrong-junit-suite-signature","name":"java/wrong-junit-suite-signature","shortDescription":{"text":"Bad suite method"},"fullDescription":{"text":"A 'suite' method in a JUnit 3.8 test that does not match the expected signature is not detected by JUnit."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Bad suite method\nJUnit 3.8 requires that a `suite` method for defining a `TestSuite` that will be used by a `TestRunner` has a specific signature. If the `suite` method does not have the expected signature, JUnit does not detect the method as a `suite` method.\n\n\n## Recommendation\nMake sure that `suite` methods in junit `TestCase` classes are declared both `public` and `static`, and that they have a return type of `junit.framework.Test` or one of its subtypes.\n\n\n## Example\nIn the following example, `BadSuiteMethod.suite` is not detected by JUnit because it is not declared `public`. However, `CorrectSuiteMethod.suite` *is* detected by JUnit because it has the expected signature.\n\n\n```java\npublic class BadSuiteMethod extends TestCase {\n\t// BAD: JUnit 3.8 does not detect the following method as a 'suite' method.\n\t// The method should be public, static, and return 'junit.framework.Test' \n\t// or one of its subtypes.\n\tstatic Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n\npublic class CorrectSuiteMethod extends TestCase {\n\t// GOOD: JUnit 3.8 correctly detects the following method as a 'suite' method.\n\tpublic static Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n","markdown":"# Bad suite method\nJUnit 3.8 requires that a `suite` method for defining a `TestSuite` that will be used by a `TestRunner` has a specific signature. If the `suite` method does not have the expected signature, JUnit does not detect the method as a `suite` method.\n\n\n## Recommendation\nMake sure that `suite` methods in junit `TestCase` classes are declared both `public` and `static`, and that they have a return type of `junit.framework.Test` or one of its subtypes.\n\n\n## Example\nIn the following example, `BadSuiteMethod.suite` is not detected by JUnit because it is not declared `public`. However, `CorrectSuiteMethod.suite` *is* detected by JUnit because it has the expected signature.\n\n\n```java\npublic class BadSuiteMethod extends TestCase {\n\t// BAD: JUnit 3.8 does not detect the following method as a 'suite' method.\n\t// The method should be public, static, and return 'junit.framework.Test' \n\t// or one of its subtypes.\n\tstatic Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n\npublic class CorrectSuiteMethod extends TestCase {\n\t// GOOD: JUnit 3.8 correctly detects the following method as a 'suite' method.\n\tpublic static Test suite() {\n\t\tTestSuite suite = new TestSuite();\n\t\tsuite.addTest(new MyTests(\"testEquals\"));\n\t\tsuite.addTest(new MyTests(\"testNotEquals\"));\n\t\treturn suite;\n\t}\n}\n```\n\n## References\n* JUnit: [JUnit Cookbook](http://junit.sourceforge.net/junit3.8.1/doc/cookbook/cookbook.htm).\n"},"properties":{"tags":["testability","maintainability","frameworks/junit"],"description":"A 'suite' method in a JUnit 3.8 test that does not match the expected signature is not\n              detected by JUnit.","id":"java/wrong-junit-suite-signature","kind":"problem","name":"Bad suite method","precision":"medium","problem.severity":"warning"}},{"id":"java/wrong-swing-event-adapter-signature","name":"java/wrong-swing-event-adapter-signature","shortDescription":{"text":"Bad implementation of an event Adapter"},"fullDescription":{"text":"In a class that extends a Swing or Abstract Window Toolkit event adapter, an event handler that does not have exactly the same name as the event handler that it overrides means that the overridden event handler is not called."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Bad implementation of an event Adapter\nEvent adapters in Swing (and Abstract Window Toolkit) provide a convenient way for programmers to implement event listeners. However, care must be taken to get the names of the overridden methods right, or the event handlers will not be called.\n\n\n## In Depth\nThe event listener interfaces in Swing (and Abstract Window Toolkit) have many methods. For example, `java.awt.event.MouseListener` is defined as follows:\n\n```java\npublic interface MouseListener extends EventListener {\n    public abstract void mouseClicked(MouseEvent);\n    public abstract void mousePressed(MouseEvent);\n    public abstract void mouseReleased(MouseEvent);\n    public abstract void mouseEntered(MouseEvent);\n    public abstract void mouseExited(MouseEvent);\n}\n```\nThe large number of methods can make such interfaces lengthy and tedious to implement, especially because it is rare that all of the methods need to be overridden. It is much more common that you need to override only one method, for example the `mouseClicked` event.\n\nFor this reason, Swing supplies *adapter* classes that provide default, blank implementations of interface methods. An example is `MouseAdapter`, which provides default implementations for the methods in `MouseListener`, `MouseWheelListener` and `MouseMotionListener`. (Note that an adapter often implements multiple interfaces to avoid a large number of small adapter classes.) This makes it easy for programmers to implement just the methods they need from a given interface.\n\nUnfortunately, adapter classes are also a source of potential defects. Because the `@Override` annotation is not compulsory, it is very easy for programmers not to use it and then mistype the name of the method. This introduces a new method rather than implementing the relevant event handler.\n\n\n## Recommendation\nEnsure that any overriding methods have exactly the same name as the overridden method.\n\n\n## Example\nIn the following example, the programmer has tried to implement the `mouseClicked` function but has misspelled the function name. This makes the function inoperable but the programmer gets no warning about this from the compiler.\n\n\n```java\nadd(new MouseAdapter() {\n    public void mouseClickd(MouseEvent e) {\n        // ...\n    }\n});\n```\nIn the following modified example, the function name is spelled correctly. It is also preceded by the `@Override` annotation, which will cause the compiler to display an error if there is not a function of the same name to be overridden.\n\n\n```java\nadd(new MouseAdapter() {\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // ...\n    }\n});\n```\n\n## References\n* D. Flanagan, *Java Foundation Classes in a Nutshell*, Chapter 26. O'Reilly, 1999.\n* Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n* The Java Tutorials: [Event Adapters](https://docs.oracle.com/javase/tutorial/uiswing/events/generalrules.html#eventAdapters).\n","markdown":"# Bad implementation of an event Adapter\nEvent adapters in Swing (and Abstract Window Toolkit) provide a convenient way for programmers to implement event listeners. However, care must be taken to get the names of the overridden methods right, or the event handlers will not be called.\n\n\n## In Depth\nThe event listener interfaces in Swing (and Abstract Window Toolkit) have many methods. For example, `java.awt.event.MouseListener` is defined as follows:\n\n```java\npublic interface MouseListener extends EventListener {\n    public abstract void mouseClicked(MouseEvent);\n    public abstract void mousePressed(MouseEvent);\n    public abstract void mouseReleased(MouseEvent);\n    public abstract void mouseEntered(MouseEvent);\n    public abstract void mouseExited(MouseEvent);\n}\n```\nThe large number of methods can make such interfaces lengthy and tedious to implement, especially because it is rare that all of the methods need to be overridden. It is much more common that you need to override only one method, for example the `mouseClicked` event.\n\nFor this reason, Swing supplies *adapter* classes that provide default, blank implementations of interface methods. An example is `MouseAdapter`, which provides default implementations for the methods in `MouseListener`, `MouseWheelListener` and `MouseMotionListener`. (Note that an adapter often implements multiple interfaces to avoid a large number of small adapter classes.) This makes it easy for programmers to implement just the methods they need from a given interface.\n\nUnfortunately, adapter classes are also a source of potential defects. Because the `@Override` annotation is not compulsory, it is very easy for programmers not to use it and then mistype the name of the method. This introduces a new method rather than implementing the relevant event handler.\n\n\n## Recommendation\nEnsure that any overriding methods have exactly the same name as the overridden method.\n\n\n## Example\nIn the following example, the programmer has tried to implement the `mouseClicked` function but has misspelled the function name. This makes the function inoperable but the programmer gets no warning about this from the compiler.\n\n\n```java\nadd(new MouseAdapter() {\n    public void mouseClickd(MouseEvent e) {\n        // ...\n    }\n});\n```\nIn the following modified example, the function name is spelled correctly. It is also preceded by the `@Override` annotation, which will cause the compiler to display an error if there is not a function of the same name to be overridden.\n\n\n```java\nadd(new MouseAdapter() {\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // ...\n    }\n});\n```\n\n## References\n* D. Flanagan, *Java Foundation Classes in a Nutshell*, Chapter 26. O'Reilly, 1999.\n* Java API Specification: [Annotation Type Override](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Override.html).\n* The Java Tutorials: [Event Adapters](https://docs.oracle.com/javase/tutorial/uiswing/events/generalrules.html#eventAdapters).\n"},"properties":{"tags":["reliability","maintainability","frameworks/swing"],"description":"In a class that extends a Swing or Abstract Window Toolkit event adapter, an\n              event handler that does not have exactly the same name as the event handler that it\n              overrides means that the overridden event handler is not called.","id":"java/wrong-swing-event-adapter-signature","kind":"problem","name":"Bad implementation of an event Adapter","precision":"medium","problem.severity":"warning"}},{"id":"java/missing-super-finalize","name":"java/missing-super-finalize","shortDescription":{"text":"Finalizer inconsistency"},"fullDescription":{"text":"A 'finalize' method that does not call 'super.finalize' may leave cleanup actions undone."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Finalizer inconsistency\nA `finalize` method that overrides the finalizer of a superclass but does not call `super.finalize` may leave system resources undisposed of or cause other cleanup actions to be left undone.\n\n\n## Recommendation\nMake sure that all `finalize` methods call `super.finalize` to ensure that the finalizer of its superclass is executed. Finalizer chaining is not automatic in Java.\n\nIt is also possible to defend against subclasses that do not call `super.finalize` by putting the cleanup code into a *finalizer guardian* instead of the `finalize` method. A finalizer guardian is an anonymous object instance that contains the cleanup code for the enclosing object in its `finalize` method. The only reference to the finalizer guardian is stored in a private field of the enclosing instance, which means that both the guardian and the enclosing instance can be finalized at the same time. This way, a subclass cannot block the execution of the cleanup code by not calling `super.finalize`.\n\n\n## Example\nIn the following example, `WrongCache.finalize` does not call `super.finalize`, which means that native resources are not disposed of. However, `RightCache.finalize` *does* call `super.finalize`, which means that native resources *are* disposed of.\n\n\n```java\nclass LocalCache {\n    private Collection<NativeResource> localResources;\n\n    //...\n\n    protected void finalize() throws Throwable {\n        for (NativeResource r : localResources) {\n            r.dispose();\n        }\n    };\n}\n\nclass WrongCache extends LocalCache {\n    //...\n    @Override\n    protected void finalize() throws Throwable {\n        // BAD: Empty 'finalize', which does not call 'super.finalize'.\n        //        Native resources in LocalCache are not disposed of.\n    }\n}\n\nclass RightCache extends LocalCache {\n    //...\n    @Override\n    protected void finalize() throws Throwable {\n        // GOOD: 'finalize' calls 'super.finalize'.\n        //        Native resources in LocalCache are disposed of.\n        super.finalize();\n    }\n}\n\n```\nThe following example shows a finalizer guardian.\n\n\n```java\nclass GuardedLocalCache {\n\tprivate Collection<NativeResource> localResources;\n\t// A finalizer guardian, which performs the finalize actions for 'GuardedLocalCache'\n\t// even if a subclass does not call 'super.finalize' in its 'finalize' method\n\tprivate Object finalizerGuardian = new Object() {\n\t\tprotected void finalize() throws Throwable {\n\t\t\tfor (NativeResource r : localResources) {\n\t\t\t\tr.dispose();\n\t\t\t}\n\t\t};\n\t};\n}\n```\n\n## References\n* Java API Specification: [Object.finalize()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#finalize()).\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* Common Weakness Enumeration: [CWE-568](https://cwe.mitre.org/data/definitions/568.html).\n","markdown":"# Finalizer inconsistency\nA `finalize` method that overrides the finalizer of a superclass but does not call `super.finalize` may leave system resources undisposed of or cause other cleanup actions to be left undone.\n\n\n## Recommendation\nMake sure that all `finalize` methods call `super.finalize` to ensure that the finalizer of its superclass is executed. Finalizer chaining is not automatic in Java.\n\nIt is also possible to defend against subclasses that do not call `super.finalize` by putting the cleanup code into a *finalizer guardian* instead of the `finalize` method. A finalizer guardian is an anonymous object instance that contains the cleanup code for the enclosing object in its `finalize` method. The only reference to the finalizer guardian is stored in a private field of the enclosing instance, which means that both the guardian and the enclosing instance can be finalized at the same time. This way, a subclass cannot block the execution of the cleanup code by not calling `super.finalize`.\n\n\n## Example\nIn the following example, `WrongCache.finalize` does not call `super.finalize`, which means that native resources are not disposed of. However, `RightCache.finalize` *does* call `super.finalize`, which means that native resources *are* disposed of.\n\n\n```java\nclass LocalCache {\n    private Collection<NativeResource> localResources;\n\n    //...\n\n    protected void finalize() throws Throwable {\n        for (NativeResource r : localResources) {\n            r.dispose();\n        }\n    };\n}\n\nclass WrongCache extends LocalCache {\n    //...\n    @Override\n    protected void finalize() throws Throwable {\n        // BAD: Empty 'finalize', which does not call 'super.finalize'.\n        //        Native resources in LocalCache are not disposed of.\n    }\n}\n\nclass RightCache extends LocalCache {\n    //...\n    @Override\n    protected void finalize() throws Throwable {\n        // GOOD: 'finalize' calls 'super.finalize'.\n        //        Native resources in LocalCache are disposed of.\n        super.finalize();\n    }\n}\n\n```\nThe following example shows a finalizer guardian.\n\n\n```java\nclass GuardedLocalCache {\n\tprivate Collection<NativeResource> localResources;\n\t// A finalizer guardian, which performs the finalize actions for 'GuardedLocalCache'\n\t// even if a subclass does not call 'super.finalize' in its 'finalize' method\n\tprivate Object finalizerGuardian = new Object() {\n\t\tprotected void finalize() throws Throwable {\n\t\t\tfor (NativeResource r : localResources) {\n\t\t\t\tr.dispose();\n\t\t\t}\n\t\t};\n\t};\n}\n```\n\n## References\n* Java API Specification: [Object.finalize()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#finalize()).\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* Common Weakness Enumeration: [CWE-568](https://cwe.mitre.org/data/definitions/568.html).\n"},"properties":{"tags":["reliability","maintainability","external/cwe/cwe-568"],"description":"A 'finalize' method that does not call 'super.finalize' may leave\n              cleanup actions undone.","id":"java/missing-super-finalize","kind":"problem","name":"Finalizer inconsistency","precision":"medium","problem.severity":"error"}},{"id":"java/wrong-equals-signature","name":"java/wrong-equals-signature","shortDescription":{"text":"Overloaded equals"},"fullDescription":{"text":"Defining 'Object.equals', where the parameter of 'equals' is not of the appropriate type, overloads 'equals' instead of overriding it."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Overloaded equals\nClasses that define an `equals` method whose parameter type is not `Object` *overload* the `Object.equals` method instead of *overriding* it. This may not be intended.\n\n\n## Recommendation\nTo *override* the `Object.equals` method, the parameter of the `equals` method must have type `Object`.\n\n\n## Example\nIn the following example, the definition of class `BadPoint` does not override the `Object.equals` method. This means that `p.equals(q)` resolves to the default definition of `Object.equals` and returns `false`. Class `GoodPoint` correctly overrides `Object.equals`, so that `r.equals(s)` returns `true`.\n\n\n```java\nclass BadPoint {\n    int x;\n    int y;\n\n    BadPoint(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    // overloaded equals method -- should be avoided\n    public boolean equals(BadPoint q) {\n        return x == q.x && y == q.y;\n    }\n}\n\nBadPoint p = new BadPoint(1, 2);\nObject q = new BadPoint(1, 2);\nboolean badEquals = p.equals(q); // evaluates to false\n\nclass GoodPoint {\n    int x;\n    int y;\n\n    GoodPoint(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    // correctly overrides Object.equals(Object)\n    public boolean equals(Object obj) {\n        if (obj != null && getClass() == obj.getClass()) {\n            GoodPoint q = (GoodPoint)obj;\n            return x == q.x && y == q.y;\n        }\n        return false;\n    }\n}\n\nGoodPoint r = new GoodPoint(1, 2);\nObject s = new GoodPoint(1, 2);\nboolean goodEquals = r.equals(s); // evaluates to true\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 8. Addison-Wesley, 2008.\n* Java Language Specification: [Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1), [Overloading](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.9).\n* The Java Tutorials: [Overriding and Hiding Methods](https://docs.oracle.com/javase/tutorial/java/IandI/override.html).\n","markdown":"# Overloaded equals\nClasses that define an `equals` method whose parameter type is not `Object` *overload* the `Object.equals` method instead of *overriding* it. This may not be intended.\n\n\n## Recommendation\nTo *override* the `Object.equals` method, the parameter of the `equals` method must have type `Object`.\n\n\n## Example\nIn the following example, the definition of class `BadPoint` does not override the `Object.equals` method. This means that `p.equals(q)` resolves to the default definition of `Object.equals` and returns `false`. Class `GoodPoint` correctly overrides `Object.equals`, so that `r.equals(s)` returns `true`.\n\n\n```java\nclass BadPoint {\n    int x;\n    int y;\n\n    BadPoint(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    // overloaded equals method -- should be avoided\n    public boolean equals(BadPoint q) {\n        return x == q.x && y == q.y;\n    }\n}\n\nBadPoint p = new BadPoint(1, 2);\nObject q = new BadPoint(1, 2);\nboolean badEquals = p.equals(q); // evaluates to false\n\nclass GoodPoint {\n    int x;\n    int y;\n\n    GoodPoint(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    // correctly overrides Object.equals(Object)\n    public boolean equals(Object obj) {\n        if (obj != null && getClass() == obj.getClass()) {\n            GoodPoint q = (GoodPoint)obj;\n            return x == q.x && y == q.y;\n        }\n        return false;\n    }\n}\n\nGoodPoint r = new GoodPoint(1, 2);\nObject s = new GoodPoint(1, 2);\nboolean goodEquals = r.equals(s); // evaluates to true\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 8. Addison-Wesley, 2008.\n* Java Language Specification: [Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1), [Overloading](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.9).\n* The Java Tutorials: [Overriding and Hiding Methods](https://docs.oracle.com/javase/tutorial/java/IandI/override.html).\n"},"properties":{"tags":["reliability","correctness"],"description":"Defining 'Object.equals', where the parameter of 'equals' is not of the\n              appropriate type, overloads 'equals' instead of overriding it.","id":"java/wrong-equals-signature","kind":"problem","name":"Overloaded equals","precision":"medium","problem.severity":"error"}},{"id":"java/reference-equality-on-strings","name":"java/reference-equality-on-strings","shortDescription":{"text":"Reference equality test on strings"},"fullDescription":{"text":"Comparing two strings using the == or != operator compares object identity, which may not be intended."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Reference equality test on strings\nComparing two `String` objects using `==` or `!=` compares object identity, which may not be intended. The same sequence of characters can be represented by two distinct `String` objects.\n\n\n## Recommendation\nTo see if two `String` objects represent the same sequence of characters, you should usually compare the objects by using their `equals` methods.\n\n\n## Example\nWith the following definition, `headerStyle` is compared to the empty string using `==`. This comparison can yield `false` even if `headerStyle` is the empty string, because it compares the identity of the two string objects rather than their contents. For example, if `headerStyle` was initialized by an XML parser or a JSON parser, then it might have been created with code like `String.valueOf(buf,start,len)`. Such code will produce a new string object every time it is called.\n\n\n```java\nvoid printHeader(String headerStyle) {\n\tif (headerStyle == null || headerStyle == \"\") {\n\t\t// No header\n\t\treturn;\n\t}\n\t// ... print the header\n}\n\n```\nWith the following definition, `headerStyle` is tested using the `equals` method. This version will reliably detect whenever `headerStyle` is the empty string.\n\n\n```java\nvoid printHeader(String headerStyle) {\n\tif (headerStyle == null || headerStyle.equals(\"\")) {\n\t\t// No header\n\t\treturn;\n\t}\n\t// ... print the header\n}\n\n```\n\n## References\n* Java API Specification: [String.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#equals(java.lang.Object)), [String.intern()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#intern()).\n* Java Language Specification: [15.21.3 Reference Equality Operators == and !=](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.3), [3.10.5 String Literals ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.5), [15.28 Constant Expressions](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.28).\n* Common Weakness Enumeration: [CWE-597](https://cwe.mitre.org/data/definitions/597.html).\n","markdown":"# Reference equality test on strings\nComparing two `String` objects using `==` or `!=` compares object identity, which may not be intended. The same sequence of characters can be represented by two distinct `String` objects.\n\n\n## Recommendation\nTo see if two `String` objects represent the same sequence of characters, you should usually compare the objects by using their `equals` methods.\n\n\n## Example\nWith the following definition, `headerStyle` is compared to the empty string using `==`. This comparison can yield `false` even if `headerStyle` is the empty string, because it compares the identity of the two string objects rather than their contents. For example, if `headerStyle` was initialized by an XML parser or a JSON parser, then it might have been created with code like `String.valueOf(buf,start,len)`. Such code will produce a new string object every time it is called.\n\n\n```java\nvoid printHeader(String headerStyle) {\n\tif (headerStyle == null || headerStyle == \"\") {\n\t\t// No header\n\t\treturn;\n\t}\n\t// ... print the header\n}\n\n```\nWith the following definition, `headerStyle` is tested using the `equals` method. This version will reliably detect whenever `headerStyle` is the empty string.\n\n\n```java\nvoid printHeader(String headerStyle) {\n\tif (headerStyle == null || headerStyle.equals(\"\")) {\n\t\t// No header\n\t\treturn;\n\t}\n\t// ... print the header\n}\n\n```\n\n## References\n* Java API Specification: [String.equals()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#equals(java.lang.Object)), [String.intern()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#intern()).\n* Java Language Specification: [15.21.3 Reference Equality Operators == and !=](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.21.3), [3.10.5 String Literals ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.5), [15.28 Constant Expressions](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.28).\n* Common Weakness Enumeration: [CWE-597](https://cwe.mitre.org/data/definitions/597.html).\n"},"properties":{"tags":["reliability","external/cwe/cwe-597"],"description":"Comparing two strings using the == or != operator\n              compares object identity, which may not be intended.","id":"java/reference-equality-on-strings","kind":"problem","name":"Reference equality test on strings","precision":"medium","problem.severity":"warning"}},{"id":"java/wrong-compareto-signature","name":"java/wrong-compareto-signature","shortDescription":{"text":"Overloaded compareTo"},"fullDescription":{"text":"Defining 'Comparable.compareTo', where the parameter of 'compareTo' is not of the appropriate type, overloads 'compareTo' instead of overriding it."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Overloaded compareTo\nClasses that implement `Comparable<T>` and define a `compareTo` method whose parameter type is not `T` *overload* the `compareTo` method instead of *overriding* it. This may not be intended.\n\n\n## Example\nIn the following example, the call to `compareTo` on line 17 calls the method defined in class `Super`, instead of the method defined in class `Sub`, because the type of `a` and `b` is `Super`. This may not be the method that the programmer intended.\n\n\n```java\npublic class CovariantCompareTo {\n\tstatic class Super implements Comparable<Super> {\n\t\tpublic int compareTo(Super rhs) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tstatic class Sub extends Super {\n\t\tpublic int compareTo(Sub rhs) {  // Definition of compareTo uses a different parameter type\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSuper a = new Sub();\n\t\tSuper b = new Sub();\n\t\tSystem.out.println(a.compareTo(b));\n\t}\n}\n```\n\n## Recommendation\nTo *override* the `Comparable<T>.compareTo` method, the parameter of `compareTo` must have type `T`.\n\nIn the example above, this means that the type of the parameter of `Sub.compareTo` should be changed to `Super`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 12. Addison-Wesley, 2008.\n* Java Language Specification: [Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1), [Overloading](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.9).\n* The Java Tutorials: [Overriding and Hiding Methods](https://docs.oracle.com/javase/tutorial/java/IandI/override.html).\n","markdown":"# Overloaded compareTo\nClasses that implement `Comparable<T>` and define a `compareTo` method whose parameter type is not `T` *overload* the `compareTo` method instead of *overriding* it. This may not be intended.\n\n\n## Example\nIn the following example, the call to `compareTo` on line 17 calls the method defined in class `Super`, instead of the method defined in class `Sub`, because the type of `a` and `b` is `Super`. This may not be the method that the programmer intended.\n\n\n```java\npublic class CovariantCompareTo {\n\tstatic class Super implements Comparable<Super> {\n\t\tpublic int compareTo(Super rhs) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tstatic class Sub extends Super {\n\t\tpublic int compareTo(Sub rhs) {  // Definition of compareTo uses a different parameter type\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSuper a = new Sub();\n\t\tSuper b = new Sub();\n\t\tSystem.out.println(a.compareTo(b));\n\t}\n}\n```\n\n## Recommendation\nTo *override* the `Comparable<T>.compareTo` method, the parameter of `compareTo` must have type `T`.\n\nIn the example above, this means that the type of the parameter of `Sub.compareTo` should be changed to `Super`.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 12. Addison-Wesley, 2008.\n* Java Language Specification: [Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1), [Overloading](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.9).\n* The Java Tutorials: [Overriding and Hiding Methods](https://docs.oracle.com/javase/tutorial/java/IandI/override.html).\n"},"properties":{"tags":["reliability","correctness"],"description":"Defining 'Comparable.compareTo', where the parameter of 'compareTo' is not of the\n              appropriate type, overloads 'compareTo' instead of overriding it.","id":"java/wrong-compareto-signature","kind":"problem","name":"Overloaded compareTo","precision":"medium","problem.severity":"error"}},{"id":"java/inconsistent-compareto-and-equals","name":"java/inconsistent-compareto-and-equals","shortDescription":{"text":"Inconsistent compareTo"},"fullDescription":{"text":"If a class overrides 'compareTo' but not 'equals', it may mean that 'compareTo' and 'equals' are inconsistent."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Inconsistent compareTo\nA class that overrides `compareTo` but not `equals` may not implement a natural ordering that is consistent with `equals`.\n\n\n## Recommendation\nAlthough this consistency is not strictly required by the `compareTo` contract, usually both methods should be overridden to ensure that they are consistent, that is, that `x.compareTo(y)==0` is `true` if and only if `x.equals(y)` is `true`, for any non-null `x` and `y`.\n\n\n## Example\nIn the following example, the class `InconsistentCompareTo` overrides `compareTo` but not `equals`.\n\n\n```java\npublic class InconsistentCompareTo implements Comparable<InconsistentCompareTo> {\n\tprivate int i = 0;\n\tpublic InconsistentCompareTo(int i) {\n\t\tthis.i = i;\n\t}\n\t\n\tpublic int compareTo(InconsistentCompareTo rhs) {\n\t\treturn i - rhs.i;\n\t}\n}\n```\nIn the following example, the class `InconsistentCompareToFix` overrides both `compareTo` and `equals`.\n\n\n```java\npublic class InconsistentCompareToFix implements Comparable<InconsistentCompareToFix> {\n\tprivate int i = 0;\n\tpublic InconsistentCompareToFix(int i) {\n\t\tthis.i = i;\n\t}\n\t\n\tpublic int compareTo(InconsistentCompareToFix rhs) {\n\t\treturn i - rhs.i;\n\t}\n\n\tpublic boolean equals(InconsistentCompareToFix rhs) {\n\t\treturn i == rhs.i;\n\t}\n}\n```\nIf you require a natural ordering that is inconsistent with `equals`, you should document it clearly.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 12. Addison-Wesley, 2008.\n* Java API Specification: [Comparable.compareTo](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html#compareTo(T)), [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n","markdown":"# Inconsistent compareTo\nA class that overrides `compareTo` but not `equals` may not implement a natural ordering that is consistent with `equals`.\n\n\n## Recommendation\nAlthough this consistency is not strictly required by the `compareTo` contract, usually both methods should be overridden to ensure that they are consistent, that is, that `x.compareTo(y)==0` is `true` if and only if `x.equals(y)` is `true`, for any non-null `x` and `y`.\n\n\n## Example\nIn the following example, the class `InconsistentCompareTo` overrides `compareTo` but not `equals`.\n\n\n```java\npublic class InconsistentCompareTo implements Comparable<InconsistentCompareTo> {\n\tprivate int i = 0;\n\tpublic InconsistentCompareTo(int i) {\n\t\tthis.i = i;\n\t}\n\t\n\tpublic int compareTo(InconsistentCompareTo rhs) {\n\t\treturn i - rhs.i;\n\t}\n}\n```\nIn the following example, the class `InconsistentCompareToFix` overrides both `compareTo` and `equals`.\n\n\n```java\npublic class InconsistentCompareToFix implements Comparable<InconsistentCompareToFix> {\n\tprivate int i = 0;\n\tpublic InconsistentCompareToFix(int i) {\n\t\tthis.i = i;\n\t}\n\t\n\tpublic int compareTo(InconsistentCompareToFix rhs) {\n\t\treturn i - rhs.i;\n\t}\n\n\tpublic boolean equals(InconsistentCompareToFix rhs) {\n\t\treturn i == rhs.i;\n\t}\n}\n```\nIf you require a natural ordering that is inconsistent with `equals`, you should document it clearly.\n\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 12. Addison-Wesley, 2008.\n* Java API Specification: [Comparable.compareTo](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html#compareTo(T)), [Object.equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n"},"properties":{"tags":["reliability","correctness"],"description":"If a class overrides 'compareTo' but not 'equals', it may mean that 'compareTo'\n              and 'equals' are inconsistent.","id":"java/inconsistent-compareto-and-equals","kind":"problem","name":"Inconsistent compareTo","precision":"medium","problem.severity":"warning"}},{"id":"java/ineffective-annotation-present-check","name":"java/ineffective-annotation-present-check","shortDescription":{"text":"AnnotationPresent check"},"fullDescription":{"text":"If an annotation has not been annotated with a 'RUNTIME' retention policy, checking for its presence at runtime is not possible."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# AnnotationPresent check\nTo be able to use the `isAnnotationPresent` method on an `AnnotatedElement` at runtime, an annotation must be explicitly annotated with a `RUNTIME` retention policy. Otherwise, the annotation is not retained at runtime and cannot be observed using reflection.\n\n\n## Recommendation\nExplicitly annotate annotations with a `RUNTIME` retention policy if you want to observe their presence using `AnnotatedElement.isAnnotationPresent` at runtime.\n\n\n## Example\nIn the following example, the call to `isAnnotationPresent` returns `false` because the annotation cannot be observed using reflection.\n\n\n```java\npublic class AnnotationPresentCheck {\n\tpublic static @interface UntrustedData { }\n\n\t@UntrustedData\n\tpublic static String getUserData() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\treturn scanner.nextLine();\n\t}\n\n\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException {\n\t\tString data = getUserData();\n\t\tMethod m = AnnotationPresentCheck.class.getMethod(\"getUserData\");\n\t\tif(m.isAnnotationPresent(UntrustedData.class)) {  // Returns 'false'\n\t\t\tSystem.out.println(\"Not trusting data from user.\");\n\t\t}\n\t}\n}\n```\nTo correct this, the annotation is annotated with a `RUNTIME` retention policy.\n\n\n```java\npublic class AnnotationPresentCheckFix {\n\t@Retention(RetentionPolicy.RUNTIME)  // Annotate the annotation\n\tpublic static @interface UntrustedData { }\n\n\t@UntrustedData\n\tpublic static String getUserData() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\treturn scanner.nextLine();\n\t}\n\n\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException {\n\t\tString data = getUserData();\n\t\tMethod m = AnnotationPresentCheckFix.class.getMethod(\"getUserData\");\n\t\tif(m.isAnnotationPresent(UntrustedData.class)) {  // Returns 'true'\n\t\t\tSystem.out.println(\"Not trusting data from user.\");\n\t\t}\n\t}\n}\n```\n\n## References\n* Java API Specification: [Annotation Type Retention](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/Retention.html), [RetentionPolicy.RUNTIME](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/RetentionPolicy.html#RUNTIME), [AnnotatedElement.isAnnotationPresent()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/reflect/AnnotatedElement.html#isAnnotationPresent(java.lang.Class)).\n","markdown":"# AnnotationPresent check\nTo be able to use the `isAnnotationPresent` method on an `AnnotatedElement` at runtime, an annotation must be explicitly annotated with a `RUNTIME` retention policy. Otherwise, the annotation is not retained at runtime and cannot be observed using reflection.\n\n\n## Recommendation\nExplicitly annotate annotations with a `RUNTIME` retention policy if you want to observe their presence using `AnnotatedElement.isAnnotationPresent` at runtime.\n\n\n## Example\nIn the following example, the call to `isAnnotationPresent` returns `false` because the annotation cannot be observed using reflection.\n\n\n```java\npublic class AnnotationPresentCheck {\n\tpublic static @interface UntrustedData { }\n\n\t@UntrustedData\n\tpublic static String getUserData() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\treturn scanner.nextLine();\n\t}\n\n\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException {\n\t\tString data = getUserData();\n\t\tMethod m = AnnotationPresentCheck.class.getMethod(\"getUserData\");\n\t\tif(m.isAnnotationPresent(UntrustedData.class)) {  // Returns 'false'\n\t\t\tSystem.out.println(\"Not trusting data from user.\");\n\t\t}\n\t}\n}\n```\nTo correct this, the annotation is annotated with a `RUNTIME` retention policy.\n\n\n```java\npublic class AnnotationPresentCheckFix {\n\t@Retention(RetentionPolicy.RUNTIME)  // Annotate the annotation\n\tpublic static @interface UntrustedData { }\n\n\t@UntrustedData\n\tpublic static String getUserData() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\treturn scanner.nextLine();\n\t}\n\n\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException {\n\t\tString data = getUserData();\n\t\tMethod m = AnnotationPresentCheckFix.class.getMethod(\"getUserData\");\n\t\tif(m.isAnnotationPresent(UntrustedData.class)) {  // Returns 'true'\n\t\t\tSystem.out.println(\"Not trusting data from user.\");\n\t\t}\n\t}\n}\n```\n\n## References\n* Java API Specification: [Annotation Type Retention](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/Retention.html), [RetentionPolicy.RUNTIME](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/RetentionPolicy.html#RUNTIME), [AnnotatedElement.isAnnotationPresent()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/reflect/AnnotatedElement.html#isAnnotationPresent(java.lang.Class)).\n"},"properties":{"tags":["correctness","logic"],"description":"If an annotation has not been annotated with a 'RUNTIME' retention policy, checking\n              for its presence at runtime is not possible.","id":"java/ineffective-annotation-present-check","kind":"problem","name":"AnnotationPresent check","precision":"medium","problem.severity":"error"}},{"id":"java/missing-case-in-switch","name":"java/missing-case-in-switch","shortDescription":{"text":"Missing enum case in switch"},"fullDescription":{"text":"A 'switch' statement that is based on an 'enum' type and does not have cases for all the 'enum' constants is usually a coding mistake."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Missing enum case in switch\nA `switch` statement that is based on a variable with an `enum` type should either have a default case or handle all possible constants of that `enum` type. Handling all but one or two `enum` constants is usually a coding mistake.\n\n\n## Recommendation\nIf there are only a handful of missing cases, add them to the end of the `switch` statement. If there are many cases that do not need to be handled individually, add a default case to handle them.\n\nIf there are some `enum` constants that should never occur in this particular part of the code, then program defensively by adding cases for those constants and explicitly throwing an exception (rather than just having no cases for those constants).\n\n\n## Example\nIn the following example, the case for 'YES' is missing. Therefore, if `answer` is 'YES', an exception is thrown at run time. To fix this, a case for 'YES' should be added.\n\n\n```java\nenum Answer { YES, NO, MAYBE }\n\nclass Optimist\n{\n\tAnswer interpret(Answer answer) {\n\t\tswitch (answer) {\n\t\t\tcase MAYBE:\n\t\t\t\treturn Answer.YES;\n\t\t\tcase NO:\n\t\t\t\treturn Answer.MAYBE;\n\t\t\t// Missing case for 'YES'\n\t\t}\n\t\tthrow new RuntimeException(\"uncaught case: \" + answer);\n\t}\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [8.9 Enum Types](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.9), [14.11 The switch Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.11).\n* Common Weakness Enumeration: [CWE-478](https://cwe.mitre.org/data/definitions/478.html).\n","markdown":"# Missing enum case in switch\nA `switch` statement that is based on a variable with an `enum` type should either have a default case or handle all possible constants of that `enum` type. Handling all but one or two `enum` constants is usually a coding mistake.\n\n\n## Recommendation\nIf there are only a handful of missing cases, add them to the end of the `switch` statement. If there are many cases that do not need to be handled individually, add a default case to handle them.\n\nIf there are some `enum` constants that should never occur in this particular part of the code, then program defensively by adding cases for those constants and explicitly throwing an exception (rather than just having no cases for those constants).\n\n\n## Example\nIn the following example, the case for 'YES' is missing. Therefore, if `answer` is 'YES', an exception is thrown at run time. To fix this, a case for 'YES' should be added.\n\n\n```java\nenum Answer { YES, NO, MAYBE }\n\nclass Optimist\n{\n\tAnswer interpret(Answer answer) {\n\t\tswitch (answer) {\n\t\t\tcase MAYBE:\n\t\t\t\treturn Answer.YES;\n\t\t\tcase NO:\n\t\t\t\treturn Answer.MAYBE;\n\t\t\t// Missing case for 'YES'\n\t\t}\n\t\tthrow new RuntimeException(\"uncaught case: \" + answer);\n\t}\n}\n\n```\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [8.9 Enum Types](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.9), [14.11 The switch Statement](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.11).\n* Common Weakness Enumeration: [CWE-478](https://cwe.mitre.org/data/definitions/478.html).\n"},"properties":{"tags":["reliability","readability","external/cwe/cwe-478"],"description":"A 'switch' statement that is based on an 'enum' type and does not have cases for all\n              the 'enum' constants is usually a coding mistake.","id":"java/missing-case-in-switch","kind":"problem","name":"Missing enum case in switch","precision":"medium","problem.severity":"warning"}},{"id":"java/spin-on-field","name":"java/spin-on-field","shortDescription":{"text":"Spin on field"},"fullDescription":{"text":"Repeatedly reading a non-volatile field within the condition of an empty loop may result in an infinite loop."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Spin on field\nRepeatedly reading a non-volatile field within the condition of an empty loop statement may result in an infinite loop, since a compiler optimization may move this field access out of the loop.\n\n\n## Example\nIn the following example, the method `spin` repeatedly tests the field `done` in a loop. The method repeats the while-loop until the value of the field `done` is set by another thread. However, the compiler could optimize the code as shown in the second code snippet, because the field `done` is not marked as `volatile` and there are no statements in the body of the loop that could change the value of `done`. The optimized version of `spin` loops forever, even when another thread would set `done` to `true`.\n\n\n```java\nclass Spin {\n    public boolean done = false;\n\n    public void spin() {\n        while(!done){\n        }\n    }\n}\n\nclass Spin { // optimized\n    public boolean done = false;\n\n    public void spin() {\n        boolean cond = done;\n        while(!cond){\n        }\n    }\n}\n\n```\n\n## Recommendation\nEnsure that access to this field is properly synchronized. Alternatively, avoid spinning on the field and instead use the `wait` and `notifyAll` methods or the `java.util.concurrent` library to communicate between threads.\n\n\n## References\n* Java Language Specification: [Threads and Locks](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html).\n","markdown":"# Spin on field\nRepeatedly reading a non-volatile field within the condition of an empty loop statement may result in an infinite loop, since a compiler optimization may move this field access out of the loop.\n\n\n## Example\nIn the following example, the method `spin` repeatedly tests the field `done` in a loop. The method repeats the while-loop until the value of the field `done` is set by another thread. However, the compiler could optimize the code as shown in the second code snippet, because the field `done` is not marked as `volatile` and there are no statements in the body of the loop that could change the value of `done`. The optimized version of `spin` loops forever, even when another thread would set `done` to `true`.\n\n\n```java\nclass Spin {\n    public boolean done = false;\n\n    public void spin() {\n        while(!done){\n        }\n    }\n}\n\nclass Spin { // optimized\n    public boolean done = false;\n\n    public void spin() {\n        boolean cond = done;\n        while(!cond){\n        }\n    }\n}\n\n```\n\n## Recommendation\nEnsure that access to this field is properly synchronized. Alternatively, avoid spinning on the field and instead use the `wait` and `notifyAll` methods or the `java.util.concurrent` library to communicate between threads.\n\n\n## References\n* Java Language Specification: [Threads and Locks](https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html).\n"},"properties":{"tags":["efficiency","correctness","concurrency"],"description":"Repeatedly reading a non-volatile field within the condition of an empty loop may\n              result in an infinite loop.","id":"java/spin-on-field","kind":"problem","name":"Spin on field","precision":"medium","problem.severity":"warning"}},{"id":"java/abs-of-random","name":"java/abs-of-random","shortDescription":{"text":"Incorrect absolute value of random number"},"fullDescription":{"text":"Calling 'Math.abs' to find the absolute value of a randomly generated integer is not guaranteed to return a non-negative integer."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Incorrect absolute value of random number\nUsing `Math.abs` on the result of a call to `Random.nextInt()` (or `Random.nextLong()`) is not guaranteed to return a non-negative number. `Random.nextInt()` can return `Integer.MIN_VALUE`, which when passed to `Math.abs` results in the same value, `Integer.MIN_VALUE`. (Because of the two's-complement representation of integers in Java, the positive equivalent of `Integer.MIN_VALUE` cannot be represented in the same number of bits.) The case for `Random.nextLong()` is similar.\n\n\n## Recommendation\nIf a non-negative random integer is required, use `Random.nextInt(int)` instead, and use `Integer.MAX_VALUE` as its parameter. The values that might be returned do not include `Integer.MAX_VALUE` itself, but this solution is likely to be sufficient for most purposes.\n\nAnother solution is to increment the value of `Random.nextInt()` by one, if it is negative, before passing the result to `Math.abs`. This solution has the advantage that `0` has the same probability as other numbers.\n\n\n## Example\nIn the following example, `mayBeNegativeInt` is negative if `nextInt` returns `Integer.MIN_VALUE`. The example shows how using the two solutions described above means that `positiveInt` is always assigned a positive number.\n\n\n```java\npublic static void main(String args[]) {\n    Random r = new Random();\n\n    // BAD: 'mayBeNegativeInt' is negative if\n    // 'nextInt()' returns 'Integer.MIN_VALUE'.\n    int mayBeNegativeInt = Math.abs(r.nextInt());\n\n    // GOOD: 'nonNegativeInt' is always a value between 0 (inclusive)\n    // and Integer.MAX_VALUE (exclusive).\n    int nonNegativeInt = r.nextInt(Integer.MAX_VALUE);\n\n    // GOOD: When 'nextInt' returns a negative number increment the returned value.\n    int nextInt = r.nextInt();\n    if(nextInt < 0)\n        nextInt++;\n    int nonNegativeInt = Math.abs(nextInt);\n}\n\n```\n\n## References\n* Java API Specification: [Math.abs(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(int)), [Math.abs(long)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(long)), [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n* Java Language Specification: [4.2.1 Integral Types and Values](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.2.1).\n","markdown":"# Incorrect absolute value of random number\nUsing `Math.abs` on the result of a call to `Random.nextInt()` (or `Random.nextLong()`) is not guaranteed to return a non-negative number. `Random.nextInt()` can return `Integer.MIN_VALUE`, which when passed to `Math.abs` results in the same value, `Integer.MIN_VALUE`. (Because of the two's-complement representation of integers in Java, the positive equivalent of `Integer.MIN_VALUE` cannot be represented in the same number of bits.) The case for `Random.nextLong()` is similar.\n\n\n## Recommendation\nIf a non-negative random integer is required, use `Random.nextInt(int)` instead, and use `Integer.MAX_VALUE` as its parameter. The values that might be returned do not include `Integer.MAX_VALUE` itself, but this solution is likely to be sufficient for most purposes.\n\nAnother solution is to increment the value of `Random.nextInt()` by one, if it is negative, before passing the result to `Math.abs`. This solution has the advantage that `0` has the same probability as other numbers.\n\n\n## Example\nIn the following example, `mayBeNegativeInt` is negative if `nextInt` returns `Integer.MIN_VALUE`. The example shows how using the two solutions described above means that `positiveInt` is always assigned a positive number.\n\n\n```java\npublic static void main(String args[]) {\n    Random r = new Random();\n\n    // BAD: 'mayBeNegativeInt' is negative if\n    // 'nextInt()' returns 'Integer.MIN_VALUE'.\n    int mayBeNegativeInt = Math.abs(r.nextInt());\n\n    // GOOD: 'nonNegativeInt' is always a value between 0 (inclusive)\n    // and Integer.MAX_VALUE (exclusive).\n    int nonNegativeInt = r.nextInt(Integer.MAX_VALUE);\n\n    // GOOD: When 'nextInt' returns a negative number increment the returned value.\n    int nextInt = r.nextInt();\n    if(nextInt < 0)\n        nextInt++;\n    int nonNegativeInt = Math.abs(nextInt);\n}\n\n```\n\n## References\n* Java API Specification: [Math.abs(int)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(int)), [Math.abs(long)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#abs(long)), [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n* Java Language Specification: [4.2.1 Integral Types and Values](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.2.1).\n"},"properties":{"tags":["reliability","maintainability"],"description":"Calling 'Math.abs' to find the absolute value of a randomly generated integer is not\n              guaranteed to return a non-negative integer.","id":"java/abs-of-random","kind":"problem","name":"Incorrect absolute value of random number","precision":"medium","problem.severity":"warning"}},{"id":"java/random-used-once","name":"java/random-used-once","shortDescription":{"text":"Random used only once"},"fullDescription":{"text":"Creating an instance of 'Random' for each pseudo-random number required does not guarantee an evenly distributed sequence of random numbers."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Random used only once\nA program that uses `java.util.Random` to generate a sequence of pseudo-random numbers *should not* create a new instance of `Random` every time a new pseudo-random number is required (for example, `new Random().nextInt()`).\n\nAccording to the Java API Specification:\n\n> If two instances of `Random` are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers.\n\nThe sequence of pseudo-random numbers returned by these calls depends only on the value of the seed. If you construct a new `Random` object each time a pseudo-random number is needed, this does not generate a good distribution of pseudo-random numbers, even though the parameterless `Random()` constructor tries to initialize itself with a unique seed.\n\n\n## Recommendation\nCreate a `Random` object once and use the same instance when generating sequences of pseudo-random numbers (by calling `nextInt`, `nextLong`, and so on).\n\n\n## Example\nIn the following example, generating a series of pseudo-random numbers, such as `notReallyRandom` and `notReallyRandom2`, by creating a new instance of `Random` each time is unlikely to result in a good distribution of pseudo-random numbers. In contrast, generating a series of pseudo-random numbers, such as `random1` and `random2`, by calling `nextInt` each time *is* likely to result in a good distribution. This is because the numbers are based on only one `Random` object.\n\n\n```java\npublic static void main(String args[]) {\n\t// BAD: A new 'Random' object is created every time\n\t// a pseudo-random integer is required.\n\tint notReallyRandom = new Random().nextInt();\n\tint notReallyRandom2 = new Random().nextInt();\n\t\n\t// GOOD: The same 'Random' object is used to generate \n\t// two pseudo-random integers.\n\tRandom r = new Random();\n\tint random1 = r.nextInt();\n\tint random2 = r.nextInt();\n}\n```\n\n## References\n* Java API Specification: [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n* Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).\n","markdown":"# Random used only once\nA program that uses `java.util.Random` to generate a sequence of pseudo-random numbers *should not* create a new instance of `Random` every time a new pseudo-random number is required (for example, `new Random().nextInt()`).\n\nAccording to the Java API Specification:\n\n> If two instances of `Random` are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers.\n\nThe sequence of pseudo-random numbers returned by these calls depends only on the value of the seed. If you construct a new `Random` object each time a pseudo-random number is needed, this does not generate a good distribution of pseudo-random numbers, even though the parameterless `Random()` constructor tries to initialize itself with a unique seed.\n\n\n## Recommendation\nCreate a `Random` object once and use the same instance when generating sequences of pseudo-random numbers (by calling `nextInt`, `nextLong`, and so on).\n\n\n## Example\nIn the following example, generating a series of pseudo-random numbers, such as `notReallyRandom` and `notReallyRandom2`, by creating a new instance of `Random` each time is unlikely to result in a good distribution of pseudo-random numbers. In contrast, generating a series of pseudo-random numbers, such as `random1` and `random2`, by calling `nextInt` each time *is* likely to result in a good distribution. This is because the numbers are based on only one `Random` object.\n\n\n```java\npublic static void main(String args[]) {\n\t// BAD: A new 'Random' object is created every time\n\t// a pseudo-random integer is required.\n\tint notReallyRandom = new Random().nextInt();\n\tint notReallyRandom2 = new Random().nextInt();\n\t\n\t// GOOD: The same 'Random' object is used to generate \n\t// two pseudo-random integers.\n\tRandom r = new Random();\n\tint random1 = r.nextInt();\n\tint random2 = r.nextInt();\n}\n```\n\n## References\n* Java API Specification: [Random](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html).\n* Common Weakness Enumeration: [CWE-335](https://cwe.mitre.org/data/definitions/335.html).\n"},"properties":{"tags":["reliability","maintainability","external/cwe/cwe-335"],"description":"Creating an instance of 'Random' for each pseudo-random number required does not\n              guarantee an evenly distributed sequence of random numbers.","id":"java/random-used-once","kind":"problem","name":"Random used only once","precision":"medium","problem.severity":"warning"}},{"id":"java/multiplication-of-remainder","name":"java/multiplication-of-remainder","shortDescription":{"text":"Multiplication of remainder"},"fullDescription":{"text":"Using the remainder operator with the multiplication operator without adding parentheses to clarify precedence may cause confusion."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Multiplication of remainder\nUsing the remainder operator `%` with the multiplication operator may not give you the result that you expect unless you use parentheses. This is because the remainder operator has the same precedence as the multiplication operator, and the operators are left-associative.\n\n\n## Recommendation\nWhen you use the remainder operator with the multiplication operator, ensure that the expression is evaluated as you expect. If necessary, add parentheses.\n\n\n## Example\nConsider a time in milliseconds, represented by `t`. To calculate the number of milliseconds remaining after the time has been converted to whole minutes, you might write `t % 60 * 1000`. However, this is equal to `(t % 60) * 1000`, which gives the wrong result. Instead, the expression should be `t % (60 * 1000)`.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.\n* The Java Tutorials: [Operators](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).\n","markdown":"# Multiplication of remainder\nUsing the remainder operator `%` with the multiplication operator may not give you the result that you expect unless you use parentheses. This is because the remainder operator has the same precedence as the multiplication operator, and the operators are left-associative.\n\n\n## Recommendation\nWhen you use the remainder operator with the multiplication operator, ensure that the expression is evaluated as you expect. If necessary, add parentheses.\n\n\n## Example\nConsider a time in milliseconds, represented by `t`. To calculate the number of milliseconds remaining after the time has been converted to whole minutes, you might write `t % 60 * 1000`. However, this is equal to `(t % 60) * 1000`, which gives the wrong result. Instead, the expression should be `t % (60 * 1000)`.\n\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.\n* The Java Tutorials: [Operators](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).\n"},"properties":{"tags":["maintainability","correctness"],"description":"Using the remainder operator with the multiplication operator without adding\n              parentheses to clarify precedence may cause confusion.","id":"java/multiplication-of-remainder","kind":"problem","name":"Multiplication of remainder","precision":"medium","problem.severity":"warning"}},{"id":"java/missing-call-to-super-clone","name":"java/missing-call-to-super-clone","shortDescription":{"text":"Missing super clone"},"fullDescription":{"text":"A 'clone' method that is overridden in a subclass, and that does not itself call 'super.clone', causes calls to the subclass's 'clone' method to return an object of the wrong type."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Missing super clone\nA `clone` method that is overridden in a subclass should call `super.clone`. Not doing so causes the subclass `clone` to return an object of the wrong type, which violates the contract for `Cloneable`.\n\nThe Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:\n\n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)\n* `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)\nFor the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.\n\nHowever, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a \"deep structure\" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.\n\nOne added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.\n\n\n## Recommendation\nEvery clone method should always use `super.clone` to construct the cloned object. This ensures that the cloned object is ultimately constructed by `Object.clone`, which uses reflection to ensure that an object of the correct runtime type is created.\n\n\n## Example\nIn the following example, the attempt to clone `WrongEmployee` fails because `super.clone` is implemented incorrectly in its superclass `WrongPerson`.\n\n\n```java\nclass WrongPerson implements Cloneable {\n    private String name;\n    public WrongPerson(String name) { this.name = name; }\n    // BAD: 'clone' does not call 'super.clone'.\n    public WrongPerson clone() {\n        return new WrongPerson(this.name);\n    }\n}\n\nclass WrongEmployee extends WrongPerson {\n    public WrongEmployee(String name) {\n        super(name);\n    }\n    // ALMOST RIGHT: 'clone' correctly calls 'super.clone',\n    // but 'super.clone' is implemented incorrectly.\n    public WrongEmployee clone() {\n    \treturn (WrongEmployee)super.clone();\n    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[] args) {\n        WrongEmployee e = new WrongEmployee(\"John Doe\");\n        WrongEmployee eclone = e.clone(); // Causes a ClassCastException\n    }\n}\n\n```\nHowever, in the following modified example, the attempt to clone `Employee` succeeds because `super.clone` is implemented correctly in its superclass `Person`.\n\n\n```java\nclass Person implements Cloneable {\n    private String name;\n    public Person(String name) { this.name = name; }\n    // GOOD: 'clone' correctly calls 'super.clone'\n    public Person clone() {\n        try {\n            return (Person)super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should never happen\");\n        }\n    }\n}\n\nclass Employee extends Person {\n    public Employee(String name) {\n        super(name);\n    }\n    // GOOD: 'clone' correctly calls 'super.clone'\n    public Employee clone() {\n    \treturn (Employee)super.clone();\n    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[] args) {\n        Employee e2 = new Employee(\"Jane Doe\");\n        Employee e2clone = e2.clone(); // 'clone' correctly returns an object of type 'Employee'\n    }\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n* Common Weakness Enumeration: [CWE-580](https://cwe.mitre.org/data/definitions/580.html).\n","markdown":"# Missing super clone\nA `clone` method that is overridden in a subclass should call `super.clone`. Not doing so causes the subclass `clone` to return an object of the wrong type, which violates the contract for `Cloneable`.\n\nThe Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:\n\n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)\n* `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)\nFor the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.\n\nHowever, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a \"deep structure\" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.\n\nOne added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.\n\n\n## Recommendation\nEvery clone method should always use `super.clone` to construct the cloned object. This ensures that the cloned object is ultimately constructed by `Object.clone`, which uses reflection to ensure that an object of the correct runtime type is created.\n\n\n## Example\nIn the following example, the attempt to clone `WrongEmployee` fails because `super.clone` is implemented incorrectly in its superclass `WrongPerson`.\n\n\n```java\nclass WrongPerson implements Cloneable {\n    private String name;\n    public WrongPerson(String name) { this.name = name; }\n    // BAD: 'clone' does not call 'super.clone'.\n    public WrongPerson clone() {\n        return new WrongPerson(this.name);\n    }\n}\n\nclass WrongEmployee extends WrongPerson {\n    public WrongEmployee(String name) {\n        super(name);\n    }\n    // ALMOST RIGHT: 'clone' correctly calls 'super.clone',\n    // but 'super.clone' is implemented incorrectly.\n    public WrongEmployee clone() {\n    \treturn (WrongEmployee)super.clone();\n    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[] args) {\n        WrongEmployee e = new WrongEmployee(\"John Doe\");\n        WrongEmployee eclone = e.clone(); // Causes a ClassCastException\n    }\n}\n\n```\nHowever, in the following modified example, the attempt to clone `Employee` succeeds because `super.clone` is implemented correctly in its superclass `Person`.\n\n\n```java\nclass Person implements Cloneable {\n    private String name;\n    public Person(String name) { this.name = name; }\n    // GOOD: 'clone' correctly calls 'super.clone'\n    public Person clone() {\n        try {\n            return (Person)super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should never happen\");\n        }\n    }\n}\n\nclass Employee extends Person {\n    public Employee(String name) {\n        super(name);\n    }\n    // GOOD: 'clone' correctly calls 'super.clone'\n    public Employee clone() {\n    \treturn (Employee)super.clone();\n    }\n}\n\npublic class MissingCallToSuperClone {\n    public static void main(String[] args) {\n        Employee e2 = new Employee(\"Jane Doe\");\n        Employee e2clone = e2.clone(); // 'clone' correctly returns an object of type 'Employee'\n    }\n}\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n* Common Weakness Enumeration: [CWE-580](https://cwe.mitre.org/data/definitions/580.html).\n"},"properties":{"tags":["reliability","maintainability","external/cwe/cwe-580"],"description":"A 'clone' method that is overridden in a subclass, and that does not itself call\n              'super.clone', causes calls to the subclass's 'clone' method to return an object of\n              the wrong type.","id":"java/missing-call-to-super-clone","kind":"problem","name":"Missing super clone","precision":"medium","problem.severity":"error"}},{"id":"java/missing-clone-method","name":"java/missing-clone-method","shortDescription":{"text":"No clone method"},"fullDescription":{"text":"A class that implements 'Cloneable' but does not override the 'clone' method will have undesired behavior."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# No clone method\nA class that implements `Cloneable` should override `Object.clone`. For non-trivial objects, the `Cloneable` contract requires a deep copy of the object's internal state. A class that does not have a `clone` method indicates that the class is breaking the contract and will have undesired behavior.\n\nThe Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:\n\n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)\n* `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)\nFor the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.\n\nHowever, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a \"deep structure\" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.\n\nOne added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.\n\n\n## Recommendation\nThe necessity of creating a deep copy of an object's internal state means that, for most objects, `clone` must be overridden to satisfy the `Cloneable` contract. Implement a `clone` method that properly creates the internal state of the cloned object.\n\nNotable exceptions to this recommendation are:\n\n* Classes that contain only primitive types (which will be properly cloned by `Object.clone` as long as its `Cloneable` supertypes all call `super.clone`).\n* Subclasses of `Cloneable` classes that do not introduce new state.\n\n## Example\nIn the following example, `WrongStack` does not implement `clone`. This means that when `ws1clone` is cloned from `ws1`, the default `clone` implementation is used. This results in operations on the `ws1clone` stack affecting the `ws1` stack.\n\n\n```java\nabstract class AbstractStack implements Cloneable {\n    public AbstractStack clone() {\n        try {\n            return (AbstractStack) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should not happen\");\n        }\n    }\n}\n\nclass WrongStack extends AbstractStack {\n    private static final int MAX_STACK = 10;\n    int[] elements = new int[MAX_STACK];\n    int top = -1;\n\n    void push(int newInt) {\n        elements[++top] = newInt;\n    }\n    int pop() {\n        return elements[top--];\n    }\n    // BAD: No 'clone' method to create a copy of the elements.\n    // Therefore, the default 'clone' implementation (shallow copy) is used, which\n    // is equivalent to:\n    //\n    //  public WrongStack clone() {\n    //      WrongStack cloned = (WrongStack) super.clone();\n    //      cloned.elements = elements;  // Both 'this' and 'cloned' now use the same elements.\n    //      return cloned;\n    //  }\n}\n\npublic class MissingMethodClone {\n    public static void main(String[] args) {\n        WrongStack ws1 = new WrongStack();              // ws1: {}\n        ws1.push(1);                                    // ws1: {1}\n        ws1.push(2);                                    // ws1: {1,2}\n        WrongStack ws1clone = (WrongStack) ws1.clone(); // ws1clone: {1,2}\n        ws1clone.pop();                                 // ws1clone: {1}\n        ws1clone.push(3);                               // ws1clone: {1,3}\n        System.out.println(ws1.pop());                  // Because ws1 and ws1clone have the same\n                                                        // elements, this prints 3 instead of 2\n    }\n}\n\n\n\n```\nIn the following modified example, `RightStack` *does* implement `clone`. This means that when `rs1clone` is cloned from `rs1`, operations on the `rs1clone` stack do not affect the `rs1` stack.\n\n\n```java\nabstract class AbstractStack implements Cloneable {\n    public AbstractStack clone() {\n        try {\n            return (AbstractStack) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should not happen\");\n        }\n    }\n}\n\nclass RightStack extends AbstractStack {\n    private static final int MAX_STACK = 10;\n    int[] elements = new int[MAX_STACK];\n    int top = -1;\n\n    void push(int newInt) {\n        elements[++top] = newInt;\n    }\n    int pop() {\n        return elements[top--];\n    }\n\n    // GOOD: 'clone' method to create a copy of the elements.\n    public RightStack clone() {\n        RightStack cloned = (RightStack) super.clone();\n        cloned.elements = elements.clone();  // 'cloned' has its own elements.\n        return cloned;\n    }\n}\n\npublic class MissingMethodClone {\n    public static void main(String[] args) {\n        RightStack rs1 = new RightStack();              // rs1: {}\n        rs1.push(1);                                    // rs1: {1}\n        rs1.push(2);                                    // rs1: {1,2}\n        RightStack rs1clone = rs1.clone();              // rs1clone: {1,2}\n        rs1clone.pop();                                 // rs1clone: {1}\n        rs1clone.push(3);                               // rs1clone: {1,3}\n        System.out.println(rs1.pop());                  // Correctly prints 2\n    }\n}\n\n\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n","markdown":"# No clone method\nA class that implements `Cloneable` should override `Object.clone`. For non-trivial objects, the `Cloneable` contract requires a deep copy of the object's internal state. A class that does not have a `clone` method indicates that the class is breaking the contract and will have undesired behavior.\n\nThe Java API Specification states that, for an object `x`, the general intent of the `clone` method is for it to satisfy the following three properties:\n\n* `x.clone() != x` (the cloned object is a different object instance)\n* `x.clone().getClass() == x.getClass()` (the cloned object is the same type as the source object)\n* `x.clone().equals(x)` (the cloned object has the same 'contents' as the source object)\nFor the cloned object to be of the same type as the source object, non-final classes must call `super.clone` and that call must eventually reach `Object.clone`, which creates an instance of the right type. If it were to create a new object using a constructor, a subclass that does not implement the `clone` method returns an object of the wrong type. In addition, all of the class's supertypes that also override `clone` must call `super.clone`. Otherwise, it never reaches `Object.clone` and creates an object of the incorrect type.\n\nHowever, as `Object.clone` only does a shallow copy of the fields of an object, any `Cloneable` objects that have a \"deep structure\" (for example, objects that use an array or `Collection`) must take the clone that results from the call to `super.clone` and assign explicitly created copies of the structure to the clone's fields. This means that the cloned instance does not share its internal state with the source object. If it *did* share its internal state, any changes made in the cloned object would also affect the internal state of the source object, probably causing unintended behavior.\n\nOne added complication is that `clone` cannot modify values in final fields, which would be already set by the call to `super.clone`. Some fields must be made non-final to correctly implement the `clone` method.\n\n\n## Recommendation\nThe necessity of creating a deep copy of an object's internal state means that, for most objects, `clone` must be overridden to satisfy the `Cloneable` contract. Implement a `clone` method that properly creates the internal state of the cloned object.\n\nNotable exceptions to this recommendation are:\n\n* Classes that contain only primitive types (which will be properly cloned by `Object.clone` as long as its `Cloneable` supertypes all call `super.clone`).\n* Subclasses of `Cloneable` classes that do not introduce new state.\n\n## Example\nIn the following example, `WrongStack` does not implement `clone`. This means that when `ws1clone` is cloned from `ws1`, the default `clone` implementation is used. This results in operations on the `ws1clone` stack affecting the `ws1` stack.\n\n\n```java\nabstract class AbstractStack implements Cloneable {\n    public AbstractStack clone() {\n        try {\n            return (AbstractStack) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should not happen\");\n        }\n    }\n}\n\nclass WrongStack extends AbstractStack {\n    private static final int MAX_STACK = 10;\n    int[] elements = new int[MAX_STACK];\n    int top = -1;\n\n    void push(int newInt) {\n        elements[++top] = newInt;\n    }\n    int pop() {\n        return elements[top--];\n    }\n    // BAD: No 'clone' method to create a copy of the elements.\n    // Therefore, the default 'clone' implementation (shallow copy) is used, which\n    // is equivalent to:\n    //\n    //  public WrongStack clone() {\n    //      WrongStack cloned = (WrongStack) super.clone();\n    //      cloned.elements = elements;  // Both 'this' and 'cloned' now use the same elements.\n    //      return cloned;\n    //  }\n}\n\npublic class MissingMethodClone {\n    public static void main(String[] args) {\n        WrongStack ws1 = new WrongStack();              // ws1: {}\n        ws1.push(1);                                    // ws1: {1}\n        ws1.push(2);                                    // ws1: {1,2}\n        WrongStack ws1clone = (WrongStack) ws1.clone(); // ws1clone: {1,2}\n        ws1clone.pop();                                 // ws1clone: {1}\n        ws1clone.push(3);                               // ws1clone: {1,3}\n        System.out.println(ws1.pop());                  // Because ws1 and ws1clone have the same\n                                                        // elements, this prints 3 instead of 2\n    }\n}\n\n\n\n```\nIn the following modified example, `RightStack` *does* implement `clone`. This means that when `rs1clone` is cloned from `rs1`, operations on the `rs1clone` stack do not affect the `rs1` stack.\n\n\n```java\nabstract class AbstractStack implements Cloneable {\n    public AbstractStack clone() {\n        try {\n            return (AbstractStack) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(\"Should not happen\");\n        }\n    }\n}\n\nclass RightStack extends AbstractStack {\n    private static final int MAX_STACK = 10;\n    int[] elements = new int[MAX_STACK];\n    int top = -1;\n\n    void push(int newInt) {\n        elements[++top] = newInt;\n    }\n    int pop() {\n        return elements[top--];\n    }\n\n    // GOOD: 'clone' method to create a copy of the elements.\n    public RightStack clone() {\n        RightStack cloned = (RightStack) super.clone();\n        cloned.elements = elements.clone();  // 'cloned' has its own elements.\n        return cloned;\n    }\n}\n\npublic class MissingMethodClone {\n    public static void main(String[] args) {\n        RightStack rs1 = new RightStack();              // rs1: {}\n        rs1.push(1);                                    // rs1: {1}\n        rs1.push(2);                                    // rs1: {1,2}\n        RightStack rs1clone = rs1.clone();              // rs1clone: {1,2}\n        rs1clone.pop();                                 // rs1clone: {1}\n        rs1clone.push(3);                               // rs1clone: {1,3}\n        System.out.println(rs1.pop());                  // Correctly prints 2\n    }\n}\n\n\n\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 11. Addison-Wesley, 2008.\n* Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).\n"},"properties":{"tags":["reliability","maintainability"],"description":"A class that implements 'Cloneable' but does not override the 'clone' method will\n              have undesired behavior.","id":"java/missing-clone-method","kind":"problem","name":"No clone method","precision":"medium","problem.severity":"error"}},{"id":"java/non-serializable-inner-class","name":"java/non-serializable-inner-class","shortDescription":{"text":"Serializable inner class of non-serializable class"},"fullDescription":{"text":"A class that is serializable with an enclosing class that is not serializable causes serialization to fail."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Serializable inner class of non-serializable class\nNon-static nested classes that implement `Serializable` must be defined in an enclosing class that is also serializable. Non-static nested classes retain an implicit reference to an instance of their enclosing class. If the enclosing class is not serializable, the Java serialization mechanism fails with a `java.io.NotSerializableException`.\n\n\n## Recommendation\nTo avoid causing a `NotSerializableException`, do one of the following:\n\n* **Declare the nested class as `static` :** If the nested class does not use any of the non-static fields or methods of the enclosing class, it is best to declare it `static`. This removes the implicit reference to an instance of the enclosing class, and has the additional effect of breaking an unnecessary dependency between the two classes. A similar solution is to turn the nested class into a separate top-level class.\n* **Make the enclosing class implement `Serializable` :** However, this is not recommended because the implementation of inner classes may be compiler-specific, and serializing an inner class can result in non-portability across compilers. The Java Serialization Specification states: <blockquote><p> Serialization of inner classes (i.e., nested classes that are not static member classes), including local and anonymous classes, is strongly discouraged for several reasons. Because inner classes declared in non-static contexts contain implicit non-transient references to enclosing class instances, serializing such an inner class instance will result in serialization of its associated outer class instance as well. Synthetic fields generated by javac (or other Java(TM) compilers) to implement inner classes are implementation dependent and may vary between compilers; differences in such fields can disrupt compatibility as well as result in conflicting default serialVersionUID values. The names assigned to local and anonymous inner classes are also implementation dependent and may differ between compilers. </p> </blockquote>\n\n## Example\nIn the following example, the class `WrongSession` cannot be serialized without causing a `NotSerializableException`, because it is enclosed by a non-serializable class. However, the class `Session` can be serialized because it is declared as `static`.\n\n\n```java\nclass NonSerializableServer {\n\n    // BAD: The following class is serializable, but the enclosing class\n    // 'NonSerializableServer' is not. Serializing an instance of 'WrongSession' \n    // causes a 'java.io.NotSerializableException'.\n    class WrongSession implements Serializable {\n        private static final long serialVersionUID = 8970783971992397218L;\n        private int id;\n        private String user;\n        \n        WrongSession(int id, String user) { /*...*/ }\n    }\n    \n    public WrongSession getNewSession(String user) {\n        return new WrongSession(newId(), user);\n    }\n}\n\nclass Server {\n\n    // GOOD: The following class can be correctly serialized because it is static.\n    static class Session implements Serializable {\n        private static final long serialVersionUID = 1065454318648105638L;\n        private int id;\n        private String user;\n        \n        Session(int id, String user) { /*...*/ }\n    }\n    \n    public Session getNewSession(String user) {\n        return new Session(newId(), user);\n    }\n}\n```\n\n## References\n* Java Object Serialization Specification: [1.10 The Serializable Interface](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#the-serializable-interface), [2.1 The ObjectOutputStream Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/output.html#the-objectoutputstream-class).\n","markdown":"# Serializable inner class of non-serializable class\nNon-static nested classes that implement `Serializable` must be defined in an enclosing class that is also serializable. Non-static nested classes retain an implicit reference to an instance of their enclosing class. If the enclosing class is not serializable, the Java serialization mechanism fails with a `java.io.NotSerializableException`.\n\n\n## Recommendation\nTo avoid causing a `NotSerializableException`, do one of the following:\n\n* **Declare the nested class as `static` :** If the nested class does not use any of the non-static fields or methods of the enclosing class, it is best to declare it `static`. This removes the implicit reference to an instance of the enclosing class, and has the additional effect of breaking an unnecessary dependency between the two classes. A similar solution is to turn the nested class into a separate top-level class.\n* **Make the enclosing class implement `Serializable` :** However, this is not recommended because the implementation of inner classes may be compiler-specific, and serializing an inner class can result in non-portability across compilers. The Java Serialization Specification states: <blockquote><p> Serialization of inner classes (i.e., nested classes that are not static member classes), including local and anonymous classes, is strongly discouraged for several reasons. Because inner classes declared in non-static contexts contain implicit non-transient references to enclosing class instances, serializing such an inner class instance will result in serialization of its associated outer class instance as well. Synthetic fields generated by javac (or other Java(TM) compilers) to implement inner classes are implementation dependent and may vary between compilers; differences in such fields can disrupt compatibility as well as result in conflicting default serialVersionUID values. The names assigned to local and anonymous inner classes are also implementation dependent and may differ between compilers. </p> </blockquote>\n\n## Example\nIn the following example, the class `WrongSession` cannot be serialized without causing a `NotSerializableException`, because it is enclosed by a non-serializable class. However, the class `Session` can be serialized because it is declared as `static`.\n\n\n```java\nclass NonSerializableServer {\n\n    // BAD: The following class is serializable, but the enclosing class\n    // 'NonSerializableServer' is not. Serializing an instance of 'WrongSession' \n    // causes a 'java.io.NotSerializableException'.\n    class WrongSession implements Serializable {\n        private static final long serialVersionUID = 8970783971992397218L;\n        private int id;\n        private String user;\n        \n        WrongSession(int id, String user) { /*...*/ }\n    }\n    \n    public WrongSession getNewSession(String user) {\n        return new WrongSession(newId(), user);\n    }\n}\n\nclass Server {\n\n    // GOOD: The following class can be correctly serialized because it is static.\n    static class Session implements Serializable {\n        private static final long serialVersionUID = 1065454318648105638L;\n        private int id;\n        private String user;\n        \n        Session(int id, String user) { /*...*/ }\n    }\n    \n    public Session getNewSession(String user) {\n        return new Session(newId(), user);\n    }\n}\n```\n\n## References\n* Java Object Serialization Specification: [1.10 The Serializable Interface](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#the-serializable-interface), [2.1 The ObjectOutputStream Class](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/output.html#the-objectoutputstream-class).\n"},"properties":{"tags":["reliability","maintainability","language-features"],"description":"A class that is serializable with an enclosing class that is not serializable\n              causes serialization to fail.","id":"java/non-serializable-inner-class","kind":"problem","name":"Serializable inner class of non-serializable class","precision":"medium","problem.severity":"warning"}},{"id":"java/wrong-object-serialization-signature","name":"java/wrong-object-serialization-signature","shortDescription":{"text":"Serialization methods do not match required signature"},"fullDescription":{"text":"A serialized class that implements 'readObject', 'readObjectNoData' or 'writeObject' but does not use the correct signatures causes the default serialization mechanism to be used."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Serialization methods do not match required signature\nA serializable object that defines its own serialization protocol using the methods `readObject`, `readObjectNoData` or `writeObject` must use the signature that is expected by the Java serialization framework. Otherwise, the default serialization mechanism is used.\n\n\n## Recommendation\nMake sure that the signatures of `readObject`, `readObjectNoData` and `writeObject` on serializable classes match these expected signatures:\n\n\n```java\nprivate void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException;\nprivate void readObjectNoData()\n     throws ObjectStreamException;\nprivate void writeObject(java.io.ObjectOutputStream out)\n     throws IOException;\n```\n\n## Example\nIn the following example, `WrongNetRequest` defines `readObject`, `readObjectNoData` and `writeObject` using the wrong signatures. However, `NetRequest` defines them correctly.\n\n\n```java\nclass WrongNetRequest implements Serializable {\n\t// BAD: Does not match the exact signature required for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\tvoid readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\tvoid readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required for a custom \n\t// serialization protocol. Will not be called during serialization.\n\tprotected void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n\nclass NetRequest implements Serializable {\n\t// GOOD: Signature for a custom deserialization implementation.\n\tprivate void readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom deserialization implementation.\n\tprivate void readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom serialization implementation.\n\tprivate void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* Oracle Technology Network: [Discover the secrets of the Java Serialization API](https://www.oracle.com/technical-resources/articles/java/serializationapi.html).\n","markdown":"# Serialization methods do not match required signature\nA serializable object that defines its own serialization protocol using the methods `readObject`, `readObjectNoData` or `writeObject` must use the signature that is expected by the Java serialization framework. Otherwise, the default serialization mechanism is used.\n\n\n## Recommendation\nMake sure that the signatures of `readObject`, `readObjectNoData` and `writeObject` on serializable classes match these expected signatures:\n\n\n```java\nprivate void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException;\nprivate void readObjectNoData()\n     throws ObjectStreamException;\nprivate void writeObject(java.io.ObjectOutputStream out)\n     throws IOException;\n```\n\n## Example\nIn the following example, `WrongNetRequest` defines `readObject`, `readObjectNoData` and `writeObject` using the wrong signatures. However, `NetRequest` defines them correctly.\n\n\n```java\nclass WrongNetRequest implements Serializable {\n\t// BAD: Does not match the exact signature required for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\tvoid readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required for a custom \n\t// deserialization protocol. Will not be called during deserialization.\n\tvoid readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// BAD: Does not match the exact signature required for a custom \n\t// serialization protocol. Will not be called during serialization.\n\tprotected void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n\nclass NetRequest implements Serializable {\n\t// GOOD: Signature for a custom deserialization implementation.\n\tprivate void readObject(ObjectInputStream in) {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom deserialization implementation.\n\tprivate void readObjectNoData() {\n\t\t//...\n\t}\n\t\n\t// GOOD: Signature for a custom serialization implementation.\n\tprivate void writeObject(ObjectOutputStream out) {\n\t\t//...\n\t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* Oracle Technology Network: [Discover the secrets of the Java Serialization API](https://www.oracle.com/technical-resources/articles/java/serializationapi.html).\n"},"properties":{"tags":["reliability","maintainability","language-features"],"description":"A serialized class that implements 'readObject', 'readObjectNoData' or 'writeObject' but\n              does not use the correct signatures causes the default serialization mechanism to be used.","id":"java/wrong-object-serialization-signature","kind":"problem","name":"Serialization methods do not match required signature","precision":"medium","problem.severity":"warning"}},{"id":"java/incorrect-serial-version-uid","name":"java/incorrect-serial-version-uid","shortDescription":{"text":"Incorrect serialVersionUID field"},"fullDescription":{"text":"A 'serialVersionUID' field that is declared in a serializable class but is of the wrong type cannot be used by the serialization framework."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Incorrect serialVersionUID field\nA serializable class that uses the `serialVersionUID` field to act as an object version number must declare the field to be `final`, `static`, and of type `long` for it to be used by the Java serialization framework.\n\n\n## Recommendation\nMake sure that the `serialVersionUID` field in a serialized class is final, static, and of type `long`.\n\n\n## Example\nIn the following example, `WrongNote` defines `serialVersionUID` using the wrong type, so that it is not used by the Java serialization framework. However, `Note` defines it correctly so that it is used by the framework.\n\n\n```java\nclass WrongNote implements Serializable {\n\t// BAD: serialVersionUID must be static, final, and 'long'\n\tprivate static final int serialVersionUID = 1;\n\t\n\t//...\n}\n\nclass Note implements Serializable {\n\t// GOOD: serialVersionUID is of the correct type\n\tprivate static final long serialVersionUID = 1L;\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* JavaWorld: [Ensure proper version control for serialized objects](https://www.infoworld.com/article/2071731/ensure-proper-version-control-for-serialized-objects.html).\n","markdown":"# Incorrect serialVersionUID field\nA serializable class that uses the `serialVersionUID` field to act as an object version number must declare the field to be `final`, `static`, and of type `long` for it to be used by the Java serialization framework.\n\n\n## Recommendation\nMake sure that the `serialVersionUID` field in a serialized class is final, static, and of type `long`.\n\n\n## Example\nIn the following example, `WrongNote` defines `serialVersionUID` using the wrong type, so that it is not used by the Java serialization framework. However, `Note` defines it correctly so that it is used by the framework.\n\n\n```java\nclass WrongNote implements Serializable {\n\t// BAD: serialVersionUID must be static, final, and 'long'\n\tprivate static final int serialVersionUID = 1;\n\t\n\t//...\n}\n\nclass Note implements Serializable {\n\t// GOOD: serialVersionUID is of the correct type\n\tprivate static final long serialVersionUID = 1L;\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* JavaWorld: [Ensure proper version control for serialized objects](https://www.infoworld.com/article/2071731/ensure-proper-version-control-for-serialized-objects.html).\n"},"properties":{"tags":["reliability","maintainability","language-features"],"description":"A 'serialVersionUID' field that is declared in a serializable class but is of the\n              wrong type cannot be used by the serialization framework.","id":"java/incorrect-serial-version-uid","kind":"problem","name":"Incorrect serialVersionUID field","precision":"medium","problem.severity":"warning"}},{"id":"java/missing-no-arg-constructor-on-serializable","name":"java/missing-no-arg-constructor-on-serializable","shortDescription":{"text":"Serializable but no void constructor"},"fullDescription":{"text":"A non-serializable, immediate superclass of a serializable class that does not itself declare an accessible, no-argument constructor causes deserialization to fail."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Serializable but no void constructor\nA serializable class that is a subclass of a non-serializable class cannot be deserialized if its superclass does not declare a no-argument constructor. The Java serialization framework uses the no-argument constructor when it initializes the object instance that is created during deserialization. Deserialization fails with an `InvalidClassException` if its superclass does not declare a no-argument constructor.\n\nThe Java Development Kit API documentation states:\n\n> To allow subtypes of non-serializable classes to be serialized, the subtype may assume responsibility for saving and restoring the state of the supertype's public, protected, and (if accessible) package fields. The subtype may assume this responsibility only if the class it extends has an accessible no-arg constructor to initialize the class's state. It is an error to declare a class `Serializable` if this is not the case. The error will be detected at runtime.\n\n\n## Recommendation\nMake sure that every non-serializable class that is extended by a serializable class has a no-argument constructor. Alternatively, consider defining a `writeReplace` method that replaces the `Serializable` class instance with a serialization proxy, so as to avoid direct deserialization of a class whose parent lacks a no-argument constructor.\n\n\n## Example\nIn the following example, the class `WrongSubItem` cannot be deserialized because its superclass `WrongItem` does not declare a no-argument constructor. However, the class `SubItem` *can* be serialized because it declares a no-argument constructor.\n\n\n```java\nclass WrongItem {\n    private String name;\n\n    // BAD: This class does not have a no-argument constructor, and throws an\n    // 'InvalidClassException' at runtime.\n\n    public WrongItem(String name) {\n        this.name = name;\n    }\n}\n\nclass WrongSubItem extends WrongItem implements Serializable {\n    public WrongSubItem() {\n        super(null);\n    }\n\n    public WrongSubItem(String name) {\n        super(name);\n    }\n}\n\nclass Item {\n    private String name;\n\n    // GOOD: This class declares a no-argument constructor, which allows serializable \n    // subclasses to be deserialized without error.\n    public Item() {}\n\n    public Item(String name) {\n        this.name = name;\n    }\n}\n\nclass SubItem extends Item implements Serializable {\n    public SubItem() { \n        super(null); \n    }\n\n    public SubItem(String name) {\n        super(name);\n    }\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* J. Bloch, *Effective Java (second edition)*, Item 74. Addison-Wesley, 2008.\n","markdown":"# Serializable but no void constructor\nA serializable class that is a subclass of a non-serializable class cannot be deserialized if its superclass does not declare a no-argument constructor. The Java serialization framework uses the no-argument constructor when it initializes the object instance that is created during deserialization. Deserialization fails with an `InvalidClassException` if its superclass does not declare a no-argument constructor.\n\nThe Java Development Kit API documentation states:\n\n> To allow subtypes of non-serializable classes to be serialized, the subtype may assume responsibility for saving and restoring the state of the supertype's public, protected, and (if accessible) package fields. The subtype may assume this responsibility only if the class it extends has an accessible no-arg constructor to initialize the class's state. It is an error to declare a class `Serializable` if this is not the case. The error will be detected at runtime.\n\n\n## Recommendation\nMake sure that every non-serializable class that is extended by a serializable class has a no-argument constructor. Alternatively, consider defining a `writeReplace` method that replaces the `Serializable` class instance with a serialization proxy, so as to avoid direct deserialization of a class whose parent lacks a no-argument constructor.\n\n\n## Example\nIn the following example, the class `WrongSubItem` cannot be deserialized because its superclass `WrongItem` does not declare a no-argument constructor. However, the class `SubItem` *can* be serialized because it declares a no-argument constructor.\n\n\n```java\nclass WrongItem {\n    private String name;\n\n    // BAD: This class does not have a no-argument constructor, and throws an\n    // 'InvalidClassException' at runtime.\n\n    public WrongItem(String name) {\n        this.name = name;\n    }\n}\n\nclass WrongSubItem extends WrongItem implements Serializable {\n    public WrongSubItem() {\n        super(null);\n    }\n\n    public WrongSubItem(String name) {\n        super(name);\n    }\n}\n\nclass Item {\n    private String name;\n\n    // GOOD: This class declares a no-argument constructor, which allows serializable \n    // subclasses to be deserialized without error.\n    public Item() {}\n\n    public Item(String name) {\n        this.name = name;\n    }\n}\n\nclass SubItem extends Item implements Serializable {\n    public SubItem() { \n        super(null); \n    }\n\n    public SubItem(String name) {\n        super(name);\n    }\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* J. Bloch, *Effective Java (second edition)*, Item 74. Addison-Wesley, 2008.\n"},"properties":{"tags":["reliability","maintainability","language-features"],"description":"A non-serializable, immediate superclass of a serializable class that does not\n              itself declare an accessible, no-argument constructor causes deserialization to\n              fail.","id":"java/missing-no-arg-constructor-on-serializable","kind":"problem","name":"Serializable but no void constructor","precision":"medium","problem.severity":"warning"}},{"id":"java/wrong-readresolve-signature","name":"java/wrong-readresolve-signature","shortDescription":{"text":"ReadResolve must have Object return type, not void"},"fullDescription":{"text":"An implementation of 'readResolve' that does not have the signature that is expected by the Java serialization framework is not recognized by the serialization mechanism."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# ReadResolve must have Object return type, not void\nIf a class uses the `readResolve` method to specify a replacement object instance when the object is read from a stream, ensure that the signature of `readResolve` is *exactly* what the Java serialization mechanism expects.\n\n\n## Recommendation\nEnsure that the signature of the `readResolve` method in the class matches the expected signature:\n\n` ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException; `\n\nNote that the method *must* return a `java.lang.Object`.\n\nIf `readResolve` is used for instance control of a serializable singleton, (that is, to make sure that deserializing a singleton class does not result in another instance of the singleton) it may be possible to use an `enum` with a single element instead. The Java serialization specification explicitly ensures that deserializing an `enum` does not create a new instance. (For details about this technique, see \\[Bloch\\].)\n\n\n## Example\nIn the following example, `FalseSingleton.readResolve` has the wrong signature, which causes deserialization to create a new instance of the singleton. However, `Singleton.readResolve` has the correct signature, which means that deserialization does not result in another instance of the singleton.\n\n\n```java\nclass FalseSingleton implements Serializable {\n\tprivate static final long serialVersionUID = -7480651116825504381L;\n\tprivate static FalseSingleton instance;\n\t\n\tprivate FalseSingleton() {}\n\t\n\tpublic static FalseSingleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new FalseSingleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// BAD: Signature of 'readResolve' does not match the exact signature that is expected\n\t// (that is, it does not return 'java.lang.Object').\n\tpublic FalseSingleton readResolve() throws ObjectStreamException {\n\t\treturn FalseSingleton.getInstance();\n\t}\n}\n\nclass Singleton implements Serializable {\n\tprivate static final long serialVersionUID = -7480651116825504381L;\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\tpublic static Singleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// GOOD: Signature of 'readResolve' matches the exact signature that is expected.\n\t// It replaces the singleton that is read from a stream with an instance of 'Singleton',\n\t// instead of creating a new singleton.\n\tprivate Object readResolve() throws ObjectStreamException {\n\t\treturn Singleton.getInstance();\n\t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* Java Object Serialization Specification: [3.7 The readResolve Method](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/input.html#the-readresolve-method), [1.12 Serialization of Enum Constants](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#serialization-of-enum-constants).\n* J. Bloch, *Effective Java (second edition)*, Item 77. Addison-Wesley, 2008.\n","markdown":"# ReadResolve must have Object return type, not void\nIf a class uses the `readResolve` method to specify a replacement object instance when the object is read from a stream, ensure that the signature of `readResolve` is *exactly* what the Java serialization mechanism expects.\n\n\n## Recommendation\nEnsure that the signature of the `readResolve` method in the class matches the expected signature:\n\n` ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException; `\n\nNote that the method *must* return a `java.lang.Object`.\n\nIf `readResolve` is used for instance control of a serializable singleton, (that is, to make sure that deserializing a singleton class does not result in another instance of the singleton) it may be possible to use an `enum` with a single element instead. The Java serialization specification explicitly ensures that deserializing an `enum` does not create a new instance. (For details about this technique, see \\[Bloch\\].)\n\n\n## Example\nIn the following example, `FalseSingleton.readResolve` has the wrong signature, which causes deserialization to create a new instance of the singleton. However, `Singleton.readResolve` has the correct signature, which means that deserialization does not result in another instance of the singleton.\n\n\n```java\nclass FalseSingleton implements Serializable {\n\tprivate static final long serialVersionUID = -7480651116825504381L;\n\tprivate static FalseSingleton instance;\n\t\n\tprivate FalseSingleton() {}\n\t\n\tpublic static FalseSingleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new FalseSingleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// BAD: Signature of 'readResolve' does not match the exact signature that is expected\n\t// (that is, it does not return 'java.lang.Object').\n\tpublic FalseSingleton readResolve() throws ObjectStreamException {\n\t\treturn FalseSingleton.getInstance();\n\t}\n}\n\nclass Singleton implements Serializable {\n\tprivate static final long serialVersionUID = -7480651116825504381L;\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\tpublic static Singleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t// GOOD: Signature of 'readResolve' matches the exact signature that is expected.\n\t// It replaces the singleton that is read from a stream with an instance of 'Singleton',\n\t// instead of creating a new singleton.\n\tprivate Object readResolve() throws ObjectStreamException {\n\t\treturn Singleton.getInstance();\n\t}\n}\n```\n\n## References\n* Java API Specification: [Serializable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html).\n* Java Object Serialization Specification: [3.7 The readResolve Method](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/input.html#the-readresolve-method), [1.12 Serialization of Enum Constants](https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/serial-arch.html#serialization-of-enum-constants).\n* J. Bloch, *Effective Java (second edition)*, Item 77. Addison-Wesley, 2008.\n"},"properties":{"tags":["reliability","maintainability","language-features"],"description":"An implementation of 'readResolve' that does not have the signature that is expected\n              by the Java serialization framework is not recognized by the serialization\n              mechanism.","id":"java/wrong-readresolve-signature","kind":"problem","name":"ReadResolve must have Object return type, not void","precision":"medium","problem.severity":"warning"}},{"id":"java/missing-no-arg-constructor-on-externalizable","name":"java/missing-no-arg-constructor-on-externalizable","shortDescription":{"text":"Externalizable but no public no-argument constructor"},"fullDescription":{"text":"A class that implements 'Externalizable' but does not have a public no-argument constructor causes an 'InvalidClassException' to be thrown."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Externalizable but no public no-argument constructor\nA class that implements `java.io.Externalizable` must have a public no-argument constructor. The constructor is used by the Java serialization framework when it creates the object during deserialization. If the class does not define such a constructor, the Java serialization framework throws an `InvalidClassException`.\n\nThe Java Development Kit API documentation for `Externalizable` states:\n\n> When an `Externalizable` object is reconstructed, an instance is created using the public no-arg constructor, then the `readExternal` method called.\n\n\n## Recommendation\nMake sure that externalizable classes always have a no-argument constructor.\n\n\n## Example\nIn the following example, `WrongMemo` does not declare a public no-argument constructor. When the Java serialization framework tries to deserialize the object, an `InvalidClassException` is thrown. However, `Memo` does declare a public no-argument constructor, so that the object is deserialized successfully.\n\n\n```java\nclass WrongMemo implements Externalizable {\n    private String memo;\n\n    // BAD: No public no-argument constructor is defined. Deserializing this object\n    // causes an 'InvalidClassException'.\n\n    public WrongMemo(String memo) {\n        this.memo = memo;\n    }\n\n    public void writeExternal(ObjectOutput arg0) throws IOException {\n        //...\n    }\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //...\n    }\n}\n\nclass Memo implements Externalizable {\n    private String memo;\n\n    // GOOD: Declare a public no-argument constructor, which is used by the\n    // serialization framework when the object is deserialized.\n    public Memo() {\n    }\n\n    public Memo(String memo) {\n        this.memo = memo;\n    }\n\n    public void writeExternal(ObjectOutput out) throws IOException {\n        //...\n    }\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //...\n    }\n}\n\n```\n\n## References\n* Java API Specification: [Externalizable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Externalizable.html).\n","markdown":"# Externalizable but no public no-argument constructor\nA class that implements `java.io.Externalizable` must have a public no-argument constructor. The constructor is used by the Java serialization framework when it creates the object during deserialization. If the class does not define such a constructor, the Java serialization framework throws an `InvalidClassException`.\n\nThe Java Development Kit API documentation for `Externalizable` states:\n\n> When an `Externalizable` object is reconstructed, an instance is created using the public no-arg constructor, then the `readExternal` method called.\n\n\n## Recommendation\nMake sure that externalizable classes always have a no-argument constructor.\n\n\n## Example\nIn the following example, `WrongMemo` does not declare a public no-argument constructor. When the Java serialization framework tries to deserialize the object, an `InvalidClassException` is thrown. However, `Memo` does declare a public no-argument constructor, so that the object is deserialized successfully.\n\n\n```java\nclass WrongMemo implements Externalizable {\n    private String memo;\n\n    // BAD: No public no-argument constructor is defined. Deserializing this object\n    // causes an 'InvalidClassException'.\n\n    public WrongMemo(String memo) {\n        this.memo = memo;\n    }\n\n    public void writeExternal(ObjectOutput arg0) throws IOException {\n        //...\n    }\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //...\n    }\n}\n\nclass Memo implements Externalizable {\n    private String memo;\n\n    // GOOD: Declare a public no-argument constructor, which is used by the\n    // serialization framework when the object is deserialized.\n    public Memo() {\n    }\n\n    public Memo(String memo) {\n        this.memo = memo;\n    }\n\n    public void writeExternal(ObjectOutput out) throws IOException {\n        //...\n    }\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //...\n    }\n}\n\n```\n\n## References\n* Java API Specification: [Externalizable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Externalizable.html).\n"},"properties":{"tags":["reliability","maintainability","language-features"],"description":"A class that implements 'Externalizable' but does not have a public no-argument\n              constructor causes an 'InvalidClassException' to be thrown.","id":"java/missing-no-arg-constructor-on-externalizable","kind":"problem","name":"Externalizable but no public no-argument constructor","precision":"medium","problem.severity":"warning"}},{"id":"java/hashcode-typo","name":"java/hashcode-typo","shortDescription":{"text":"Typo in hashCode"},"fullDescription":{"text":"A method named 'hashcode' may be intended to be named 'hashCode'."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Typo in hashCode\nA method named `hashcode` may be a typographical error. `hashCode` (different capitalization) may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.hashCode`.\n\n\n## Example\nThe following example shows a method named `hashcode`. It may be better to rename it.\n\n\n```java\npublic class Person\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic int hashcode() {  // The method is named 'hashcode'.\n\t\tint hash = 23 * title.hashCode();\n\t\thash ^= 13 * forename.hashCode();\n\t\treturn hash ^ surname.hashCode();\n\t}\n}\n```\n\n## References\n* Java API Specification: [ Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n","markdown":"# Typo in hashCode\nA method named `hashcode` may be a typographical error. `hashCode` (different capitalization) may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.hashCode`.\n\n\n## Example\nThe following example shows a method named `hashcode`. It may be better to rename it.\n\n\n```java\npublic class Person\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic int hashcode() {  // The method is named 'hashcode'.\n\t\tint hash = 23 * title.hashCode();\n\t\thash ^= 13 * forename.hashCode();\n\t\treturn hash ^ surname.hashCode();\n\t}\n}\n```\n\n## References\n* Java API Specification: [ Object.hashCode](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()).\n"},"properties":{"tags":["maintainability","readability","naming"],"description":"A method named 'hashcode' may be intended to be named 'hashCode'.","id":"java/hashcode-typo","kind":"problem","name":"Typo in hashCode","precision":"medium","problem.severity":"warning"}},{"id":"java/equals-typo","name":"java/equals-typo","shortDescription":{"text":"Typo in equals"},"fullDescription":{"text":"A method named 'equal' may be intended to be named 'equals'."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Typo in equals\nA method named `equal` may be a typographical error. `equals` may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.equals`.\n\n\n## Example\nThe following example shows a method named `equal`. It may be better to rename it.\n\n\n```java\npublic class Complex\n{\n\tprivate double real;\n\tprivate double complex;\n\n\t// ...\n\n\tpublic boolean equal(Object obj) {  // The method is named 'equal'.\n\t\tif (!getClass().equals(obj.getClass()))\n\t\t\treturn false;\n\t\tComplex other = (Complex) obj;\n\t\treturn real == other.real && complex == other.complex;\n\t}\n}\n```\n\n## References\n* Java API Specification: [ equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n","markdown":"# Typo in equals\nA method named `equal` may be a typographical error. `equals` may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.equals`.\n\n\n## Example\nThe following example shows a method named `equal`. It may be better to rename it.\n\n\n```java\npublic class Complex\n{\n\tprivate double real;\n\tprivate double complex;\n\n\t// ...\n\n\tpublic boolean equal(Object obj) {  // The method is named 'equal'.\n\t\tif (!getClass().equals(obj.getClass()))\n\t\t\treturn false;\n\t\tComplex other = (Complex) obj;\n\t\treturn real == other.real && complex == other.complex;\n\t}\n}\n```\n\n## References\n* Java API Specification: [ equals](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)).\n"},"properties":{"tags":["maintainability","readability","naming"],"description":"A method named 'equal' may be intended to be named 'equals'.","id":"java/equals-typo","kind":"problem","name":"Typo in equals","precision":"medium","problem.severity":"warning"}},{"id":"java/non-short-circuit-evaluation","name":"java/non-short-circuit-evaluation","shortDescription":{"text":"Dangerous non-short-circuit logic"},"fullDescription":{"text":"Using a bitwise logical operator on a boolean where a conditional-and or conditional-or operator is intended may yield the wrong result or cause an exception."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Dangerous non-short-circuit logic\nUsing a bitwise logical operator (`&` or `|`) on a boolean where a conditional-and or conditional-or operator (`&&` or `||`) is intended may yield the wrong result or cause an exception. This is especially true if the left-hand operand is a guard for the right-hand operand.\n\nTypically, as in the example below, this kind of defect is introduced by simply mistyping the intended logical operator rather than any conceptual mistake by the programmer.\n\n\n## Recommendation\nIf the right-hand side of an expression is only intended to be evaluated if the left-hand side evaluates to `true`, use a conditional-and.\n\nSimilarly, if the right-hand side of an expression is only intended to be evaluated if the left-hand side evaluates to `false`, use a conditional-or.\n\n\n## Example\nIn the following example, the `hasForename` method is implemented correctly. For a forename to be valid it must be a non-null string with a non-zero length. The method has two expressions (`forename != null` and `forename.length() > 0`) to check these two properties. The second check is executed only if the first succeeds, because they are combined using a conditional-and operator (`&&`).\n\nIn contrast, although `hasSurname` looks almost the same, it contains a defect. Again there are two tests (`surname != null` and `surname.length() > 0`), but they are linked by a bitwise logical operator (`&`). Both sides of a bitwise logical operator are *always* evaluated, so if `surname` is `null` the `hasSurname` method throws a `NullPointerException`. To fix the defect, change `&` to `&&`.\n\n\n```java\npublic class Person\n{\n\tprivate String forename;\n\tprivate String surname;\n\n\tpublic boolean hasForename() {\n\t\treturn forename != null && forename.length() > 0;  // GOOD: Conditional-and operator\n\t}\n\n\tpublic boolean hasSurname() {\n\t\treturn surname != null & surname.length() > 0;  // BAD: Bitwise AND operator\n\t}\n\n\t// ...\n}\n```\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 42. Addison-Wesley, 2005.\n* Java Language Specification: [15.22.2 Boolean Logical Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.2), [15.23 Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23), [15.24 Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24).\n* Common Weakness Enumeration: [CWE-691](https://cwe.mitre.org/data/definitions/691.html).\n","markdown":"# Dangerous non-short-circuit logic\nUsing a bitwise logical operator (`&` or `|`) on a boolean where a conditional-and or conditional-or operator (`&&` or `||`) is intended may yield the wrong result or cause an exception. This is especially true if the left-hand operand is a guard for the right-hand operand.\n\nTypically, as in the example below, this kind of defect is introduced by simply mistyping the intended logical operator rather than any conceptual mistake by the programmer.\n\n\n## Recommendation\nIf the right-hand side of an expression is only intended to be evaluated if the left-hand side evaluates to `true`, use a conditional-and.\n\nSimilarly, if the right-hand side of an expression is only intended to be evaluated if the left-hand side evaluates to `false`, use a conditional-or.\n\n\n## Example\nIn the following example, the `hasForename` method is implemented correctly. For a forename to be valid it must be a non-null string with a non-zero length. The method has two expressions (`forename != null` and `forename.length() > 0`) to check these two properties. The second check is executed only if the first succeeds, because they are combined using a conditional-and operator (`&&`).\n\nIn contrast, although `hasSurname` looks almost the same, it contains a defect. Again there are two tests (`surname != null` and `surname.length() > 0`), but they are linked by a bitwise logical operator (`&`). Both sides of a bitwise logical operator are *always* evaluated, so if `surname` is `null` the `hasSurname` method throws a `NullPointerException`. To fix the defect, change `&` to `&&`.\n\n\n```java\npublic class Person\n{\n\tprivate String forename;\n\tprivate String surname;\n\n\tpublic boolean hasForename() {\n\t\treturn forename != null && forename.length() > 0;  // GOOD: Conditional-and operator\n\t}\n\n\tpublic boolean hasSurname() {\n\t\treturn surname != null & surname.length() > 0;  // BAD: Bitwise AND operator\n\t}\n\n\t// ...\n}\n```\n\n## References\n* J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 42. Addison-Wesley, 2005.\n* Java Language Specification: [15.22.2 Boolean Logical Operators &amp;, ^, and |](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.22.2), [15.23 Conditional-And Operator &amp;&amp;](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.23), [15.24 Conditional-Or Operator ||](https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.24).\n* Common Weakness Enumeration: [CWE-691](https://cwe.mitre.org/data/definitions/691.html).\n"},"properties":{"tags":["reliability","readability","external/cwe/cwe-691"],"description":"Using a bitwise logical operator on a boolean where a conditional-and or\n              conditional-or operator is intended may yield the wrong result or\n              cause an exception.","id":"java/non-short-circuit-evaluation","kind":"problem","name":"Dangerous non-short-circuit logic","precision":"medium","problem.severity":"warning"}},{"id":"java/tostring-typo","name":"java/tostring-typo","shortDescription":{"text":"Typo in toString"},"fullDescription":{"text":"A method named 'tostring' may be intended to be named 'toString'."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Typo in toString\nA method named `tostring` may be a typographical error. `toString` (different capitalization) may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.toString`.\n\n\n## Example\nThe following example shows a method named `tostring`. It may be better to rename it.\n\n\n```java\npublic class Customer\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic String tostring() {  // The method is named 'tostring'.\n\t\treturn title + \" \" + forename + \" \" + surname;\n\t}\n}\n```\n\n## References\n* Java API Specification: [ Object.toString](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n","markdown":"# Typo in toString\nA method named `tostring` may be a typographical error. `toString` (different capitalization) may have been intended instead.\n\n\n## Recommendation\nEnsure that any such method is intended to have this name. Even if it is, it may be better to rename it to avoid confusion with the inherited method `Object.toString`.\n\n\n## Example\nThe following example shows a method named `tostring`. It may be better to rename it.\n\n\n```java\npublic class Customer\n{\n\tprivate String title;\n\tprivate String forename;\n\tprivate String surname;\n\n\t// ...\n\n\tpublic String tostring() {  // The method is named 'tostring'.\n\t\treturn title + \" \" + forename + \" \" + surname;\n\t}\n}\n```\n\n## References\n* Java API Specification: [ Object.toString](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#toString()).\n"},"properties":{"tags":["maintainability","readability","naming"],"description":"A method named 'tostring' may be intended to be named 'toString'.","id":"java/tostring-typo","kind":"problem","name":"Typo in toString","precision":"medium","problem.severity":"warning"}},{"id":"java/iterator-remove-failure","name":"java/iterator-remove-failure","shortDescription":{"text":"Call to Iterator.remove may fail"},"fullDescription":{"text":"Attempting to invoke 'Iterator.remove' on an iterator over a collection that does not support element removal causes a runtime exception."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Call to Iterator.remove may fail\nThe `remove` method of the `Iterator` interface is an optional operation. It is not supported by iterators on unmodifiable collections, or iterators on lists constructed by the `Arrays.asList` method. Invoking `remove` on such an iterator will lead to an `UnsupportedOperationException`.\n\n\n## Recommendation\nIf a collection is meant to be modified after construction, use a modifiable collection type such as `ArrayList` or `HashSet`.\n\n\n## Example\nIn the following example, the constructor `A(Integer...)` initializes the field `A.l` to `Arrays.asList(is)`. While the type of lists returned by `Arrays.asList` supports element updates through the `set` method, it does not support element removal. Hence the call to `iter.remove` on line 20 must fail at runtime.\n\n\n```java\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class A {\n\tprivate List<Integer> l;\n\t\n\tpublic A(Integer... is) {\n\t\tthis.l = Arrays.asList(is);\n\t}\n\t\n\tpublic List<Integer> getList() {\n\t\treturn l;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tA a = new A(23, 42);\n\t\tfor (Iterator<Integer> iter = a.getList().iterator(); iter.hasNext();)\n\t\t\tif (iter.next()%2 != 0)\n\t\t\t\titer.remove();\n\t}\n}\n\n```\nTo avoid this failure, copy the list returned by `Arrays.asList` into a newly created `ArrayList` like this:\n\n\n```java\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class A {\n\tprivate List<Integer> l;\n\t\n\tpublic A(Integer... is) {\n\t\tthis.l = new ArrayList<Integer>(Arrays.asList(is));\n\t}\n\t\n\tpublic List<Integer> getList() {\n\t\treturn l;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tA a = new A(23, 42);\n\t\tfor (Iterator<Integer> iter = a.getList().iterator(); iter.hasNext();)\n\t\t\tif (iter.next()%2 != 0)\n\t\t\t\titer.remove();\n\t}\n}\n\n```\n\n## References\n* Mark Needham: [Java: Fooled by java.util.Arrays.asList](https://dzone.com/articles/java-fooled).\n","markdown":"# Call to Iterator.remove may fail\nThe `remove` method of the `Iterator` interface is an optional operation. It is not supported by iterators on unmodifiable collections, or iterators on lists constructed by the `Arrays.asList` method. Invoking `remove` on such an iterator will lead to an `UnsupportedOperationException`.\n\n\n## Recommendation\nIf a collection is meant to be modified after construction, use a modifiable collection type such as `ArrayList` or `HashSet`.\n\n\n## Example\nIn the following example, the constructor `A(Integer...)` initializes the field `A.l` to `Arrays.asList(is)`. While the type of lists returned by `Arrays.asList` supports element updates through the `set` method, it does not support element removal. Hence the call to `iter.remove` on line 20 must fail at runtime.\n\n\n```java\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class A {\n\tprivate List<Integer> l;\n\t\n\tpublic A(Integer... is) {\n\t\tthis.l = Arrays.asList(is);\n\t}\n\t\n\tpublic List<Integer> getList() {\n\t\treturn l;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tA a = new A(23, 42);\n\t\tfor (Iterator<Integer> iter = a.getList().iterator(); iter.hasNext();)\n\t\t\tif (iter.next()%2 != 0)\n\t\t\t\titer.remove();\n\t}\n}\n\n```\nTo avoid this failure, copy the list returned by `Arrays.asList` into a newly created `ArrayList` like this:\n\n\n```java\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class A {\n\tprivate List<Integer> l;\n\t\n\tpublic A(Integer... is) {\n\t\tthis.l = new ArrayList<Integer>(Arrays.asList(is));\n\t}\n\t\n\tpublic List<Integer> getList() {\n\t\treturn l;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tA a = new A(23, 42);\n\t\tfor (Iterator<Integer> iter = a.getList().iterator(); iter.hasNext();)\n\t\t\tif (iter.next()%2 != 0)\n\t\t\t\titer.remove();\n\t}\n}\n\n```\n\n## References\n* Mark Needham: [Java: Fooled by java.util.Arrays.asList](https://dzone.com/articles/java-fooled).\n"},"properties":{"tags":["reliability","correctness","logic"],"description":"Attempting to invoke 'Iterator.remove' on an iterator over a collection that does not\n              support element removal causes a runtime exception.","id":"java/iterator-remove-failure","kind":"problem","name":"Call to Iterator.remove may fail","precision":"medium","problem.severity":"warning"}},{"id":"java/type-variable-hides-type","name":"java/type-variable-hides-type","shortDescription":{"text":"Type variable hides another type"},"fullDescription":{"text":"A type variable with the same name as another type that is in scope can cause the two types to be confused."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Type variable hides another type\nType shadowing occurs if two types have the same name but one is defined within the scope of the other. This can arise if you introduce a type variable with the same name as an imported class.\n\nType shadowing may cause the two types to be confused, which can lead to various problems.\n\n\n## Recommendation\nName the type variable so that its name does not clash with the imported class.\n\n\n## Example\nIn the following example, the type `java.util.Map.Entry` is imported at the top of the file, but the class `Mapping` is defined with two type variables, `Key` and `Entry`. Uses of `Entry` within the `Mapping` class refer to the type variable, and not the imported interface. The type variable therefore shadows `Map.Entry`.\n\n\n```java\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nclass Mapping<Key, Entry>  // The type variable 'Entry' shadows the imported interface 'Entry'.\n{\n\t// ...\n}\n```\nTo fix the code, the type variable `Entry` on line 4 should be renamed.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [6.4 Shadowing and Obscuring](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4).\n","markdown":"# Type variable hides another type\nType shadowing occurs if two types have the same name but one is defined within the scope of the other. This can arise if you introduce a type variable with the same name as an imported class.\n\nType shadowing may cause the two types to be confused, which can lead to various problems.\n\n\n## Recommendation\nName the type variable so that its name does not clash with the imported class.\n\n\n## Example\nIn the following example, the type `java.util.Map.Entry` is imported at the top of the file, but the class `Mapping` is defined with two type variables, `Key` and `Entry`. Uses of `Entry` within the `Mapping` class refer to the type variable, and not the imported interface. The type variable therefore shadows `Map.Entry`.\n\n\n```java\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nclass Mapping<Key, Entry>  // The type variable 'Entry' shadows the imported interface 'Entry'.\n{\n\t// ...\n}\n```\nTo fix the code, the type variable `Entry` on line 4 should be renamed.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [6.4 Shadowing and Obscuring](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.4).\n"},"properties":{"tags":["reliability","readability","types"],"description":"A type variable with the same name as another type that is in scope can cause\n              the two types to be confused.","id":"java/type-variable-hides-type","kind":"problem","name":"Type variable hides another type","precision":"medium","problem.severity":"warning"}},{"id":"java/type-bound-extends-final","name":"java/type-bound-extends-final","shortDescription":{"text":"Type bound extends a final class"},"fullDescription":{"text":"If 'C' is a final class, a type bound such as '? extends C' is confusing because it implies that 'C' has subclasses, but a final class has no subclasses."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Type bound extends a final class\nA type wildcard with an `extends` clause (for example `?&nbsp;extends&nbsp;String`) implicitly suggests that a type (in this case `String`) has subclasses. If the type in the `extends` clause is final, the code is confusing because a final class cannot have any subclasses. The only type that satisfies `?&nbsp;extends&nbsp;String` is `String`.\n\n\n## Recommendation\nTo make the code more readable, omit the wildcard to leave just the final type.\n\n\n## Example\nIn the following example, a wildcard is used to refer to any type that is a subclass of `String`.\n\n\n```java\nclass Printer\n{\n\tvoid print(List<? extends String> strings) {  // Unnecessary wildcard\n\t\tfor (String s : strings)\n\t\t\tSystem.out.println(s);\n\t}\n}\n```\nHowever, because `String` is declared `final`, it does not have any subclasses. Therefore, it is clearer to replace `?&nbsp;extends&nbsp;String` with `String`.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [4.5.1 Type Arguments of Parameterized Types ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1), [8.1.1.2 final Classes](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.1.2).\n","markdown":"# Type bound extends a final class\nA type wildcard with an `extends` clause (for example `?&nbsp;extends&nbsp;String`) implicitly suggests that a type (in this case `String`) has subclasses. If the type in the `extends` clause is final, the code is confusing because a final class cannot have any subclasses. The only type that satisfies `?&nbsp;extends&nbsp;String` is `String`.\n\n\n## Recommendation\nTo make the code more readable, omit the wildcard to leave just the final type.\n\n\n## Example\nIn the following example, a wildcard is used to refer to any type that is a subclass of `String`.\n\n\n```java\nclass Printer\n{\n\tvoid print(List<? extends String> strings) {  // Unnecessary wildcard\n\t\tfor (String s : strings)\n\t\t\tSystem.out.println(s);\n\t}\n}\n```\nHowever, because `String` is declared `final`, it does not have any subclasses. Therefore, it is clearer to replace `?&nbsp;extends&nbsp;String` with `String`.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [4.5.1 Type Arguments of Parameterized Types ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1), [8.1.1.2 final Classes](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.1.2).\n"},"properties":{"tags":["maintainability","readability","types"],"description":"If 'C' is a final class, a type bound such as '? extends C'\n              is confusing because it implies that 'C' has subclasses, but\n              a final class has no subclasses.","id":"java/type-bound-extends-final","kind":"problem","name":"Type bound extends a final class","precision":"medium","problem.severity":"warning"}},{"id":"java/non-overriding-package-private","name":"java/non-overriding-package-private","shortDescription":{"text":"Confusing non-overriding of package-private method"},"fullDescription":{"text":"A method that appears to override another method but does not, because the declaring classes are in different packages, is potentially confusing."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Confusing non-overriding of package-private method\nIf a method is declared with default access (that is, not private, protected, nor public), it can only be overridden by methods in the same package. If a method of the same signature is defined in a subclass in a different package, it is a completely separate method and no overriding occurs.\n\nCode like this can be confusing for other programmers, who have to understand that there is no overriding relation, check that the original programmer did not intend one method to override the other, and avoid mixing up the two methods by accident.\n\n\n## Recommendation\nIn cases where there is intentionally no overriding, the best solution is to rename one or both of the methods to clarify their different purposes.\n\nIf one method is supposed to override another method that is declared with default access in another package, the access of the method must be changed to `public` or `protected`. Alternatively, the classes must be moved to the same package.\n\n\n## Example\nIn the following example, `PhotoResizerWidget.width` does not override `Widget.width` because one method is in package `gui` and one method is in package `gui.extras`.\n\n\n```java\n// File 1\npackage gui;\n\nabstract class Widget\n{\n    // ...\n\n    // Return the width (in pixels) of this widget\n    int width() {\n        // ...\n    }\n\n    // ...\n}\n\n// File 2\npackage gui.extras;\n\nclass PhotoResizerWidget extends Widget\n{\n    // ...\n \n    // Return the new width (of the photo when resized)\n    public int width() {\n        // ...\n    }\n   \n    // ...\n}\n```\nAssuming that no overriding is intentional, one or both of the methods should be renamed. For example, `PhotoResizerWidget.width` would be better named `PhotoResizerWidget.newPhotoWidth`.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [8.4.8.1 Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1).\n","markdown":"# Confusing non-overriding of package-private method\nIf a method is declared with default access (that is, not private, protected, nor public), it can only be overridden by methods in the same package. If a method of the same signature is defined in a subclass in a different package, it is a completely separate method and no overriding occurs.\n\nCode like this can be confusing for other programmers, who have to understand that there is no overriding relation, check that the original programmer did not intend one method to override the other, and avoid mixing up the two methods by accident.\n\n\n## Recommendation\nIn cases where there is intentionally no overriding, the best solution is to rename one or both of the methods to clarify their different purposes.\n\nIf one method is supposed to override another method that is declared with default access in another package, the access of the method must be changed to `public` or `protected`. Alternatively, the classes must be moved to the same package.\n\n\n## Example\nIn the following example, `PhotoResizerWidget.width` does not override `Widget.width` because one method is in package `gui` and one method is in package `gui.extras`.\n\n\n```java\n// File 1\npackage gui;\n\nabstract class Widget\n{\n    // ...\n\n    // Return the width (in pixels) of this widget\n    int width() {\n        // ...\n    }\n\n    // ...\n}\n\n// File 2\npackage gui.extras;\n\nclass PhotoResizerWidget extends Widget\n{\n    // ...\n \n    // Return the new width (of the photo when resized)\n    public int width() {\n        // ...\n    }\n   \n    // ...\n}\n```\nAssuming that no overriding is intentional, one or both of the methods should be renamed. For example, `PhotoResizerWidget.width` would be better named `PhotoResizerWidget.newPhotoWidth`.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* Java Language Specification: [8.4.8.1 Overriding (by Instance Methods)](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8.1).\n"},"properties":{"tags":["maintainability","readability"],"description":"A method that appears to override another method but does not, because the\n              declaring classes are in different packages, is potentially confusing.","id":"java/non-overriding-package-private","kind":"problem","name":"Confusing non-overriding of package-private method","precision":"medium","problem.severity":"warning"}},{"id":"java/unsafe-get-resource","name":"java/unsafe-get-resource","shortDescription":{"text":"Unsafe use of getResource"},"fullDescription":{"text":"Calling 'this.getClass().getResource()' may yield unexpected results if called from a subclass in another package."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unsafe use of getResource\nUsing the `Class.getResource` method is a common way of including some non-code resources with an application.\n\nThere are problems when this is called using `x.getClass().getResource()`, for some variable `x`. This is not a safe way to retrieve a resource. The method `getClass` returns the *run-time* class of `x` (that is, its actual, \"most derived\" class, rather than its declared type), which causes two potential problems:\n\n* If the run-time type of the receiving object is a subclass of the declared type and is in a different package, the resource path may be interpreted differently. According to its contract, `Class.getResource` qualifies non-absolute paths with the current package name, thus potentially returning a different resource or failing to find the requested resource.\n* `Class.getResource` delegates finding the resource to the class loader that loaded the class. At run time, there is no guarantee that all subclasses of a particular type are loaded by the same class loader, resulting in resource lookup failures that are difficult to diagnose.\n\n## Recommendation\nRather than using the `getClass` method, which relies on dynamic dispatch and run-time types, use `class` literals instead. For example, instead of calling `getClass().getResource()` on an object of type `Foo`, call `Foo.class.getResource()`. Class literals always refer to the declared type they are used on, removing the dependency on run-time types.\n\n\n## Example\nIn the following example, the calls to `getPostalCodes` return different results, depending on which class the call is made on: the class `Address` is in the package `framework` and the class `UKAddress` is in the package `client`.\n\n\n```java\npackage framework;\nclass Address {\n    public URL getPostalCodes() {\n        // AVOID: The call is made on the run-time type of 'this'.\n        return this.getClass().getResource(\"postal-codes.csv\");\n    }\n}\n\npackage client;\nclass UKAddress extends Address {\n    public void convert() {\n        // Looks up \"framework/postal-codes.csv\"\n        new Address().getPostalCodes();\n        // Looks up \"client/postal-codes.csv\"\n        new UKAddress().getPostalCodes();\n    }\n}\n```\nIn the following corrected example, the implementation of `getPostalCodes` is changed so that it always calls `getResource` on the same class.\n\n\n```java\npackage framework;\nclass Address {\n    public URL getPostalCodes() {\n        // GOOD: The call is always made on an object of the same type.\n        return Address.class.getResource(\"postal-codes.csv\");\n    }\n}\n\npackage client;\nclass UKAddress extends Address {\n    public void convert() {\n        // Looks up \"framework/postal-codes.csv\"\n        new Address().getPostalCodes();\n        // Looks up \"framework/postal-codes.csv\"\n        new UKAddress().getPostalCodes();\n    }\n}\n```\n\n## References\n* Java API Specification: [Class.getResource()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#getResource(java.lang.String)).\n","markdown":"# Unsafe use of getResource\nUsing the `Class.getResource` method is a common way of including some non-code resources with an application.\n\nThere are problems when this is called using `x.getClass().getResource()`, for some variable `x`. This is not a safe way to retrieve a resource. The method `getClass` returns the *run-time* class of `x` (that is, its actual, \"most derived\" class, rather than its declared type), which causes two potential problems:\n\n* If the run-time type of the receiving object is a subclass of the declared type and is in a different package, the resource path may be interpreted differently. According to its contract, `Class.getResource` qualifies non-absolute paths with the current package name, thus potentially returning a different resource or failing to find the requested resource.\n* `Class.getResource` delegates finding the resource to the class loader that loaded the class. At run time, there is no guarantee that all subclasses of a particular type are loaded by the same class loader, resulting in resource lookup failures that are difficult to diagnose.\n\n## Recommendation\nRather than using the `getClass` method, which relies on dynamic dispatch and run-time types, use `class` literals instead. For example, instead of calling `getClass().getResource()` on an object of type `Foo`, call `Foo.class.getResource()`. Class literals always refer to the declared type they are used on, removing the dependency on run-time types.\n\n\n## Example\nIn the following example, the calls to `getPostalCodes` return different results, depending on which class the call is made on: the class `Address` is in the package `framework` and the class `UKAddress` is in the package `client`.\n\n\n```java\npackage framework;\nclass Address {\n    public URL getPostalCodes() {\n        // AVOID: The call is made on the run-time type of 'this'.\n        return this.getClass().getResource(\"postal-codes.csv\");\n    }\n}\n\npackage client;\nclass UKAddress extends Address {\n    public void convert() {\n        // Looks up \"framework/postal-codes.csv\"\n        new Address().getPostalCodes();\n        // Looks up \"client/postal-codes.csv\"\n        new UKAddress().getPostalCodes();\n    }\n}\n```\nIn the following corrected example, the implementation of `getPostalCodes` is changed so that it always calls `getResource` on the same class.\n\n\n```java\npackage framework;\nclass Address {\n    public URL getPostalCodes() {\n        // GOOD: The call is always made on an object of the same type.\n        return Address.class.getResource(\"postal-codes.csv\");\n    }\n}\n\npackage client;\nclass UKAddress extends Address {\n    public void convert() {\n        // Looks up \"framework/postal-codes.csv\"\n        new Address().getPostalCodes();\n        // Looks up \"framework/postal-codes.csv\"\n        new UKAddress().getPostalCodes();\n    }\n}\n```\n\n## References\n* Java API Specification: [Class.getResource()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#getResource(java.lang.String)).\n"},"properties":{"tags":["reliability","maintainability"],"description":"Calling 'this.getClass().getResource()' may yield unexpected results if called from a\n              subclass in another package.","id":"java/unsafe-get-resource","kind":"problem","name":"Unsafe use of getResource","precision":"medium","problem.severity":"warning"}},{"id":"java/iterator-hasnext-calls-next","name":"java/iterator-hasnext-calls-next","shortDescription":{"text":"Next in hasNext implementation"},"fullDescription":{"text":"Iterator implementations whose 'hasNext' method calls 'next' are most likely incorrect."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Next in hasNext implementation\nIterator implementations with a `hasNext` method that calls the `next` method are most likely incorrect. This is because `next` changes the iterator's position to the next element and returns that element, which is unlikely to be desirable in the implementation of `hasNext`.\n\n\n## Recommendation\nEnsure that any calls to `next` from within `hasNext` are legitimate. The `hasNext` method should indicate whether there are further elements remaining in the iteration without changing the iterator's state by calling `next`.\n\n\n## Example\nIn the following example, which outputs the contents of a string, `hasNext` calls `next`, which has the effect of changing the iterator's position. Given that `main` also calls `next` when it outputs an item, some items are skipped and only half the items are output.\n\n\n```java\npublic class NextFromIterator implements Iterator<String> {\n\tprivate int position = -1;\n\tprivate List<String> list = new ArrayList<String>() {{\n\t\tadd(\"alpha\"); add(\"bravo\"); add(\"charlie\"); add(\"delta\"); add(\"echo\"); add(\"foxtrot\");\n\t}};\n\t\n\tpublic boolean hasNext() {\n\t\treturn next() != null;  // BAD: Call to 'next'\n\t}\n\t\n\tpublic String next() {\n\t\tposition++;\n\t\treturn position < list.size() ? list.get(position) : null;\n\t}\n\n\tpublic void remove() {\n\t\t// ...\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tNextFromIterator x = new NextFromIterator();\n\t\twhile(x.hasNext()) {\n\t\t\tSystem.out.println(x.next());\n\t\t}\n\t}\n}\n```\nInstead, the implementation of `hasNext` should use another way of indicating whether there are further elements in the string without calling `next`. For example, `hasNext` could check the underlying array directly to see if there is an element at the next position.\n\n\n## References\n* Java API Specification: [Iterator.hasNext()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html#hasNext()), [Iterator.next()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html#next()).\n","markdown":"# Next in hasNext implementation\nIterator implementations with a `hasNext` method that calls the `next` method are most likely incorrect. This is because `next` changes the iterator's position to the next element and returns that element, which is unlikely to be desirable in the implementation of `hasNext`.\n\n\n## Recommendation\nEnsure that any calls to `next` from within `hasNext` are legitimate. The `hasNext` method should indicate whether there are further elements remaining in the iteration without changing the iterator's state by calling `next`.\n\n\n## Example\nIn the following example, which outputs the contents of a string, `hasNext` calls `next`, which has the effect of changing the iterator's position. Given that `main` also calls `next` when it outputs an item, some items are skipped and only half the items are output.\n\n\n```java\npublic class NextFromIterator implements Iterator<String> {\n\tprivate int position = -1;\n\tprivate List<String> list = new ArrayList<String>() {{\n\t\tadd(\"alpha\"); add(\"bravo\"); add(\"charlie\"); add(\"delta\"); add(\"echo\"); add(\"foxtrot\");\n\t}};\n\t\n\tpublic boolean hasNext() {\n\t\treturn next() != null;  // BAD: Call to 'next'\n\t}\n\t\n\tpublic String next() {\n\t\tposition++;\n\t\treturn position < list.size() ? list.get(position) : null;\n\t}\n\n\tpublic void remove() {\n\t\t// ...\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tNextFromIterator x = new NextFromIterator();\n\t\twhile(x.hasNext()) {\n\t\t\tSystem.out.println(x.next());\n\t\t}\n\t}\n}\n```\nInstead, the implementation of `hasNext` should use another way of indicating whether there are further elements in the string without calling `next`. For example, `hasNext` could check the underlying array directly to see if there is an element at the next position.\n\n\n## References\n* Java API Specification: [Iterator.hasNext()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html#hasNext()), [Iterator.next()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Iterator.html#next()).\n"},"properties":{"tags":["reliability","correctness"],"description":"Iterator implementations whose 'hasNext' method calls 'next' are most likely\n              incorrect.","id":"java/iterator-hasnext-calls-next","kind":"problem","name":"Next in hasNext implementation","precision":"medium","problem.severity":"warning"}},{"id":"java/run-finalizers-on-exit","name":"java/run-finalizers-on-exit","shortDescription":{"text":"Dangerous runFinalizersOnExit"},"fullDescription":{"text":"Calling 'System.runFinalizersOnExit' or 'Runtime.runFinalizersOnExit' may cause finalizers to be run on live objects, leading to erratic behavior or deadlock."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Dangerous runFinalizersOnExit\nAvoid calling `System.runFinalizersOnExit` or `Runtime.runFinalizersOnExit`, which are considered to be dangerous methods.\n\nThe Java Development Kit documentation for `System.runFinalizersOnExit` states:\n\n> This method is inherently unsafe. It may result in finalizers being called on live objects while other threads are concurrently manipulating those objects, resulting in erratic behavior or deadlock.\n\nObject finalizers are normally only called when the object is about to be collected by the garbage collector. Using `runFinalizersOnExit` sets a Java Virtual Machine-wide flag that executes finalizers *on all objects with a `finalize` method* before the runtime exits. This would require all objects with finalizers to defend against the possibility of `finalize` being called when the object is still in use, which is not practical for most applications.\n\n\n## Recommendation\nEnsure that the code does not rely on the execution of finalizers. If the code is dependent on the garbage collection behavior of the Java Virtual Machine, there is no guarantee that finalizers will be executed in a timely manner, or at all. This may become a problem if finalizers are used to dispose of limited system resources, such as file handles.\n\nInstead of finalizers, use explicit `dispose` methods in `finally` blocks, to make sure that an object's resources are released.\n\n\n## Example\nThe following example shows a program that calls `runFinalizersOnExit`, which is not recommended.\n\n\n```java\nvoid main() {\n\t// ...\n\t// BAD: Call to 'runFinalizersOnExit' forces execution of all finalizers on termination of \n\t// the runtime, which can cause live objects to transition to an invalid state.\n\t// Avoid using this method (and finalizers in general).\n\tSystem.runFinalizersOnExit(true);\n\t// ...\n}\n```\nThe following example shows the recommended approach: a program that calls a `dispose` method in a `finally` block.\n\n\n```java\n// Instead of using finalizers, define explicit termination methods \n// and call them in 'finally' blocks.\nclass LocalCache {\n\tprivate Collection<File> cacheFiles = ...;\n\t\n\t// Explicit method to close all cacheFiles\n\tpublic void dispose() {\n\t\tfor (File cacheFile : cacheFiles) {\n\t\t\tdisposeCacheFile(cacheFile);\n\t\t}\n\t}\n}\n\nvoid main() {\n\tLocalCache cache = new LocalCache();\n\ttry {\n\t\t// Use the cache\n\t} finally {\n\t\t// Call the termination method in a 'finally' block, to ensure that\n\t\t// the cache's resources are freed. \n\t\tcache.dispose();\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* Java API Specification: [System.runFinalizersOnExit()](https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#runFinalizersOnExit-boolean-), [Object.finalize()](https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#finalize--).\n* Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/javase/10/docs/api/java/lang/doc-files/threadPrimitiveDeprecation.html).\n","markdown":"# Dangerous runFinalizersOnExit\nAvoid calling `System.runFinalizersOnExit` or `Runtime.runFinalizersOnExit`, which are considered to be dangerous methods.\n\nThe Java Development Kit documentation for `System.runFinalizersOnExit` states:\n\n> This method is inherently unsafe. It may result in finalizers being called on live objects while other threads are concurrently manipulating those objects, resulting in erratic behavior or deadlock.\n\nObject finalizers are normally only called when the object is about to be collected by the garbage collector. Using `runFinalizersOnExit` sets a Java Virtual Machine-wide flag that executes finalizers *on all objects with a `finalize` method* before the runtime exits. This would require all objects with finalizers to defend against the possibility of `finalize` being called when the object is still in use, which is not practical for most applications.\n\n\n## Recommendation\nEnsure that the code does not rely on the execution of finalizers. If the code is dependent on the garbage collection behavior of the Java Virtual Machine, there is no guarantee that finalizers will be executed in a timely manner, or at all. This may become a problem if finalizers are used to dispose of limited system resources, such as file handles.\n\nInstead of finalizers, use explicit `dispose` methods in `finally` blocks, to make sure that an object's resources are released.\n\n\n## Example\nThe following example shows a program that calls `runFinalizersOnExit`, which is not recommended.\n\n\n```java\nvoid main() {\n\t// ...\n\t// BAD: Call to 'runFinalizersOnExit' forces execution of all finalizers on termination of \n\t// the runtime, which can cause live objects to transition to an invalid state.\n\t// Avoid using this method (and finalizers in general).\n\tSystem.runFinalizersOnExit(true);\n\t// ...\n}\n```\nThe following example shows the recommended approach: a program that calls a `dispose` method in a `finally` block.\n\n\n```java\n// Instead of using finalizers, define explicit termination methods \n// and call them in 'finally' blocks.\nclass LocalCache {\n\tprivate Collection<File> cacheFiles = ...;\n\t\n\t// Explicit method to close all cacheFiles\n\tpublic void dispose() {\n\t\tfor (File cacheFile : cacheFiles) {\n\t\t\tdisposeCacheFile(cacheFile);\n\t\t}\n\t}\n}\n\nvoid main() {\n\tLocalCache cache = new LocalCache();\n\ttry {\n\t\t// Use the cache\n\t} finally {\n\t\t// Call the termination method in a 'finally' block, to ensure that\n\t\t// the cache's resources are freed. \n\t\tcache.dispose();\n\t}\n}\n```\n\n## References\n* J. Bloch, *Effective Java (second edition)*, Item 7. Addison-Wesley, 2008.\n* Java API Specification: [System.runFinalizersOnExit()](https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#runFinalizersOnExit-boolean-), [Object.finalize()](https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#finalize--).\n* Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/javase/10/docs/api/java/lang/doc-files/threadPrimitiveDeprecation.html).\n"},"properties":{"tags":["reliability","maintainability"],"description":"Calling 'System.runFinalizersOnExit' or 'Runtime.runFinalizersOnExit'\n              may cause finalizers to be run on live objects, leading to erratic behavior or\n              deadlock.","id":"java/run-finalizers-on-exit","kind":"problem","name":"Dangerous runFinalizersOnExit","precision":"medium","problem.severity":"error"}},{"id":"java/field-masks-super-field","name":"java/field-masks-super-field","shortDescription":{"text":"Field masks field in super class"},"fullDescription":{"text":"Hiding a field in a superclass by redeclaring it in a subclass might be unintentional, especially if references to the hidden field are not qualified using 'super'."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Field masks field in super class\nA field that has the same name as a field in a superclass *hides* the field in the superclass. Such hiding might be unintentional, especially if there are no references to the hidden field using the `super` qualifier. In any case, it makes code more difficult to read.\n\n\n## Recommendation\nEnsure that any hiding is intentional. For clarity, it may be better to rename the field in the subclass.\n\n\n## Example\nIn the following example, the programmer unintentionally added an `age` field to `Employee`, which hides the `age` field in `Person`. The constructor in `Person` sets the `age ` field in `Person` to 20 but the `age` field in `Employee` is still 0. This means that the program outputs 0, which is probably not what was intended.\n\n\n```java\npublic class FieldMasksSuperField {\n    static class Person {\n        protected int age;\n        public Person(int age)\n        {\n            this.age = age;\n        }\n    }\n\n    static class Employee extends Person {\n        protected int age;  // This field hides 'Person.age'.\n        protected int numberOfYearsEmployed;\n        public Employee(int age, int numberOfYearsEmployed)\n        {\n            super(age);\n            this.numberOfYearsEmployed = numberOfYearsEmployed;\n        }\n    }\n\n    public static void main(String[] args) {\n        Employee e = new Employee(20, 2);\n        System.out.println(e.age);\n    }\n}\n```\nTo fix this, delete the declaration of `age` on line 11.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Hiding Fields](https://docs.oracle.com/javase/tutorial/java/IandI/hidevariables.html).\n","markdown":"# Field masks field in super class\nA field that has the same name as a field in a superclass *hides* the field in the superclass. Such hiding might be unintentional, especially if there are no references to the hidden field using the `super` qualifier. In any case, it makes code more difficult to read.\n\n\n## Recommendation\nEnsure that any hiding is intentional. For clarity, it may be better to rename the field in the subclass.\n\n\n## Example\nIn the following example, the programmer unintentionally added an `age` field to `Employee`, which hides the `age` field in `Person`. The constructor in `Person` sets the `age ` field in `Person` to 20 but the `age` field in `Employee` is still 0. This means that the program outputs 0, which is probably not what was intended.\n\n\n```java\npublic class FieldMasksSuperField {\n    static class Person {\n        protected int age;\n        public Person(int age)\n        {\n            this.age = age;\n        }\n    }\n\n    static class Employee extends Person {\n        protected int age;  // This field hides 'Person.age'.\n        protected int numberOfYearsEmployed;\n        public Employee(int age, int numberOfYearsEmployed)\n        {\n            super(age);\n            this.numberOfYearsEmployed = numberOfYearsEmployed;\n        }\n    }\n\n    public static void main(String[] args) {\n        Employee e = new Employee(20, 2);\n        System.out.println(e.age);\n    }\n}\n```\nTo fix this, delete the declaration of `age` on line 11.\n\n\n## References\n* Help - Eclipse Platform: [Java Compiler Errors/Warnings Preferences](https://help.eclipse.org/2020-12/advanced/content.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm).\n* The Java Tutorials: [Hiding Fields](https://docs.oracle.com/javase/tutorial/java/IandI/hidevariables.html).\n"},"properties":{"tags":["maintainability","readability"],"description":"Hiding a field in a superclass by redeclaring it in a subclass might be\n              unintentional, especially if references to the hidden field are not qualified using\n              'super'.","id":"java/field-masks-super-field","kind":"problem","name":"Field masks field in super class","precision":"medium","problem.severity":"warning"}},{"id":"java/empty-zip-file-entry","name":"java/empty-zip-file-entry","shortDescription":{"text":"Creates empty ZIP file entry"},"fullDescription":{"text":"Omitting a call to 'ZipOutputStream.write' when writing a ZIP file to an output stream means that an empty ZIP file entry is written."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Creates empty ZIP file entry\nThe `ZipOutputStream` class is used to write ZIP files to a file or other stream. A ZIP file consists of a number of *entries*. Usually each entry corresponds to a file in the directory structure being zipped. There is a method on `ZipOutputStream` that is slightly confusingly named `putNextEntry`. Despite its name, it does not write a whole entry. Instead, it writes the *metadata* for an entry. The content for that entry is then written using the `write` method. Finally the entry is closed using `closeEntry`.\n\nTherefore, if you call `putNextEntry` and `closeEntry` but omit the call to `write`, an empty ZIP file entry is written to the output stream.\n\n\n## Recommendation\nEnsure that you include a call to `ZipOutputStream.write`.\n\n\n## Example\nIn the following example, the `archive` method calls `putNextEntry` and `closeEntry` but the call to `write` is left out.\n\n\n```java\nclass Archive implements Closeable\n{\n\tprivate ZipOutputStream zipStream;\n\n\tpublic Archive(File zip) throws IOException {\n\t\tOutputStream stream = new FileOutputStream(zip);\n\t\tstream = new BufferedOutputStream(stream);\n\t\tzipStream = new ZipOutputStream(stream);\n\t}\n\n\tpublic void archive(String name, byte[] content) throws IOException {\n\t\tZipEntry entry = new ZipEntry(name);\n\t\tzipStream.putNextEntry(entry);\n\t\t// Missing call to 'write'\n\t\tzipStream.closeEntry();\n\t}\n\n\tpublic void close() throws IOException {\n\t\tzipStream.close();\n\t}\n}\n```\n\n## References\n* Java API Specification: [ ZipOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/zip/ZipOutputStream.html).\n","markdown":"# Creates empty ZIP file entry\nThe `ZipOutputStream` class is used to write ZIP files to a file or other stream. A ZIP file consists of a number of *entries*. Usually each entry corresponds to a file in the directory structure being zipped. There is a method on `ZipOutputStream` that is slightly confusingly named `putNextEntry`. Despite its name, it does not write a whole entry. Instead, it writes the *metadata* for an entry. The content for that entry is then written using the `write` method. Finally the entry is closed using `closeEntry`.\n\nTherefore, if you call `putNextEntry` and `closeEntry` but omit the call to `write`, an empty ZIP file entry is written to the output stream.\n\n\n## Recommendation\nEnsure that you include a call to `ZipOutputStream.write`.\n\n\n## Example\nIn the following example, the `archive` method calls `putNextEntry` and `closeEntry` but the call to `write` is left out.\n\n\n```java\nclass Archive implements Closeable\n{\n\tprivate ZipOutputStream zipStream;\n\n\tpublic Archive(File zip) throws IOException {\n\t\tOutputStream stream = new FileOutputStream(zip);\n\t\tstream = new BufferedOutputStream(stream);\n\t\tzipStream = new ZipOutputStream(stream);\n\t}\n\n\tpublic void archive(String name, byte[] content) throws IOException {\n\t\tZipEntry entry = new ZipEntry(name);\n\t\tzipStream.putNextEntry(entry);\n\t\t// Missing call to 'write'\n\t\tzipStream.closeEntry();\n\t}\n\n\tpublic void close() throws IOException {\n\t\tzipStream.close();\n\t}\n}\n```\n\n## References\n* Java API Specification: [ ZipOutputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/zip/ZipOutputStream.html).\n"},"properties":{"tags":["reliability","readability"],"description":"Omitting a call to 'ZipOutputStream.write' when writing a ZIP file to an output\n              stream means that an empty ZIP file entry is written.","id":"java/empty-zip-file-entry","kind":"problem","name":"Creates empty ZIP file entry","precision":"medium","problem.severity":"warning"}},{"id":"java/improper-validation-of-array-index","name":"java/improper-validation-of-array-index","shortDescription":{"text":"Improper validation of user-provided array index"},"fullDescription":{"text":"Using external input as an index to an array, without proper validation, can lead to index out of bound exceptions."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Improper validation of user-provided array index\nUsing unvalidated input as part of an index into the array can cause the array access to throw an `ArrayIndexOutOfBoundsException`. This is because there is no guarantee that the index provided is within the bounds of the array.\n\nThis problem occurs when user input is used as an array index, either directly or following one or more calculations. If the user input is unsanitized, it may be any value, which could result in either a negative index, or an index which is larger than the size of the array, either of which would result in an `ArrayIndexOutOfBoundsException`.\n\n\n## Recommendation\nThe index used in the array access should be checked against the bounds of the array before being used. The index should be smaller than the array size, and it should not be negative.\n\n\n## Example\nThe following program accesses an element from a fixed size constant array:\n\n\n```java\npublic class ImproperValidationOfArrayIndex extends HttpServlet {\n\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n  throws ServletException, IOException {\n    String[] productDescriptions = new String[] { \"Chocolate bar\", \"Fizzy drink\" };\n\n    // User provided value\n    String productID = request.getParameter(\"productID\");\n    try {\n        int productID = Integer.parseInt(userProperty.trim());\n\n        /*\n         * BAD Array is accessed without checking if the user provided value is out of\n         * bounds.\n         */\n        String productDescription = productDescriptions[productID];\n\n        if (productID >= 0 && productID < productDescriptions.length) {\n          // GOOD We have checked that the array index is valid first\n          productDescription = productDescriptions[productID];\n        } else {\n          productDescription = \"No product for that ID\";\n        }\n\n        response.getWriter().write(productDescription);\n\n    } catch (NumberFormatException e) { }\n  }\n}\n```\nThe first access of the `productDescriptions` array uses the user-provided value as the index without performing any checks. If the user provides a negative value, or a value larger than the size of the array, then an `ArrayIndexOutOfBoundsException` may be thrown.\n\nThe second access of the `productDescriptions` array is contained within a conditional expression that verifies the user-provided value is a valid index into the array. This ensures that the access operation never throws an `ArrayIndexOutOfBoundsException`.\n\n\n## References\n* Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).\n* Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).\n","markdown":"# Improper validation of user-provided array index\nUsing unvalidated input as part of an index into the array can cause the array access to throw an `ArrayIndexOutOfBoundsException`. This is because there is no guarantee that the index provided is within the bounds of the array.\n\nThis problem occurs when user input is used as an array index, either directly or following one or more calculations. If the user input is unsanitized, it may be any value, which could result in either a negative index, or an index which is larger than the size of the array, either of which would result in an `ArrayIndexOutOfBoundsException`.\n\n\n## Recommendation\nThe index used in the array access should be checked against the bounds of the array before being used. The index should be smaller than the array size, and it should not be negative.\n\n\n## Example\nThe following program accesses an element from a fixed size constant array:\n\n\n```java\npublic class ImproperValidationOfArrayIndex extends HttpServlet {\n\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n  throws ServletException, IOException {\n    String[] productDescriptions = new String[] { \"Chocolate bar\", \"Fizzy drink\" };\n\n    // User provided value\n    String productID = request.getParameter(\"productID\");\n    try {\n        int productID = Integer.parseInt(userProperty.trim());\n\n        /*\n         * BAD Array is accessed without checking if the user provided value is out of\n         * bounds.\n         */\n        String productDescription = productDescriptions[productID];\n\n        if (productID >= 0 && productID < productDescriptions.length) {\n          // GOOD We have checked that the array index is valid first\n          productDescription = productDescriptions[productID];\n        } else {\n          productDescription = \"No product for that ID\";\n        }\n\n        response.getWriter().write(productDescription);\n\n    } catch (NumberFormatException e) { }\n  }\n}\n```\nThe first access of the `productDescriptions` array uses the user-provided value as the index without performing any checks. If the user provides a negative value, or a value larger than the size of the array, then an `ArrayIndexOutOfBoundsException` may be thrown.\n\nThe second access of the `productDescriptions` array is contained within a conditional expression that verifies the user-provided value is a valid index into the array. This ensures that the access operation never throws an `ArrayIndexOutOfBoundsException`.\n\n\n## References\n* Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).\n* Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).\n"},"properties":{"tags":["security","external/cwe/cwe-129"],"description":"Using external input as an index to an array, without proper validation, can lead to index out of bound exceptions.","id":"java/improper-validation-of-array-index","kind":"path-problem","name":"Improper validation of user-provided array index","precision":"medium","problem.severity":"warning","security-severity":"8.8"}},{"id":"java/improper-validation-of-array-construction","name":"java/improper-validation-of-array-construction","shortDescription":{"text":"Improper validation of user-provided size used for array construction"},"fullDescription":{"text":"Using unvalidated external input as the argument to a construction of an array can lead to index out of bound exceptions."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Improper validation of user-provided size used for array construction\nUsing unvalidated input when specifying the size of a newly created array can result in the creation of an array with size zero. If this array is subsequently accessed without further checks, an `ArrayIndexOutOfBoundsException` may be thrown, because there is no guarantee that the array is not empty.\n\nThis problem occurs when user input is used as the size during array initialization, either directly or following one or more calculations. If the user input is unvalidated, it may cause the size of the array to be zero.\n\n\n## Recommendation\nThe size used in the array initialization should be verified to be greater than zero before being used. Alternatively, the array access may be protected by a conditional check that ensures it is only accessed if the index is less than the array size.\n\n\n## Example\nThe following program constructs an array with the size specified by some user input:\n\n\n```java\npublic class ImproperValidationOfArrayIndex extends HttpServlet {\n\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n  throws ServletException, IOException {\n    try {\n      // User provided value\n      int numberOfItems = Integer.parseInt(request.getParameter(\"numberOfItems\").trim());\n\n      if (numberOfItems >= 0) {\n        /*\n         * BAD numberOfItems may be zero, which would cause the array indexing operation to\n         * throw an ArrayIndexOutOfBoundsException\n         */\n        String items = new String[numberOfItems];\n        items[0] = \"Item 1\";\n      }\n\n      if (numberOfItems > 0) {\n        /*\n         * GOOD numberOfItems must be greater than zero, so the indexing succeeds.\n         */\n        String items = new String[numberOfItems];\n        items[0] = \"Item 1\";\n      }\n\n    } catch (NumberFormatException e) { }\n  }\n}\n```\nThe first array construction is protected by a condition that checks if the user input is zero or more. However, if the user provides `0` as the `numberOfItems` parameter, then an empty array is created, and any array access would fail with an `ArrayIndexOutOfBoundsException`.\n\nThe second array construction is protected by a condition that checks if the user input is greater than zero. The array will therefore never be empty, and the following array access will not throw an `ArrayIndexOutOfBoundsException`.\n\n\n## References\n* Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).\n* Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).\n","markdown":"# Improper validation of user-provided size used for array construction\nUsing unvalidated input when specifying the size of a newly created array can result in the creation of an array with size zero. If this array is subsequently accessed without further checks, an `ArrayIndexOutOfBoundsException` may be thrown, because there is no guarantee that the array is not empty.\n\nThis problem occurs when user input is used as the size during array initialization, either directly or following one or more calculations. If the user input is unvalidated, it may cause the size of the array to be zero.\n\n\n## Recommendation\nThe size used in the array initialization should be verified to be greater than zero before being used. Alternatively, the array access may be protected by a conditional check that ensures it is only accessed if the index is less than the array size.\n\n\n## Example\nThe following program constructs an array with the size specified by some user input:\n\n\n```java\npublic class ImproperValidationOfArrayIndex extends HttpServlet {\n\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n  throws ServletException, IOException {\n    try {\n      // User provided value\n      int numberOfItems = Integer.parseInt(request.getParameter(\"numberOfItems\").trim());\n\n      if (numberOfItems >= 0) {\n        /*\n         * BAD numberOfItems may be zero, which would cause the array indexing operation to\n         * throw an ArrayIndexOutOfBoundsException\n         */\n        String items = new String[numberOfItems];\n        items[0] = \"Item 1\";\n      }\n\n      if (numberOfItems > 0) {\n        /*\n         * GOOD numberOfItems must be greater than zero, so the indexing succeeds.\n         */\n        String items = new String[numberOfItems];\n        items[0] = \"Item 1\";\n      }\n\n    } catch (NumberFormatException e) { }\n  }\n}\n```\nThe first array construction is protected by a condition that checks if the user input is zero or more. However, if the user provides `0` as the `numberOfItems` parameter, then an empty array is created, and any array access would fail with an `ArrayIndexOutOfBoundsException`.\n\nThe second array construction is protected by a condition that checks if the user input is greater than zero. The array will therefore never be empty, and the following array access will not throw an `ArrayIndexOutOfBoundsException`.\n\n\n## References\n* Java API Specification: [ArrayIndexOutOfBoundsException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html).\n* Common Weakness Enumeration: [CWE-129](https://cwe.mitre.org/data/definitions/129.html).\n"},"properties":{"tags":["security","external/cwe/cwe-129"],"description":"Using unvalidated external input as the argument to a construction of an array can lead to index out of bound exceptions.","id":"java/improper-validation-of-array-construction","kind":"path-problem","name":"Improper validation of user-provided size used for array construction","precision":"medium","problem.severity":"warning","security-severity":"8.8"}},{"id":"java/socket-auth-race-condition","name":"java/socket-auth-race-condition","shortDescription":{"text":"Race condition in socket authentication"},"fullDescription":{"text":"Opening a socket after authenticating via a different channel may allow an attacker to connect to the port first."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Race condition in socket authentication\nA common pattern is to have a channel of communication open with a user, and then to open another channel, for example to transfer data. However, if user authentication is done over the original channel rather than the alternate channel, then an attacker may be able to connect to the alternate channel before the legitimate user does. This allows the attacker to impersonate the user by \"piggybacking\" on any previous authentication.\n\n\n## Recommendation\nWhen opening an alternate channel for an authenticated user (for example, a Java `Socket`), always authenticate the user over the new channel.\n\n\n## Example\nThis example shows two ways of opening a connection for a user. In the first example, authentication is determined based on materials that the user has already provided (for example, their username and/or password), and then a new channel is opened. However, no authentication is done over the new channel, and so an attacker could connect to it before the user connects.\n\nIn the second example, authentication is done over the socket channel itself, which verifies that the newly connected user is in fact the user that was expected.\n\n\n```java\npublic void doConnect(int desiredPort, String username) {\n\tServerSocket listenSocket = new ServerSocket(desiredPort);\n\n\tif (isAuthenticated(username)) {\n\t\tSocket connection1 = listenSocket.accept();\n\t\t// BAD: no authentication over the socket connection\n\t\tconnection1.getOutputStream().write(secretData);\n\t}\n}\n\npublic void doConnect(int desiredPort, String username) {\n\tServerSocket listenSocket = new ServerSocket(desiredPort);\n\n\tSocket connection2 = listenSocket.accept();\n\t// GOOD: authentication happens over the socket\n\tif (doAuthenticate(connection2, username)) {\n\t\tconnection2.getOutputStream().write(secretData);\n\t}\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-421](https://cwe.mitre.org/data/definitions/421.html).\n","markdown":"# Race condition in socket authentication\nA common pattern is to have a channel of communication open with a user, and then to open another channel, for example to transfer data. However, if user authentication is done over the original channel rather than the alternate channel, then an attacker may be able to connect to the alternate channel before the legitimate user does. This allows the attacker to impersonate the user by \"piggybacking\" on any previous authentication.\n\n\n## Recommendation\nWhen opening an alternate channel for an authenticated user (for example, a Java `Socket`), always authenticate the user over the new channel.\n\n\n## Example\nThis example shows two ways of opening a connection for a user. In the first example, authentication is determined based on materials that the user has already provided (for example, their username and/or password), and then a new channel is opened. However, no authentication is done over the new channel, and so an attacker could connect to it before the user connects.\n\nIn the second example, authentication is done over the socket channel itself, which verifies that the newly connected user is in fact the user that was expected.\n\n\n```java\npublic void doConnect(int desiredPort, String username) {\n\tServerSocket listenSocket = new ServerSocket(desiredPort);\n\n\tif (isAuthenticated(username)) {\n\t\tSocket connection1 = listenSocket.accept();\n\t\t// BAD: no authentication over the socket connection\n\t\tconnection1.getOutputStream().write(secretData);\n\t}\n}\n\npublic void doConnect(int desiredPort, String username) {\n\tServerSocket listenSocket = new ServerSocket(desiredPort);\n\n\tSocket connection2 = listenSocket.accept();\n\t// GOOD: authentication happens over the socket\n\tif (doAuthenticate(connection2, username)) {\n\t\tconnection2.getOutputStream().write(secretData);\n\t}\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-421](https://cwe.mitre.org/data/definitions/421.html).\n"},"properties":{"tags":["security","external/cwe/cwe-421"],"description":"Opening a socket after authenticating via a different channel may allow an attacker to connect to the port first.","id":"java/socket-auth-race-condition","kind":"problem","name":"Race condition in socket authentication","precision":"medium","problem.severity":"warning","security-severity":"7.2"}},{"id":"java/uncontrolled-arithmetic","name":"java/uncontrolled-arithmetic","shortDescription":{"text":"Uncontrolled data in arithmetic expression"},"fullDescription":{"text":"Arithmetic operations on uncontrolled data that is not validated can cause overflows."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Uncontrolled data in arithmetic expression\nPerforming calculations on uncontrolled data can result in integer overflows unless the input is validated.\n\nIf the data is not under your control, and can take extremely large values, even arithmetic operations that would usually result in a small change in magnitude may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on uncontrolled data by doing one of the following:\n\n* Validate the data.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `MAX_VALUE`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a random integer is generated. Because the value is not controlled by the programmer, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing a multiplication.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t{\n\t\t\tint data = (new java.security.SecureRandom()).nextInt();\n\n\t\t\t// BAD: may overflow if data is large\n\t\t\tint scaled = data * 10;\n\n\t\t\t// ...\n\n\t\t\t// GOOD: use a guard to ensure no overflows occur\n\t\t\tint scaled2;\n\t\t\tif (data < Integer.MAX_VALUE/10)\n\t\t\t\tscaled2 = data * 10;\n\t\t\telse \n\t\t\t\tscaled2 = Integer.MAX_VALUE;\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n","markdown":"# Uncontrolled data in arithmetic expression\nPerforming calculations on uncontrolled data can result in integer overflows unless the input is validated.\n\nIf the data is not under your control, and can take extremely large values, even arithmetic operations that would usually result in a small change in magnitude may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on uncontrolled data by doing one of the following:\n\n* Validate the data.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `MAX_VALUE`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a random integer is generated. Because the value is not controlled by the programmer, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing a multiplication.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t{\n\t\t\tint data = (new java.security.SecureRandom()).nextInt();\n\n\t\t\t// BAD: may overflow if data is large\n\t\t\tint scaled = data * 10;\n\n\t\t\t// ...\n\n\t\t\t// GOOD: use a guard to ensure no overflows occur\n\t\t\tint scaled2;\n\t\t\tif (data < Integer.MAX_VALUE/10)\n\t\t\t\tscaled2 = data * 10;\n\t\t\telse \n\t\t\t\tscaled2 = Integer.MAX_VALUE;\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"},"properties":{"tags":["security","external/cwe/cwe-190","external/cwe/cwe-191"],"description":"Arithmetic operations on uncontrolled data that is not validated can cause\n              overflows.","id":"java/uncontrolled-arithmetic","kind":"path-problem","name":"Uncontrolled data in arithmetic expression","precision":"medium","problem.severity":"warning","security-severity":"8.6"}},{"id":"java/tainted-arithmetic","name":"java/tainted-arithmetic","shortDescription":{"text":"User-controlled data in arithmetic expression"},"fullDescription":{"text":"Arithmetic operations on user-controlled data that is not validated can cause overflows."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# User-controlled data in arithmetic expression\nPerforming calculations on user-controlled data can result in integer overflows unless the input is validated.\n\nIf the user is free to enter very large numbers, even arithmetic operations that would usually result in a small change in magnitude may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on user-controlled data by doing one of the following:\n\n* Validate the user input.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `MAX_VALUE`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a value is read from standard input into an `int`. Because the value is a user-controlled value, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing a multiplication.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t{\n\t\t\tint data;\n\n\t\t\tBufferedReader readerBuffered = new BufferedReader(\n\t\t\t\t\tnew InputStreamReader(System.in, \"UTF-8\"));\n\t\t\tString stringNumber = readerBuffered.readLine();\n\t\t\tif (stringNumber != null) {\n\t\t\t\tdata = Integer.parseInt(stringNumber.trim());\n\t\t\t} else {\n\t\t\t\tdata = 0;\n\t\t\t}\n\n\t\t\t// BAD: may overflow if input data is very large, for example\n\t\t\t// 'Integer.MAX_VALUE'\n\t\t\tint scaled = data * 10;\n\n\t\t\t//...\n\t\t\t\n\t\t\t// GOOD: use a guard to ensure no overflows occur\n\t\t\tint scaled2;\n\t\t\tif (data < Integer.MAX_VALUE / 10)\n\t\t\t\tscaled2 = data * 10;\n\t\t\telse\n\t\t\t\tscaled2 = Integer.MAX_VALUE;\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n","markdown":"# User-controlled data in arithmetic expression\nPerforming calculations on user-controlled data can result in integer overflows unless the input is validated.\n\nIf the user is free to enter very large numbers, even arithmetic operations that would usually result in a small change in magnitude may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on user-controlled data by doing one of the following:\n\n* Validate the user input.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `MAX_VALUE`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a value is read from standard input into an `int`. Because the value is a user-controlled value, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing a multiplication.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t{\n\t\t\tint data;\n\n\t\t\tBufferedReader readerBuffered = new BufferedReader(\n\t\t\t\t\tnew InputStreamReader(System.in, \"UTF-8\"));\n\t\t\tString stringNumber = readerBuffered.readLine();\n\t\t\tif (stringNumber != null) {\n\t\t\t\tdata = Integer.parseInt(stringNumber.trim());\n\t\t\t} else {\n\t\t\t\tdata = 0;\n\t\t\t}\n\n\t\t\t// BAD: may overflow if input data is very large, for example\n\t\t\t// 'Integer.MAX_VALUE'\n\t\t\tint scaled = data * 10;\n\n\t\t\t//...\n\t\t\t\n\t\t\t// GOOD: use a guard to ensure no overflows occur\n\t\t\tint scaled2;\n\t\t\tif (data < Integer.MAX_VALUE / 10)\n\t\t\t\tscaled2 = data * 10;\n\t\t\telse\n\t\t\t\tscaled2 = Integer.MAX_VALUE;\n\t\t}\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"},"properties":{"tags":["security","external/cwe/cwe-190","external/cwe/cwe-191"],"description":"Arithmetic operations on user-controlled data that is not validated can cause\n              overflows.","id":"java/tainted-arithmetic","kind":"path-problem","name":"User-controlled data in arithmetic expression","precision":"medium","problem.severity":"warning","security-severity":"8.6"}},{"id":"java/comparison-with-wider-type","name":"java/comparison-with-wider-type","shortDescription":{"text":"Comparison of narrow type with wide type in loop condition"},"fullDescription":{"text":"Comparisons between types of different widths in a loop condition can cause the loop to behave unexpectedly."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Comparison of narrow type with wide type in loop condition\nIn a loop condition, comparison of a value of a narrow type with a value of a wide type may always evaluate to `true` if the wider value is sufficiently large (or small). This is because the narrower value may overflow. This can lead to an infinite loop.\n\n\n## Recommendation\nChange the types of the compared values so that the value on the narrower side of the comparison is at least as wide as the value it is being compared with.\n\n\n## Example\nIn this example, `bytesReceived` is compared against `MAXGET` in a `while` loop. However, `bytesReceived` is a `short`, and `MAXGET` is a `long`. Because `MAXGET` is larger than `Short.MAX_VALUE`, the loop condition is always `true`, so the loop never terminates.\n\nThis problem is avoided in the 'GOOD' case because `bytesReceived2` is a `long`, which is as wide as the type of `MAXGET`.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t\n\t\t{\t\t\n\t\t\tint BIGNUM = Integer.MAX_VALUE;\n\t\t\tlong MAXGET = Short.MAX_VALUE + 1;\n\t\t\t\n\t\t\tchar[] buf = new char[BIGNUM];\n\n\t\t\tshort bytesReceived = 0;\n\t\t\t\n\t\t\t// BAD: 'bytesReceived' is compared with a value of wider type.\n\t\t\t// 'bytesReceived' overflows before reaching MAXGET,\n\t\t\t// causing an infinite loop.\n\t\t\twhile (bytesReceived < MAXGET) {\n\t\t\t\tbytesReceived += getFromInput(buf, bytesReceived);\n\t\t\t}\n\t\t}\n\t\t\n\t\t{\n\t\t\tlong bytesReceived2 = 0;\n\t\t\t\n\t\t\t// GOOD: 'bytesReceived2' has a type at least as wide as MAXGET.\n\t\t\twhile (bytesReceived2 < MAXGET) {\n\t\t\t\tbytesReceived2 += getFromInput(buf, bytesReceived2);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static int getFromInput(char[] buf, short pos) {\n\t\t// write to buf\n\t\t// ...\n\t\treturn 1;\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n","markdown":"# Comparison of narrow type with wide type in loop condition\nIn a loop condition, comparison of a value of a narrow type with a value of a wide type may always evaluate to `true` if the wider value is sufficiently large (or small). This is because the narrower value may overflow. This can lead to an infinite loop.\n\n\n## Recommendation\nChange the types of the compared values so that the value on the narrower side of the comparison is at least as wide as the value it is being compared with.\n\n\n## Example\nIn this example, `bytesReceived` is compared against `MAXGET` in a `while` loop. However, `bytesReceived` is a `short`, and `MAXGET` is a `long`. Because `MAXGET` is larger than `Short.MAX_VALUE`, the loop condition is always `true`, so the loop never terminates.\n\nThis problem is avoided in the 'GOOD' case because `bytesReceived2` is a `long`, which is as wide as the type of `MAXGET`.\n\n\n```java\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t\n\t\t{\t\t\n\t\t\tint BIGNUM = Integer.MAX_VALUE;\n\t\t\tlong MAXGET = Short.MAX_VALUE + 1;\n\t\t\t\n\t\t\tchar[] buf = new char[BIGNUM];\n\n\t\t\tshort bytesReceived = 0;\n\t\t\t\n\t\t\t// BAD: 'bytesReceived' is compared with a value of wider type.\n\t\t\t// 'bytesReceived' overflows before reaching MAXGET,\n\t\t\t// causing an infinite loop.\n\t\t\twhile (bytesReceived < MAXGET) {\n\t\t\t\tbytesReceived += getFromInput(buf, bytesReceived);\n\t\t\t}\n\t\t}\n\t\t\n\t\t{\n\t\t\tlong bytesReceived2 = 0;\n\t\t\t\n\t\t\t// GOOD: 'bytesReceived2' has a type at least as wide as MAXGET.\n\t\t\twhile (bytesReceived2 < MAXGET) {\n\t\t\t\tbytesReceived2 += getFromInput(buf, bytesReceived2);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static int getFromInput(char[] buf, short pos) {\n\t\t// write to buf\n\t\t// ...\n\t\treturn 1;\n\t}\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [NUM00-J. Detect or prevent integer overflow](https://wiki.sei.cmu.edu/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-190","external/cwe/cwe-197"],"description":"Comparisons between types of different widths in a loop condition can cause the loop\n              to behave unexpectedly.","id":"java/comparison-with-wider-type","kind":"problem","name":"Comparison of narrow type with wide type in loop condition","precision":"medium","problem.severity":"warning","security-severity":"8.1"}},{"id":"java/android/insecure-local-key-gen","name":"java/android/insecure-local-key-gen","shortDescription":{"text":"Insecurely generated keys for local authentication"},"fullDescription":{"text":"Generation of keys with insecure parameters for local biometric authentication can allow attackers with physical access to bypass authentication checks."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Insecurely generated keys for local authentication\nBiometric authentication, such as fingerprint recognition, can be used alongside cryptographic keys stored in the Android `KeyStore` to protect sensitive parts of the application. However, when a key generated for this purpose has certain parameters set insecurely, an attacker with physical access can bypass the authentication check using application hooking tools such as Frida.\n\n\n## Recommendation\nWhen generating a key for use with biometric authentication, ensure that the following parameters of `KeyGenParameterSpec.Builder` are set:\n\n* `setUserAuthenticationRequired` should be set to `true`; otherwise, the key can be used without user authentication.\n* `setInvalidatedByBiometricEnrollment` should be set to `true` (the default); otherwise, an attacker can use the key by enrolling additional biometrics on the device.\n* `setUserAuthenticationValidityDurationSeconds`, if used, should be set to `-1`; otherwise, non-biometric (less secure) credentials can be used to access the key. We recommend using `setUserAuthenticationParameters` instead to explicitly set both the timeout and the types of credentials that may be used.\n\n## Example\nThe following example demonstrates a key that is configured with secure paramaters:\n\n\n```java\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        // GOOD: Secure parameters are used to generate a key for biometric authentication.\n        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n        .setUserAuthenticationParameters(0, KeyProperties.AUTH_BIOMETRIC_STRONG)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n```\nIn each of the following cases, a parameter is set insecurely:\n\n\n```java\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        // BAD: User authentication is not required to use this key.\n        .setUserAuthenticationRequired(false)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        .setUserAuthenticationRequired(true)\n        // BAD: An attacker can access this key by enrolling additional biometrics.\n        .setInvalidatedByBiometricEnrollment(false)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n        // BAD: This key can be accessed using non-biometric credentials. \n        .setUserAuthenticationValidityDurationSeconds(30)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n```\n\n## References\n* WithSecure: [How Secure is your Android Keystore Authentication?](https://labs.withsecure.com/publications/how-secure-is-your-android-keystore-authentication).\n* Android Developers: [KeyGenParameterSpec.Builder](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder).\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n","markdown":"# Insecurely generated keys for local authentication\nBiometric authentication, such as fingerprint recognition, can be used alongside cryptographic keys stored in the Android `KeyStore` to protect sensitive parts of the application. However, when a key generated for this purpose has certain parameters set insecurely, an attacker with physical access can bypass the authentication check using application hooking tools such as Frida.\n\n\n## Recommendation\nWhen generating a key for use with biometric authentication, ensure that the following parameters of `KeyGenParameterSpec.Builder` are set:\n\n* `setUserAuthenticationRequired` should be set to `true`; otherwise, the key can be used without user authentication.\n* `setInvalidatedByBiometricEnrollment` should be set to `true` (the default); otherwise, an attacker can use the key by enrolling additional biometrics on the device.\n* `setUserAuthenticationValidityDurationSeconds`, if used, should be set to `-1`; otherwise, non-biometric (less secure) credentials can be used to access the key. We recommend using `setUserAuthenticationParameters` instead to explicitly set both the timeout and the types of credentials that may be used.\n\n## Example\nThe following example demonstrates a key that is configured with secure paramaters:\n\n\n```java\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        // GOOD: Secure parameters are used to generate a key for biometric authentication.\n        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n        .setUserAuthenticationParameters(0, KeyProperties.AUTH_BIOMETRIC_STRONG)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n```\nIn each of the following cases, a parameter is set insecurely:\n\n\n```java\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        // BAD: User authentication is not required to use this key.\n        .setUserAuthenticationRequired(false)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        .setUserAuthenticationRequired(true)\n        // BAD: An attacker can access this key by enrolling additional biometrics.\n        .setInvalidatedByBiometricEnrollment(false)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n\nprivate void generateSecretKey() {\n    KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder(\n        \"MySecretKey\",\n        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n        .setUserAuthenticationRequired(true)\n        .setInvalidatedByBiometricEnrollment(true)\n        // BAD: This key can be accessed using non-biometric credentials. \n        .setUserAuthenticationValidityDurationSeconds(30)\n        .build();\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\n            KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n    keyGenerator.init(keyGenParameterSpec);\n    keyGenerator.generateKey();\n}\n```\n\n## References\n* WithSecure: [How Secure is your Android Keystore Authentication?](https://labs.withsecure.com/publications/how-secure-is-your-android-keystore-authentication).\n* Android Developers: [KeyGenParameterSpec.Builder](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder).\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n"},"properties":{"tags":["security","external/cwe/cwe-287"],"description":"Generation of keys with insecure parameters for local biometric authentication can allow attackers with physical access to bypass authentication checks.","id":"java/android/insecure-local-key-gen","kind":"problem","name":"Insecurely generated keys for local authentication","precision":"medium","problem.severity":"warning","security-severity":"4.4"}},{"id":"java/android/incomplete-provider-permissions","name":"java/android/incomplete-provider-permissions","shortDescription":{"text":"Missing read or write permission in a content provider"},"fullDescription":{"text":"Android content providers which do not configure both read and write permissions can allow permission bypass."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Missing read or write permission in a content provider\nThe Android manifest file specifies the content providers for the application using `provider` elements. The `provider` element specifies the explicit permissions an application requires in order to access a resource using that provider. You specify the permissions using the `android:readPermission`, `android:writePermission`, or `android:permission` attributes. If you do not specify the permission required to perform an operation, the application will implicitly have access to perform that operation. For example, if you specify only `android:readPermission`, the application must have explicit permission to read data, but requires no permission to write data.\n\n\n## Recommendation\nTo prevent permission bypass, you should create `provider` elements that either specify both the `android:readPermission` and `android:writePermission` attributes, or specify the `android:permission` attribute.\n\n\n## Example\nIn the following two (bad) examples, the provider is configured with only read or write permissions. This allows a malicious application to bypass the permission check by requesting access to the unrestricted operation.\n\n\n```xml\n<manifest ... >\n    <application ...>\n      <!-- BAD: only 'android:readPermission' is set -->\n      <provider\n          android:name=\".MyContentProvider\"\n          android:authorities=\"table\"\n          android:enabled=\"true\"\n          android:exported=\"true\"\n          android:readPermission=\"android.permission.MANAGE_DOCUMENTS\">\n      </provider>\n    </application>\n</manifest>\n\n```\n\n```xml\n<manifest ... >\n    <application ...>\n      <!-- BAD: only 'android:writePermission' is set -->\n      <provider\n          android:name=\".MyContentProvider\"\n          android:authorities=\"table\"\n          android:enabled=\"true\"\n          android:exported=\"true\"\n          android:writePermission=\"android.permission.MANAGE_DOCUMENTS\">\n      </provider>\n    </application>\n</manifest>\n\n```\nIn the following (good) examples, the provider is configured with full permissions, protecting it from a permissions bypass.\n\n\n```xml\n<manifest ... >\n    <application ...>\n      <!-- Good: both 'android:readPermission' and 'android:writePermission' are set -->\n      <provider\n          android:name=\".MyContentProvider\"\n          android:authorities=\"table\"\n          android:enabled=\"true\"\n          android:exported=\"true\"\n          android:writePermission=\"android.permission.MANAGE_DOCUMENTS\"\n          android:readPermission=\"android.permission.MANAGE_DOCUMENTS\">\n      </provider>\n    </application>\n</manifest>\n\n```\n\n```xml\n<manifest ... >\n    <application ...>\n      <!-- Good: 'android:permission' is set  -->\n      <provider\n          android:name=\".MyContentProvider\"\n          android:authorities=\"table\"\n          android:enabled=\"true\"\n          android:exported=\"true\"\n          android:permission=\"android.permission.MANAGE_DOCUMENTS\">\n      </provider>\n    </application>\n</manifest>\n\n```\n\n## References\n* Android Documentation: [Provider element](https://developer.android.com/guide/topics/manifest/provider-element)\n* CVE-2021-41166: [Insufficient permission control in Nextcloud Android app](https://nvd.nist.gov/vuln/detail/CVE-2021-41166)\n* GitHub Security Lab Research: [Insufficient permission control in Nextcloud Android app](https://securitylab.github.com/advisories/GHSL-2021-1007-Nextcloud_Android_app/#issue-2-permission-bypass-in-disklruimagecachefileprovider-ghsl-2021-1008)\n* Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n","markdown":"# Missing read or write permission in a content provider\nThe Android manifest file specifies the content providers for the application using `provider` elements. The `provider` element specifies the explicit permissions an application requires in order to access a resource using that provider. You specify the permissions using the `android:readPermission`, `android:writePermission`, or `android:permission` attributes. If you do not specify the permission required to perform an operation, the application will implicitly have access to perform that operation. For example, if you specify only `android:readPermission`, the application must have explicit permission to read data, but requires no permission to write data.\n\n\n## Recommendation\nTo prevent permission bypass, you should create `provider` elements that either specify both the `android:readPermission` and `android:writePermission` attributes, or specify the `android:permission` attribute.\n\n\n## Example\nIn the following two (bad) examples, the provider is configured with only read or write permissions. This allows a malicious application to bypass the permission check by requesting access to the unrestricted operation.\n\n\n```xml\n<manifest ... >\n    <application ...>\n      <!-- BAD: only 'android:readPermission' is set -->\n      <provider\n          android:name=\".MyContentProvider\"\n          android:authorities=\"table\"\n          android:enabled=\"true\"\n          android:exported=\"true\"\n          android:readPermission=\"android.permission.MANAGE_DOCUMENTS\">\n      </provider>\n    </application>\n</manifest>\n\n```\n\n```xml\n<manifest ... >\n    <application ...>\n      <!-- BAD: only 'android:writePermission' is set -->\n      <provider\n          android:name=\".MyContentProvider\"\n          android:authorities=\"table\"\n          android:enabled=\"true\"\n          android:exported=\"true\"\n          android:writePermission=\"android.permission.MANAGE_DOCUMENTS\">\n      </provider>\n    </application>\n</manifest>\n\n```\nIn the following (good) examples, the provider is configured with full permissions, protecting it from a permissions bypass.\n\n\n```xml\n<manifest ... >\n    <application ...>\n      <!-- Good: both 'android:readPermission' and 'android:writePermission' are set -->\n      <provider\n          android:name=\".MyContentProvider\"\n          android:authorities=\"table\"\n          android:enabled=\"true\"\n          android:exported=\"true\"\n          android:writePermission=\"android.permission.MANAGE_DOCUMENTS\"\n          android:readPermission=\"android.permission.MANAGE_DOCUMENTS\">\n      </provider>\n    </application>\n</manifest>\n\n```\n\n```xml\n<manifest ... >\n    <application ...>\n      <!-- Good: 'android:permission' is set  -->\n      <provider\n          android:name=\".MyContentProvider\"\n          android:authorities=\"table\"\n          android:enabled=\"true\"\n          android:exported=\"true\"\n          android:permission=\"android.permission.MANAGE_DOCUMENTS\">\n      </provider>\n    </application>\n</manifest>\n\n```\n\n## References\n* Android Documentation: [Provider element](https://developer.android.com/guide/topics/manifest/provider-element)\n* CVE-2021-41166: [Insufficient permission control in Nextcloud Android app](https://nvd.nist.gov/vuln/detail/CVE-2021-41166)\n* GitHub Security Lab Research: [Insufficient permission control in Nextcloud Android app](https://securitylab.github.com/advisories/GHSL-2021-1007-Nextcloud_Android_app/#issue-2-permission-bypass-in-disklruimagecachefileprovider-ghsl-2021-1008)\n* Common Weakness Enumeration: [CWE-926](https://cwe.mitre.org/data/definitions/926.html).\n"},"properties":{"tags":["security","external/cwe/cwe-926"],"description":"Android content providers which do not configure both read and write permissions can allow permission bypass.","id":"java/android/incomplete-provider-permissions","kind":"problem","name":"Missing read or write permission in a content provider","precision":"medium","problem.severity":"warning","security-severity":"8.2"}},{"id":"java/android/missing-certificate-pinning","name":"java/android/missing-certificate-pinning","shortDescription":{"text":"Android missing certificate pinning"},"fullDescription":{"text":"Network connections that do not use certificate pinning may allow attackers to eavesdrop on communications."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Android missing certificate pinning\nCertificate pinning is the practice of only trusting a specific set of SSL certificates, rather than those that the device trusts by default. In Android applications, it is reccomended to use certificate pinning when communicating over the network, in order to minimize the risk of machine-in-the-middle attacks from a compromised CA.\n\n\n## Recommendation\nThe easiest way to implement certificate pinning is to declare your pins in a `network-security-config` XML file. This will automatically provide certificate pinning for any network connection made by the app.\n\nAnother way to implement certificate pinning is to use the \\`CertificatePinner\\` class from the \\`okhttp\\` library.\n\nA final way to implement certificate pinning is to use a `TrustManager`, initialized from a `KeyStore` loaded with only the necessary certificates.\n\n\n## Example\nIn the first (bad) case below, a network call is performed with no certificate pinning implemented. The other (good) cases demonstrate the different ways to implement certificate pinning.\n\n\n```java\n// BAD - By default, this network call does not use certificate pinning\nURLConnection conn = new URL(\"https://example.com\").openConnection();\n```\n\n```xml\n<!-- GOOD: Certificate pinning implemented via a Network Security Config file -->\n\n<!-- In AndroidManifest.xml -->\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.app\">\n\n    <application android:networkSecurityConfig=\"@xml/NetworkSecurityConfig\">\n        ...\n    </application>\n\n</manifest>\n\n<!-- In res/xml/NetworkSecurityConfig.xml -->\n<network-security-config>\n    <domain-config>\n        <domain>good.example.com</domain>\n        <pin-set expiration=\"2038/1/19\">\n            <pin digest=\"SHA-256\">...</pin>\n        </pin-set>\n    </domain-config>\n</network-security-config>\n```\n\n```java\n// GOOD: Certificate pinning implemented via okhttp3.CertificatePinner \nCertificatePinner certificatePinner = new CertificatePinner.Builder()\n    .add(\"example.com\", \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\")\n    .build();\nOkHttpClient client = new OkHttpClient.Builder()\n    .certificatePinner(certificatePinner)\n    .build();\n\nclient.newCall(new Request.Builder().url(\"https://example.com\").build()).execute();\n\n\n\n// GOOD: Certificate pinning implemented via a TrustManager\nKeyStore keyStore = KeyStore.getInstance(\"BKS\");\nkeyStore.load(resources.openRawResource(R.raw.cert), null);\n\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\ntmf.init(keyStore);\n\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(null, tmf.getTrustManagers(), null);\n\nURL url = new URL(\"http://www.example.com/\");\nHttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection(); \n\nurlConnection.setSSLSocketFactory(sslContext.getSocketFactory());\n```\n\n## References\n* OWASP Mobile Security: [Testing Custom Certificate Stores and Certificate Pinning (MSTG-NETWORK-4)](https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05g-testing-network-communication#testing-custom-certificate-stores-and-certificate-pinning-mstg-network-4).\n* Android Developers: [Network security configuration](https://developer.android.com/training/articles/security-config).\n* OkHttp: [CertificatePinner](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n","markdown":"# Android missing certificate pinning\nCertificate pinning is the practice of only trusting a specific set of SSL certificates, rather than those that the device trusts by default. In Android applications, it is reccomended to use certificate pinning when communicating over the network, in order to minimize the risk of machine-in-the-middle attacks from a compromised CA.\n\n\n## Recommendation\nThe easiest way to implement certificate pinning is to declare your pins in a `network-security-config` XML file. This will automatically provide certificate pinning for any network connection made by the app.\n\nAnother way to implement certificate pinning is to use the \\`CertificatePinner\\` class from the \\`okhttp\\` library.\n\nA final way to implement certificate pinning is to use a `TrustManager`, initialized from a `KeyStore` loaded with only the necessary certificates.\n\n\n## Example\nIn the first (bad) case below, a network call is performed with no certificate pinning implemented. The other (good) cases demonstrate the different ways to implement certificate pinning.\n\n\n```java\n// BAD - By default, this network call does not use certificate pinning\nURLConnection conn = new URL(\"https://example.com\").openConnection();\n```\n\n```xml\n<!-- GOOD: Certificate pinning implemented via a Network Security Config file -->\n\n<!-- In AndroidManifest.xml -->\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.app\">\n\n    <application android:networkSecurityConfig=\"@xml/NetworkSecurityConfig\">\n        ...\n    </application>\n\n</manifest>\n\n<!-- In res/xml/NetworkSecurityConfig.xml -->\n<network-security-config>\n    <domain-config>\n        <domain>good.example.com</domain>\n        <pin-set expiration=\"2038/1/19\">\n            <pin digest=\"SHA-256\">...</pin>\n        </pin-set>\n    </domain-config>\n</network-security-config>\n```\n\n```java\n// GOOD: Certificate pinning implemented via okhttp3.CertificatePinner \nCertificatePinner certificatePinner = new CertificatePinner.Builder()\n    .add(\"example.com\", \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\")\n    .build();\nOkHttpClient client = new OkHttpClient.Builder()\n    .certificatePinner(certificatePinner)\n    .build();\n\nclient.newCall(new Request.Builder().url(\"https://example.com\").build()).execute();\n\n\n\n// GOOD: Certificate pinning implemented via a TrustManager\nKeyStore keyStore = KeyStore.getInstance(\"BKS\");\nkeyStore.load(resources.openRawResource(R.raw.cert), null);\n\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\ntmf.init(keyStore);\n\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(null, tmf.getTrustManagers(), null);\n\nURL url = new URL(\"http://www.example.com/\");\nHttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection(); \n\nurlConnection.setSSLSocketFactory(sslContext.getSocketFactory());\n```\n\n## References\n* OWASP Mobile Security: [Testing Custom Certificate Stores and Certificate Pinning (MSTG-NETWORK-4)](https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05g-testing-network-communication#testing-custom-certificate-stores-and-certificate-pinning-mstg-network-4).\n* Android Developers: [Network security configuration](https://developer.android.com/training/articles/security-config).\n* OkHttp: [CertificatePinner](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"},"properties":{"tags":["security","external/cwe/cwe-295"],"description":"Network connections that do not use certificate pinning may allow attackers to eavesdrop on communications.","id":"java/android/missing-certificate-pinning","kind":"problem","name":"Android missing certificate pinning","precision":"medium","problem.severity":"warning","security-severity":"5.9"}},{"id":"java/android/webview-addjavascriptinterface","name":"java/android/webview-addjavascriptinterface","shortDescription":{"text":"Access Java object methods through JavaScript exposure"},"fullDescription":{"text":"Exposing a Java object in a WebView with a JavaScript interface can lead to malicious JavaScript controlling the application."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Access Java object methods through JavaScript exposure\nCalling the `addJavascriptInterface` method of the `android.webkit.WebView` class allows the web pages of a WebView to access a Java object's methods via JavaScript.\n\nObjects exposed to JavaScript are available in all frames of the WebView.\n\n\n## Recommendation\nIf you need to expose Java objects to JavaScript, guarantee that no untrusted third-party content is loaded into the WebView.\n\n\n## Example\nIn the following (bad) example, a Java object is exposed to JavaScript.\n\n\n```java\nimport android.webkit.JavascriptInterface;\nimport android.database.sqlite.SQLiteOpenHelper;\n\nclass ExposedObject extends SQLiteOpenHelper {\n    @JavascriptInterface\n    public String studentEmail(String studentName) {\n        // SQL injection\n        String query = \"SELECT email FROM students WHERE studentname = '\" + studentName + \"'\";\n\n        Cursor cursor = db.rawQuery(query, null);\n        cursor.moveToFirst();\n        String email = cursor.getString(0);\n\n        return email;\n    }\n}\n\nwebview.getSettings().setJavaScriptEnabled(true);\nwebview.addJavaScriptInterface(new ExposedObject(), \"exposedObject\");\nwebview.loadData(\"\", \"text/html\", null);\n\nString name = \"Robert'; DROP TABLE students; --\";\nwebview.loadUrl(\"javascript:alert(exposedObject.studentEmail(\\\"\"+ name +\"\\\"))\");\n\n```\n\n## References\n* Android Documentation: [addJavascriptInterface](https://developer.android.com/reference/android/webkit/WebView#addJavascriptInterface(java.lang.Object,%20java.lang.String))\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n","markdown":"# Access Java object methods through JavaScript exposure\nCalling the `addJavascriptInterface` method of the `android.webkit.WebView` class allows the web pages of a WebView to access a Java object's methods via JavaScript.\n\nObjects exposed to JavaScript are available in all frames of the WebView.\n\n\n## Recommendation\nIf you need to expose Java objects to JavaScript, guarantee that no untrusted third-party content is loaded into the WebView.\n\n\n## Example\nIn the following (bad) example, a Java object is exposed to JavaScript.\n\n\n```java\nimport android.webkit.JavascriptInterface;\nimport android.database.sqlite.SQLiteOpenHelper;\n\nclass ExposedObject extends SQLiteOpenHelper {\n    @JavascriptInterface\n    public String studentEmail(String studentName) {\n        // SQL injection\n        String query = \"SELECT email FROM students WHERE studentname = '\" + studentName + \"'\";\n\n        Cursor cursor = db.rawQuery(query, null);\n        cursor.moveToFirst();\n        String email = cursor.getString(0);\n\n        return email;\n    }\n}\n\nwebview.getSettings().setJavaScriptEnabled(true);\nwebview.addJavaScriptInterface(new ExposedObject(), \"exposedObject\");\nwebview.loadData(\"\", \"text/html\", null);\n\nString name = \"Robert'; DROP TABLE students; --\";\nwebview.loadUrl(\"javascript:alert(exposedObject.studentEmail(\\\"\"+ name +\"\\\"))\");\n\n```\n\n## References\n* Android Documentation: [addJavascriptInterface](https://developer.android.com/reference/android/webkit/WebView#addJavascriptInterface(java.lang.Object,%20java.lang.String))\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"},"properties":{"tags":["security","external/cwe/cwe-079"],"description":"Exposing a Java object in a WebView with a JavaScript interface can lead to malicious JavaScript controlling the application.","id":"java/android/webview-addjavascriptinterface","kind":"problem","name":"Access Java object methods through JavaScript exposure","precision":"medium","problem.severity":"warning","security-severity":"6.1"}},{"id":"java/android/websettings-javascript-enabled","name":"java/android/websettings-javascript-enabled","shortDescription":{"text":"Android WebView JavaScript settings"},"fullDescription":{"text":"Enabling JavaScript execution in a WebView can result in cross-site scripting attacks."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Android WebView JavaScript settings\nEnabling JavaScript in an Android WebView allows the execution of JavaScript code in the context of the running application. This creates a cross-site scripting vulnerability.\n\nFor example, if your application's WebView allows for visiting web pages that you do not trust, it is possible for an attacker to lead the user to a page which loads malicious JavaScript.\n\nYou can enable or disable Javascript execution using the `setJavaScriptEnabled` method of the settings of a WebView.\n\n\n## Recommendation\nJavaScript execution is disabled by default. You can explicitly disable it by calling `setJavaScriptEnabled(false)` on the settings of the WebView.\n\nIf JavaScript is necessary, only load content from trusted servers using encrypted channels, such as HTTPS with certificate verification.\n\n\n## Example\nIn the following (bad) example, a WebView has JavaScript enabled in its settings:\n\n\n```java\nWebSettings settings = webview.getSettings();\nsettings.setJavaScriptEnabled(true);\n\n```\nIn the following (good) example, a WebView explicitly disallows JavaScript execution:\n\n\n```java\nWebSettings settings = webview.getSettings();\nsettings.setJavaScriptEnabled(false);\n\n```\n\n## References\n* Android documentation: [setJavaScriptEnabled](https://developer.android.com/reference/android/webkit/WebSettings#setJavaScriptEnabled(boolean))\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n","markdown":"# Android WebView JavaScript settings\nEnabling JavaScript in an Android WebView allows the execution of JavaScript code in the context of the running application. This creates a cross-site scripting vulnerability.\n\nFor example, if your application's WebView allows for visiting web pages that you do not trust, it is possible for an attacker to lead the user to a page which loads malicious JavaScript.\n\nYou can enable or disable Javascript execution using the `setJavaScriptEnabled` method of the settings of a WebView.\n\n\n## Recommendation\nJavaScript execution is disabled by default. You can explicitly disable it by calling `setJavaScriptEnabled(false)` on the settings of the WebView.\n\nIf JavaScript is necessary, only load content from trusted servers using encrypted channels, such as HTTPS with certificate verification.\n\n\n## Example\nIn the following (bad) example, a WebView has JavaScript enabled in its settings:\n\n\n```java\nWebSettings settings = webview.getSettings();\nsettings.setJavaScriptEnabled(true);\n\n```\nIn the following (good) example, a WebView explicitly disallows JavaScript execution:\n\n\n```java\nWebSettings settings = webview.getSettings();\nsettings.setJavaScriptEnabled(false);\n\n```\n\n## References\n* Android documentation: [setJavaScriptEnabled](https://developer.android.com/reference/android/webkit/WebSettings#setJavaScriptEnabled(boolean))\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"},"properties":{"tags":["security","external/cwe/cwe-079"],"description":"Enabling JavaScript execution in a WebView can result in cross-site scripting attacks.","id":"java/android/websettings-javascript-enabled","kind":"problem","name":"Android WebView JavaScript settings","precision":"medium","problem.severity":"warning","security-severity":"6.1"}},{"id":"java/android/sensitive-keyboard-cache","name":"java/android/sensitive-keyboard-cache","shortDescription":{"text":"Android sensitive keyboard cache"},"fullDescription":{"text":"Allowing the keyboard to cache sensitive information may result in information leaks to other applications."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Android sensitive keyboard cache\nWhen a user enters information in a text input field on an Android application, their input is saved to a keyboard cache which provides autocomplete suggestions and predictions. There is a risk that sensitive user data, such as passwords or banking information, may be leaked to other applications via the keyboard cache.\n\n\n## Recommendation\nFor input fields expected to accept sensitive information, use input types such as `\"textNoSuggestions\"` (or `\"textPassword\"` for a password) to ensure the input does not get stored in the keyboard cache.\n\nOptionally, instead of declaring an input type through XML, you can set the input type in your code using `TextView.setInputType()`.\n\n\n## Example\nIn the following example, the field labeled BAD allows the password to be saved to the keyboard cache, whereas the field labeled GOOD uses the `\"textPassword\"` input type to ensure the password is not cached.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <!-- BAD: This password field uses the `text` input type, which allows the input to be saved to the keyboard cache. -->\n    <EditText\n        android:id=\"@+id/password_bad\"\n        android:inputType=\"text\"/> \n\n    <!-- GOOD: This password field uses the `textPassword` input type, which ensures that the input is not saved to the keyboard cache. -->\n    <EditText\n        android:id=\"@+id/password_good\"\n        android:inputType=\"textPassword\"/>  \n</LinearLayout>\n```\n\n## References\n* OWASP Mobile Application Security Testing Guide: [Determining Whether the Keyboard Cache Is Disabled for Text Input Fields](https://github.com/OWASP/owasp-mastg/blob/b7a93a2e5e0557cc9a12e55fc3f6675f6986bb86/Document/0x05d-Testing-Data-Storage.md#determining-whether-the-keyboard-cache-is-disabled-for-text-input-fields-mstg-storage-5).\n* Android Developers: [android:inputType attribute documentation.](https://developer.android.com/reference/android/widget/TextView#attr_android:inputType)\n* Common Weakness Enumeration: [CWE-524](https://cwe.mitre.org/data/definitions/524.html).\n","markdown":"# Android sensitive keyboard cache\nWhen a user enters information in a text input field on an Android application, their input is saved to a keyboard cache which provides autocomplete suggestions and predictions. There is a risk that sensitive user data, such as passwords or banking information, may be leaked to other applications via the keyboard cache.\n\n\n## Recommendation\nFor input fields expected to accept sensitive information, use input types such as `\"textNoSuggestions\"` (or `\"textPassword\"` for a password) to ensure the input does not get stored in the keyboard cache.\n\nOptionally, instead of declaring an input type through XML, you can set the input type in your code using `TextView.setInputType()`.\n\n\n## Example\nIn the following example, the field labeled BAD allows the password to be saved to the keyboard cache, whereas the field labeled GOOD uses the `\"textPassword\"` input type to ensure the password is not cached.\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <!-- BAD: This password field uses the `text` input type, which allows the input to be saved to the keyboard cache. -->\n    <EditText\n        android:id=\"@+id/password_bad\"\n        android:inputType=\"text\"/> \n\n    <!-- GOOD: This password field uses the `textPassword` input type, which ensures that the input is not saved to the keyboard cache. -->\n    <EditText\n        android:id=\"@+id/password_good\"\n        android:inputType=\"textPassword\"/>  \n</LinearLayout>\n```\n\n## References\n* OWASP Mobile Application Security Testing Guide: [Determining Whether the Keyboard Cache Is Disabled for Text Input Fields](https://github.com/OWASP/owasp-mastg/blob/b7a93a2e5e0557cc9a12e55fc3f6675f6986bb86/Document/0x05d-Testing-Data-Storage.md#determining-whether-the-keyboard-cache-is-disabled-for-text-input-fields-mstg-storage-5).\n* Android Developers: [android:inputType attribute documentation.](https://developer.android.com/reference/android/widget/TextView#attr_android:inputType)\n* Common Weakness Enumeration: [CWE-524](https://cwe.mitre.org/data/definitions/524.html).\n"},"properties":{"tags":["security","external/cwe/cwe-524"],"description":"Allowing the keyboard to cache sensitive information may result in information leaks to other applications.","id":"java/android/sensitive-keyboard-cache","kind":"problem","name":"Android sensitive keyboard cache","precision":"medium","problem.severity":"warning","security-severity":"8.1"}},{"id":"java/concatenated-sql-query","name":"java/concatenated-sql-query","shortDescription":{"text":"Query built by concatenation with a possibly-untrusted string"},"fullDescription":{"text":"Building a SQL or Java Persistence query by concatenating a possibly-untrusted string is vulnerable to insertion of malicious code."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Query built by concatenation with a possibly-untrusted string\nEven when the components of a SQL query are not fully controlled by a user, it is a vulnerability to build the query by directly concatenating those components. Perhaps a separate vulnerability will allow the user to gain control of the component. As well, a user who cannot gain full control of an input might influence it enough to cause the SQL query to fail to run.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating the result of `getCategory` with some string literals. The result of `getCategory` can include special characters, or it might be refactored later so that it may return something that contains special characters.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the result of `getCategory` are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = getCategory();\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = getCategory();\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n","markdown":"# Query built by concatenation with a possibly-untrusted string\nEven when the components of a SQL query are not fully controlled by a user, it is a vulnerability to build the query by directly concatenating those components. Perhaps a separate vulnerability will allow the user to gain control of the component. As well, a user who cannot gain full control of an input might influence it enough to cause the SQL query to fail to run.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating the result of `getCategory` with some string literals. The result of `getCategory` can include special characters, or it might be refactored later so that it may return something that contains special characters.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the result of `getCategory` are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = getCategory();\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = getCategory();\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n"},"properties":{"tags":["security","external/cwe/cwe-089","external/cwe/cwe-564"],"description":"Building a SQL or Java Persistence query by concatenating a possibly-untrusted string\n              is vulnerable to insertion of malicious code.","id":"java/concatenated-sql-query","kind":"problem","name":"Query built by concatenation with a possibly-untrusted string","precision":"medium","problem.severity":"error","security-severity":"8.8"}},{"id":"java/android/websettings-file-access","name":"java/android/websettings-file-access","shortDescription":{"text":"Android WebSettings file access"},"fullDescription":{"text":"Enabling access to the file system in a WebView allows attackers to view sensitive information."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Android WebSettings file access\nAllowing file access in an Android WebView can expose a device's file system to the JavaScript running in that WebView. If the JavaScript contains vulnerabilities or the WebView loads untrusted content, file access allows an attacker to steal the user's data.\n\n\n## Recommendation\nWhen possible, do not allow file access. The file access settings are disabled by default. You can explicitly disable file access by setting the following settings to `false`:\n\n* `setAllowFileAccess`\n* `setAllowFileAccessFromFileURLs`\n* `setAllowUniversalAccessFromFileURLs`\nIf your application requires access to the file system, it is best to avoid using `file://` URLs. Instead, use an alternative that loads files via HTTPS, such as `androidx.webkit.WebViewAssetLoader`.\n\n\n## Example\nIn the following (bad) example, the WebView is configured with settings that allow local file access.\n\n\n```java\nWebSettings settings = view.getSettings();\n\nsettings.setAllowFileAccess(true);\nsettings.setAllowFileAccessFromURLs(true);\nsettings.setAllowUniversalAccessFromURLs(true);\n\n```\nIn the following (good) example, the WebView is configured to disallow file access.\n\n\n```java\nWebSettings settings = view.getSettings();\n\nsettings.setAllowFileAccess(false);\nsettings.setAllowFileAccessFromURLs(false);\nsettings.setAllowUniversalAccessFromURLs(false);\n\n```\nAs mentioned previously, asset loaders can load files without file system access. In the following (good) example, an asset loader is configured to load assets over HTTPS.\n\n\n```java\nWebViewAssetLoader loader = new WebViewAssetLoader.Builder()\n    // Replace the domain with a domain you control, or use the default\n    // appassets.androidplatform.com\n    .setDomain(\"appassets.example.com\")\n    .addPathHandler(\"/resources\", new AssetsPathHandler(this))\n    .build();\n\nwebView.setWebViewClient(new WebViewClientCompat() {\n    @Override\n    public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n        return assetLoader.shouldInterceptRequest(request.getUrl());\n    }\n});\n\nwebView.loadUrl(\"https://appassets.example.com/resources/www/index.html\");\n\n```\n\n## References\n* Android documentation: [WebSettings.setAllowFileAccess](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccess(boolean)).\n* Android documentation: [WebSettings.setAllowFileAccessFromFileURLs](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccessFromFileURLs(boolean)).\n* Android documentation: [WebSettings.setAllowUniversalAccessFromFileURLs](https://developer.android.com/reference/android/webkit/WebSettings#setAllowUniversalAccessFromFileURLs(boolean)).\n* Android documentation: [WebViewAssetLoader](https://developer.android.com/reference/androidx/webkit/WebViewAssetLoader).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n","markdown":"# Android WebSettings file access\nAllowing file access in an Android WebView can expose a device's file system to the JavaScript running in that WebView. If the JavaScript contains vulnerabilities or the WebView loads untrusted content, file access allows an attacker to steal the user's data.\n\n\n## Recommendation\nWhen possible, do not allow file access. The file access settings are disabled by default. You can explicitly disable file access by setting the following settings to `false`:\n\n* `setAllowFileAccess`\n* `setAllowFileAccessFromFileURLs`\n* `setAllowUniversalAccessFromFileURLs`\nIf your application requires access to the file system, it is best to avoid using `file://` URLs. Instead, use an alternative that loads files via HTTPS, such as `androidx.webkit.WebViewAssetLoader`.\n\n\n## Example\nIn the following (bad) example, the WebView is configured with settings that allow local file access.\n\n\n```java\nWebSettings settings = view.getSettings();\n\nsettings.setAllowFileAccess(true);\nsettings.setAllowFileAccessFromURLs(true);\nsettings.setAllowUniversalAccessFromURLs(true);\n\n```\nIn the following (good) example, the WebView is configured to disallow file access.\n\n\n```java\nWebSettings settings = view.getSettings();\n\nsettings.setAllowFileAccess(false);\nsettings.setAllowFileAccessFromURLs(false);\nsettings.setAllowUniversalAccessFromURLs(false);\n\n```\nAs mentioned previously, asset loaders can load files without file system access. In the following (good) example, an asset loader is configured to load assets over HTTPS.\n\n\n```java\nWebViewAssetLoader loader = new WebViewAssetLoader.Builder()\n    // Replace the domain with a domain you control, or use the default\n    // appassets.androidplatform.com\n    .setDomain(\"appassets.example.com\")\n    .addPathHandler(\"/resources\", new AssetsPathHandler(this))\n    .build();\n\nwebView.setWebViewClient(new WebViewClientCompat() {\n    @Override\n    public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n        return assetLoader.shouldInterceptRequest(request.getUrl());\n    }\n});\n\nwebView.loadUrl(\"https://appassets.example.com/resources/www/index.html\");\n\n```\n\n## References\n* Android documentation: [WebSettings.setAllowFileAccess](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccess(boolean)).\n* Android documentation: [WebSettings.setAllowFileAccessFromFileURLs](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccessFromFileURLs(boolean)).\n* Android documentation: [WebSettings.setAllowUniversalAccessFromFileURLs](https://developer.android.com/reference/android/webkit/WebSettings#setAllowUniversalAccessFromFileURLs(boolean)).\n* Android documentation: [WebViewAssetLoader](https://developer.android.com/reference/androidx/webkit/WebViewAssetLoader).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"},"properties":{"tags":["security","external/cwe/cwe-200"],"description":"Enabling access to the file system in a WebView allows attackers to view sensitive information.","id":"java/android/websettings-file-access","kind":"problem","name":"Android WebSettings file access","precision":"medium","problem.severity":"warning","security-severity":"6.5"}},{"id":"java/android/websettings-allow-content-access","name":"java/android/websettings-allow-content-access","shortDescription":{"text":"Android WebView settings allows access to content links"},"fullDescription":{"text":"Access to content providers in a WebView can allow access to protected information by loading content:// links."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Android WebView settings allows access to content links\nAndroid can provide access to content providers within a WebView using the `setAllowContentAccess` setting.\n\nAllowing access to content providers via `content://` URLs may allow JavaScript to access protected content.\n\n\n## Recommendation\nIf your app does not require access to the `content://` URL functionality, you should explicitly disable the setting by calling `setAllowContentAccess(false)` on the settings of the WebView.\n\n\n## Example\nIn the following (bad) example, access to `content://` URLs is explicitly allowed.\n\n\n```java\nWebSettings settings = webview.getSettings();\n\nsettings.setAllowContentAccess(true);\n\n```\nIn the following (good) example, access to `content://` URLs is explicitly denied.\n\n\n```java\nWebSettings settings = webview.getSettings();\n\nsettings.setAllowContentAccess(false);\n\n```\n\n## References\n* Android Documentation: [setAllowContentAccess](https://developer.android.com/reference/android/webkit/WebSettings#setAllowContentAccess(boolean)).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n","markdown":"# Android WebView settings allows access to content links\nAndroid can provide access to content providers within a WebView using the `setAllowContentAccess` setting.\n\nAllowing access to content providers via `content://` URLs may allow JavaScript to access protected content.\n\n\n## Recommendation\nIf your app does not require access to the `content://` URL functionality, you should explicitly disable the setting by calling `setAllowContentAccess(false)` on the settings of the WebView.\n\n\n## Example\nIn the following (bad) example, access to `content://` URLs is explicitly allowed.\n\n\n```java\nWebSettings settings = webview.getSettings();\n\nsettings.setAllowContentAccess(true);\n\n```\nIn the following (good) example, access to `content://` URLs is explicitly denied.\n\n\n```java\nWebSettings settings = webview.getSettings();\n\nsettings.setAllowContentAccess(false);\n\n```\n\n## References\n* Android Documentation: [setAllowContentAccess](https://developer.android.com/reference/android/webkit/WebSettings#setAllowContentAccess(boolean)).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"},"properties":{"tags":["security","external/cwe/cwe-200"],"description":"Access to content providers in a WebView can allow access to protected information by loading content:// links.","id":"java/android/websettings-allow-content-access","kind":"problem","name":"Android WebView settings allows access to content links","precision":"medium","problem.severity":"warning","security-severity":"6.5"}},{"id":"java/local-temp-file-or-directory-information-disclosure","name":"java/local-temp-file-or-directory-information-disclosure","shortDescription":{"text":"Local information disclosure in a temporary directory"},"fullDescription":{"text":"Writing information without explicit permissions to a shared temporary directory may disclose it to other users."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Local information disclosure in a temporary directory\nLocal information disclosure can occur when files/directories are written into directories that are shared between all users on the system.\n\nOn most [unix-like](https://en.wikipedia.org/wiki/Unix-like) systems, the system temporary directory is shared between local users. If files/directories are created within the system temporary directory without using APIs that explicitly set the correct file permissions, local information disclosure can occur.\n\nDepending upon the particular file contents exposed, this vulnerability can have a [CVSSv3.1 base score of 6.2/10](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N&version=3.1).\n\n\n## Recommendation\nUse JDK methods that specifically protect against this vulnerability:\n\n* [java.nio.file.Files.createTempDirectory](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.nio.file.Path-java.lang.String-java.nio.file.attribute.FileAttribute...-)\n* [java.nio.file.Files.createTempFile](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.nio.file.Path-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-)\nOtherwise, create the file/directory by manually specifying the expected posix file permissions. For example: `PosixFilePermissions.asFileAttribute(EnumSet.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE))`\n\n* [java.nio.file.Files.createFile](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)\n* [java.nio.file.Files.createDirectory](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)\n* [java.nio.file.Files.createDirectories](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectories-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)\n\n## Example\nIn the following example, files and directories are created with file permissions that allow other local users to read their contents.\n\n\n```java\nimport java.io.File;\n\npublic class TempDirUsageVulnerable {\n    void exampleVulnerable() {\n        File temp1 = File.createTempFile(\"random\", \".txt\"); // BAD: File has permissions `-rw-r--r--`\n\n        File temp2 = File.createTempFile(\"random\", \"file\", null); // BAD: File has permissions `-rw-r--r--`\n\n        File systemTempDir = new File(System.getProperty(\"java.io.tmpdir\"));\n        File temp3 = File.createTempFile(\"random\", \"file\", systemTempDir); // BAD: File has permissions `-rw-r--r--`\n\n        File tempDir = com.google.common.io.Files.createTempDir(); // BAD: CVE-2020-8908: Directory has permissions `drwxr-xr-x`\n\n        new File(System.getProperty(\"java.io.tmpdir\"), \"/child\").mkdir(); // BAD: Directory has permissions `-rw-r--r--`\n\n        File tempDirChildFile = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-create-file.txt\");\n        Files.createFile(tempDirChildFile.toPath()); // BAD: File has permissions `-rw-r--r--`\n\n        File tempDirChildDir = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-dir\");\n        tempDirChildDir.mkdir(); // BAD: Directory has permissions `drwxr-xr-x`\n        Files.createDirectory(tempDirChildDir.toPath()); // BAD: Directory has permissions `drwxr-xr-x`\n    }\n}\n\n```\nIn the following example, files and directories are created with file permissions that protect their contents.\n\n\n```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\n\nimport java.util.EnumSet;\n\n\npublic class TempDirUsageSafe {\n    void exampleSafe() throws IOException {\n        Path temp1 = Files.createTempFile(\"random\", \".txt\"); // GOOD: File has permissions `-rw-------`\n\n        Path temp2 = Files.createTempDirectory(\"random-directory\"); // GOOD: File has permissions `drwx------`\n\n        // Creating a temporary file with a non-randomly generated name\n        File tempChildFile = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-create-file.txt\");\n        // Warning: This will fail on windows as it doesn't support PosixFilePermissions.\n        // See `exampleSafeWithWindowsSupportFile` if your code needs to support windows and unix-like systems.\n        Files.createFile(\n            tempChildFile.toPath(),\n            PosixFilePermissions.asFileAttribute(EnumSet.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE))\n        ); // GOOD: Good has permissions `-rw-------`\n    }\n\n    /*\n     * An example of a safe use of createFile or createDirectory if your code must support windows and unix-like systems.\n     */\n    void exampleSafeWithWindowsSupportFile() {\n        // Creating a temporary file with a non-randomly generated name\n        File tempChildFile = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-create-file.txt\");\n        createTempFile(tempChildFile.toPath()); // GOOD: Good has permissions `-rw-------`\n    }\n\n    static void createTempFile(Path tempDirChild) {\n        try {\n            if (tempDirChild.getFileSystem().supportedFileAttributeViews().contains(\"posix\")) {\n                // Explicit permissions setting is only required on unix-like systems because\n                // the temporary directory is shared between all users.\n                // This is not necessary on Windows, each user has their own temp directory\n                final EnumSet<PosixFilePermission> posixFilePermissions =\n                        EnumSet.of(\n                            PosixFilePermission.OWNER_READ,\n                            PosixFilePermission.OWNER_WRITE\n                        );\n                if (!Files.exists(tempDirChild)) {\n                    Files.createFile(\n                        tempDirChild,\n                        PosixFilePermissions.asFileAttribute(posixFilePermissions)\n                    ); // GOOD: Directory has permissions `-rw-------`\n                } else {\n                    Files.setPosixFilePermissions(\n                            tempDirChild,\n                            posixFilePermissions\n                    ); // GOOD: Good has permissions `-rw-------`, or will throw an exception if this fails\n                }\n            } else if (!Files.exists(tempDirChild)) {\n                // On Windows, we still need to create the directory, when it doesn't already exist.\n                Files.createDirectory(tempDirChild); // GOOD: Windows doesn't share the temp directory between users\n            }\n        } catch (IOException exception) {\n            throw new UncheckedIOException(\"Failed to create temp file\", exception);\n        }\n    }\n\n    void exampleSafeWithWindowsSupportDirectory() {\n        File tempDirChildDir = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-dir\");\n        createTempDirectories(tempDirChildDir.toPath()); // GOOD: Directory has permissions `drwx------`\n    }\n\n    static void createTempDirectories(Path tempDirChild) {\n        try {\n            if (tempDirChild.getFileSystem().supportedFileAttributeViews().contains(\"posix\")) {\n                // Explicit permissions setting is only required on unix-like systems because\n                // the temporary directory is shared between all users.\n                // This is not necessary on Windows, each user has their own temp directory\n                final EnumSet<PosixFilePermission> posixFilePermissions =\n                        EnumSet.of(\n                            PosixFilePermission.OWNER_READ,\n                            PosixFilePermission.OWNER_WRITE,\n                            PosixFilePermission.OWNER_EXECUTE\n                        );\n                if (!Files.exists(tempDirChild)) {\n                    Files.createDirectories(\n                        tempDirChild,\n                        PosixFilePermissions.asFileAttribute(posixFilePermissions)\n                    ); // GOOD: Directory has permissions `drwx------`\n                } else {\n                    Files.setPosixFilePermissions(\n                            tempDirChild,\n                            posixFilePermissions\n                    ); // GOOD: Good has permissions `drwx------`, or will throw an exception if this fails\n                }\n            } else if (!Files.exists(tempDirChild)) {\n                // On Windows, we still need to create the directory, when it doesn't already exist.\n                Files.createDirectories(tempDirChild); // GOOD: Windows doesn't share the temp directory between users\n            }\n        } catch (IOException exception) {\n            throw new UncheckedIOException(\"Failed to create temp dir\", exception);\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Insecure Temporary File](https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File).\n* CERT: [FIO00-J. Do not operate on files in shared directories](https://wiki.sei.cmu.edu/confluence/display/java/FIO00-J.+Do+not+operate+on+files+in+shared+directories).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n","markdown":"# Local information disclosure in a temporary directory\nLocal information disclosure can occur when files/directories are written into directories that are shared between all users on the system.\n\nOn most [unix-like](https://en.wikipedia.org/wiki/Unix-like) systems, the system temporary directory is shared between local users. If files/directories are created within the system temporary directory without using APIs that explicitly set the correct file permissions, local information disclosure can occur.\n\nDepending upon the particular file contents exposed, this vulnerability can have a [CVSSv3.1 base score of 6.2/10](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N&version=3.1).\n\n\n## Recommendation\nUse JDK methods that specifically protect against this vulnerability:\n\n* [java.nio.file.Files.createTempDirectory](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.nio.file.Path-java.lang.String-java.nio.file.attribute.FileAttribute...-)\n* [java.nio.file.Files.createTempFile](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.nio.file.Path-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-)\nOtherwise, create the file/directory by manually specifying the expected posix file permissions. For example: `PosixFilePermissions.asFileAttribute(EnumSet.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE))`\n\n* [java.nio.file.Files.createFile](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)\n* [java.nio.file.Files.createDirectory](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)\n* [java.nio.file.Files.createDirectories](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectories-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)\n\n## Example\nIn the following example, files and directories are created with file permissions that allow other local users to read their contents.\n\n\n```java\nimport java.io.File;\n\npublic class TempDirUsageVulnerable {\n    void exampleVulnerable() {\n        File temp1 = File.createTempFile(\"random\", \".txt\"); // BAD: File has permissions `-rw-r--r--`\n\n        File temp2 = File.createTempFile(\"random\", \"file\", null); // BAD: File has permissions `-rw-r--r--`\n\n        File systemTempDir = new File(System.getProperty(\"java.io.tmpdir\"));\n        File temp3 = File.createTempFile(\"random\", \"file\", systemTempDir); // BAD: File has permissions `-rw-r--r--`\n\n        File tempDir = com.google.common.io.Files.createTempDir(); // BAD: CVE-2020-8908: Directory has permissions `drwxr-xr-x`\n\n        new File(System.getProperty(\"java.io.tmpdir\"), \"/child\").mkdir(); // BAD: Directory has permissions `-rw-r--r--`\n\n        File tempDirChildFile = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-create-file.txt\");\n        Files.createFile(tempDirChildFile.toPath()); // BAD: File has permissions `-rw-r--r--`\n\n        File tempDirChildDir = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-dir\");\n        tempDirChildDir.mkdir(); // BAD: Directory has permissions `drwxr-xr-x`\n        Files.createDirectory(tempDirChildDir.toPath()); // BAD: Directory has permissions `drwxr-xr-x`\n    }\n}\n\n```\nIn the following example, files and directories are created with file permissions that protect their contents.\n\n\n```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\n\nimport java.util.EnumSet;\n\n\npublic class TempDirUsageSafe {\n    void exampleSafe() throws IOException {\n        Path temp1 = Files.createTempFile(\"random\", \".txt\"); // GOOD: File has permissions `-rw-------`\n\n        Path temp2 = Files.createTempDirectory(\"random-directory\"); // GOOD: File has permissions `drwx------`\n\n        // Creating a temporary file with a non-randomly generated name\n        File tempChildFile = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-create-file.txt\");\n        // Warning: This will fail on windows as it doesn't support PosixFilePermissions.\n        // See `exampleSafeWithWindowsSupportFile` if your code needs to support windows and unix-like systems.\n        Files.createFile(\n            tempChildFile.toPath(),\n            PosixFilePermissions.asFileAttribute(EnumSet.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE))\n        ); // GOOD: Good has permissions `-rw-------`\n    }\n\n    /*\n     * An example of a safe use of createFile or createDirectory if your code must support windows and unix-like systems.\n     */\n    void exampleSafeWithWindowsSupportFile() {\n        // Creating a temporary file with a non-randomly generated name\n        File tempChildFile = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-create-file.txt\");\n        createTempFile(tempChildFile.toPath()); // GOOD: Good has permissions `-rw-------`\n    }\n\n    static void createTempFile(Path tempDirChild) {\n        try {\n            if (tempDirChild.getFileSystem().supportedFileAttributeViews().contains(\"posix\")) {\n                // Explicit permissions setting is only required on unix-like systems because\n                // the temporary directory is shared between all users.\n                // This is not necessary on Windows, each user has their own temp directory\n                final EnumSet<PosixFilePermission> posixFilePermissions =\n                        EnumSet.of(\n                            PosixFilePermission.OWNER_READ,\n                            PosixFilePermission.OWNER_WRITE\n                        );\n                if (!Files.exists(tempDirChild)) {\n                    Files.createFile(\n                        tempDirChild,\n                        PosixFilePermissions.asFileAttribute(posixFilePermissions)\n                    ); // GOOD: Directory has permissions `-rw-------`\n                } else {\n                    Files.setPosixFilePermissions(\n                            tempDirChild,\n                            posixFilePermissions\n                    ); // GOOD: Good has permissions `-rw-------`, or will throw an exception if this fails\n                }\n            } else if (!Files.exists(tempDirChild)) {\n                // On Windows, we still need to create the directory, when it doesn't already exist.\n                Files.createDirectory(tempDirChild); // GOOD: Windows doesn't share the temp directory between users\n            }\n        } catch (IOException exception) {\n            throw new UncheckedIOException(\"Failed to create temp file\", exception);\n        }\n    }\n\n    void exampleSafeWithWindowsSupportDirectory() {\n        File tempDirChildDir = new File(System.getProperty(\"java.io.tmpdir\"), \"/child-dir\");\n        createTempDirectories(tempDirChildDir.toPath()); // GOOD: Directory has permissions `drwx------`\n    }\n\n    static void createTempDirectories(Path tempDirChild) {\n        try {\n            if (tempDirChild.getFileSystem().supportedFileAttributeViews().contains(\"posix\")) {\n                // Explicit permissions setting is only required on unix-like systems because\n                // the temporary directory is shared between all users.\n                // This is not necessary on Windows, each user has their own temp directory\n                final EnumSet<PosixFilePermission> posixFilePermissions =\n                        EnumSet.of(\n                            PosixFilePermission.OWNER_READ,\n                            PosixFilePermission.OWNER_WRITE,\n                            PosixFilePermission.OWNER_EXECUTE\n                        );\n                if (!Files.exists(tempDirChild)) {\n                    Files.createDirectories(\n                        tempDirChild,\n                        PosixFilePermissions.asFileAttribute(posixFilePermissions)\n                    ); // GOOD: Directory has permissions `drwx------`\n                } else {\n                    Files.setPosixFilePermissions(\n                            tempDirChild,\n                            posixFilePermissions\n                    ); // GOOD: Good has permissions `drwx------`, or will throw an exception if this fails\n                }\n            } else if (!Files.exists(tempDirChild)) {\n                // On Windows, we still need to create the directory, when it doesn't already exist.\n                Files.createDirectories(tempDirChild); // GOOD: Windows doesn't share the temp directory between users\n            }\n        } catch (IOException exception) {\n            throw new UncheckedIOException(\"Failed to create temp dir\", exception);\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Insecure Temporary File](https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File).\n* CERT: [FIO00-J. Do not operate on files in shared directories](https://wiki.sei.cmu.edu/confluence/display/java/FIO00-J.+Do+not+operate+on+files+in+shared+directories).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n"},"properties":{"tags":["security","external/cwe/cwe-200","external/cwe/cwe-732"],"description":"Writing information without explicit permissions to a shared temporary directory may disclose it to other users.","id":"java/local-temp-file-or-directory-information-disclosure","kind":"path-problem","name":"Local information disclosure in a temporary directory","precision":"medium","problem.severity":"warning","security-severity":"6.5"}},{"id":"java/android/sensitive-text","name":"java/android/sensitive-text","shortDescription":{"text":"Exposure of sensitive information to UI text views"},"fullDescription":{"text":"Sensitive information displayed in UI text views should be properly masked."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Exposure of sensitive information to UI text views\nSensitive information such as passwords should not be displayed in UI components unless explicitly required, to mitigate shoulder-surfing attacks.\n\n\n## Recommendation\nFor editable text fields containing sensitive information, the `inputType` should be set to `textPassword` or similar to ensure it is properly masked. Otherwise, sensitive data that must be displayed should be hidden by default, and only revealed based on an explicit user action.\n\n\n## Example\nIn the following (bad) case, sensitive information in `password` is exposed to the `TextView`.\n\n\n```java\nTextView pwView = getViewById(R.id.pw_text);\npwView.setText(\"Your password is: \" + password);\n```\nIn the following (good) case, the user must press a button to reveal sensitive information.\n\n\n```java\nTextView pwView = findViewById(R.id.pw_text);\npwView.setVisibility(View.INVISIBLE);\npwView.setText(\"Your password is: \" + password);\n\nButton showButton = findViewById(R.id.show_pw_button);\nshowButton.setOnClickListener(new View.OnClickListener() {\n    public void onClick(View v) {\n      pwView.setVisibility(View.VISIBLE);\n    }\n});\n\n```\n\n## References\n* OWASP Mobile Application Security: [Android Data Storage - UI Components](https://mas.owasp.org/MASTG/Android/0x05d-Testing-Data-Storage/#ui-components)\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n","markdown":"# Exposure of sensitive information to UI text views\nSensitive information such as passwords should not be displayed in UI components unless explicitly required, to mitigate shoulder-surfing attacks.\n\n\n## Recommendation\nFor editable text fields containing sensitive information, the `inputType` should be set to `textPassword` or similar to ensure it is properly masked. Otherwise, sensitive data that must be displayed should be hidden by default, and only revealed based on an explicit user action.\n\n\n## Example\nIn the following (bad) case, sensitive information in `password` is exposed to the `TextView`.\n\n\n```java\nTextView pwView = getViewById(R.id.pw_text);\npwView.setText(\"Your password is: \" + password);\n```\nIn the following (good) case, the user must press a button to reveal sensitive information.\n\n\n```java\nTextView pwView = findViewById(R.id.pw_text);\npwView.setVisibility(View.INVISIBLE);\npwView.setText(\"Your password is: \" + password);\n\nButton showButton = findViewById(R.id.show_pw_button);\nshowButton.setOnClickListener(new View.OnClickListener() {\n    public void onClick(View v) {\n      pwView.setVisibility(View.VISIBLE);\n    }\n});\n\n```\n\n## References\n* OWASP Mobile Application Security: [Android Data Storage - UI Components](https://mas.owasp.org/MASTG/Android/0x05d-Testing-Data-Storage/#ui-components)\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"},"properties":{"tags":["security","external/cwe/cwe-200"],"description":"Sensitive information displayed in UI text views should be properly masked.","id":"java/android/sensitive-text","kind":"path-problem","name":"Exposure of sensitive information to UI text views","precision":"medium","problem.severity":"warning","security-severity":"6.5"}},{"id":"java/android/sensitive-notification","name":"java/android/sensitive-notification","shortDescription":{"text":"Exposure of sensitive information to notifications"},"fullDescription":{"text":"Sensitive information exposed in a system notification can be read by an unauthorized application."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Exposure of sensitive information to notifications\nSensitive information such as passwords or two-factor authentication (2FA) codes should not be exposed in a system notification. Notifications should not be considered secure, as other untrusted applications may be able to use a `NotificationListenerService` to read the contents of notifications.\n\n\n## Recommendation\nDo not expose sensitive data in notifications.\n\n\n## Example\nIn the following sample, the `password` is sent as part of a notification. This can allow another application to read this password.\n\n\n```java\n// BAD: `password` is exposed in a notification.\nvoid confirmPassword(String password) {\n    NotificationManager manager = NotificationManager.from(this);\n    manager.send(\n        new Notification.Builder(this, CHANNEL_ID)\n        .setContentText(\"Your password is: \" + password)\n        .build());\n}\n```\n\n## References\n* OWASP Mobile Application Security: [Android Data Storage - Application Notifications](https://mas.owasp.org/MASTG/Android/0x05d-Testing-Data-Storage/#app-notifications)\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n","markdown":"# Exposure of sensitive information to notifications\nSensitive information such as passwords or two-factor authentication (2FA) codes should not be exposed in a system notification. Notifications should not be considered secure, as other untrusted applications may be able to use a `NotificationListenerService` to read the contents of notifications.\n\n\n## Recommendation\nDo not expose sensitive data in notifications.\n\n\n## Example\nIn the following sample, the `password` is sent as part of a notification. This can allow another application to read this password.\n\n\n```java\n// BAD: `password` is exposed in a notification.\nvoid confirmPassword(String password) {\n    NotificationManager manager = NotificationManager.from(this);\n    manager.send(\n        new Notification.Builder(this, CHANNEL_ID)\n        .setContentText(\"Your password is: \" + password)\n        .build());\n}\n```\n\n## References\n* OWASP Mobile Application Security: [Android Data Storage - Application Notifications](https://mas.owasp.org/MASTG/Android/0x05d-Testing-Data-Storage/#app-notifications)\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"},"properties":{"tags":["security","external/cwe/cwe-200"],"description":"Sensitive information exposed in a system notification can be read by an unauthorized application.","id":"java/android/sensitive-notification","kind":"path-problem","name":"Exposure of sensitive information to notifications","precision":"medium","problem.severity":"error","security-severity":"6.5"}},{"id":"java/android/arbitrary-apk-installation","name":"java/android/arbitrary-apk-installation","shortDescription":{"text":"Android APK installation"},"fullDescription":{"text":"Creating an intent with a URI pointing to a untrusted file can lead to the installation of an untrusted application."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Android APK installation\nAndroid allows an application to install an Android Package Kit (APK) using an `Intent` with the `\"application/vnd.android.package-archive\"` MIME type. If the file used in the `Intent` is from a location that is not controlled by the application (for example, an SD card that is universally writable), this can result in the unintended installation of untrusted applications.\n\n\n## Recommendation\nYou should install packages using the `PackageInstaller` class.\n\nIf you need to install from a file, you should use a `FileProvider`. Content providers can provide more specific permissions than file system permissions can.\n\nWhen your application does not require package installations, do not add the `REQUEST_INSTALL_PACKAGES` permission in the manifest file.\n\n\n## Example\nIn the following (bad) example, the package is installed from a file which may be altered by another application:\n\n\n```java\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Environment;\n\nimport java.io.File;\n\n/* Get a file from external storage */\nFile file = new File(Environment.getExternalStorageDirectory(), \"myapp.apk\");\nIntent intent = new Intent(Intent.ACTION_VIEW);\n/* Set the mimetype to APK */\nintent.setDataAndType(Uri.fromFile(file), \"application/vnd.android.package-archive\");\n\nstartActivity(intent);\n\n```\nIn the following (good) example, the package is installed by using a `FileProvider`:\n\n\n```java\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport androidx.core.content.FileProvider;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\n\nString tempFilename = \"temporary.apk\";\nbyte[] buffer = new byte[16384];\n\n/* Copy application asset into temporary file */\ntry (InputStream is = getAssets().open(assetName);\n     FileOutputStream fout = openFileOutput(tempFilename, Context.MODE_PRIVATE)) {\n    int n;\n    while ((n=is.read(buffer)) >= 0) {\n        fout.write(buffer, 0, n);\n    }\n}\n\n/* Expose temporary file with FileProvider */\nFile toInstall = new File(this.getFilesDir(), tempFilename);\nUri applicationUri = FileProvider.getUriForFile(this, \"com.example.apkprovider\", toInstall);\n\n/* Create Intent and set data to APK file. */\nIntent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE);\nintent.setData(applicationUri);\nintent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\nstartActivity(intent);\n\n```\nIn the following (good) example, the package is installed using an instance of the `android.content.pm.PackageInstaller` class:\n\n\n```java\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInstaller;\n\nprivate static final String PACKAGE_INSTALLED_ACTION =\n    \"com.example.SESSION_API_PACKAGE_INSTALLED\";\n\n/* Create the package installer and session */\nPackageInstaller packageInstaller = getPackageManager().getPackageInstaller();\nPackageInstaller.SessionParams params =\n    new PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL);\nint sessionId = packageInstaller.createSession(params);\nsession = packageInstaller.openSession(sessionId);\n\n/* Load asset into session */\ntry (OutputStream packageInSession = session.openWrite(\"package\", 0, -1);\n     InputStream is = getAssets().open(assetName)) {\n    byte[] buffer = new byte[16384];\n    int n;\n    while ((n = is.read(buffer)) >= 0) {\n        packageInSession.write(buffer, 0, n);\n    }\n}\n\n/* Create status receiver */\nIntent intent = new Intent(this, InstallApkSessionApi.class);\nintent.setAction(PACKAGE_INSTALLED_ACTION);\nPendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);\nIntentSender statusReceiver = pendingIntent.getIntentSender();\n\n/* Commit the session */\nsession.commit(statusReceiver);\n\n```\n\n## References\n* Android Developers: [Intent.ACTION_INSTALL_PACKAGE](https://developer.android.com/reference/android/content/Intent#ACTION_INSTALL_PACKAGE).\n* Android Developers: [Manifest.permission.REQUEST_INSTALL_PACKAGES](https://developer.android.com/reference/android/Manifest.permission#REQUEST_INSTALL_PACKAGES).\n* Android Developers: [PackageInstaller](https://developer.android.com/reference/android/content/pm/PackageInstaller).\n* Android Developers: [FileProvider](https://developer.android.com/reference/androidx/core/content/FileProvider).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n","markdown":"# Android APK installation\nAndroid allows an application to install an Android Package Kit (APK) using an `Intent` with the `\"application/vnd.android.package-archive\"` MIME type. If the file used in the `Intent` is from a location that is not controlled by the application (for example, an SD card that is universally writable), this can result in the unintended installation of untrusted applications.\n\n\n## Recommendation\nYou should install packages using the `PackageInstaller` class.\n\nIf you need to install from a file, you should use a `FileProvider`. Content providers can provide more specific permissions than file system permissions can.\n\nWhen your application does not require package installations, do not add the `REQUEST_INSTALL_PACKAGES` permission in the manifest file.\n\n\n## Example\nIn the following (bad) example, the package is installed from a file which may be altered by another application:\n\n\n```java\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Environment;\n\nimport java.io.File;\n\n/* Get a file from external storage */\nFile file = new File(Environment.getExternalStorageDirectory(), \"myapp.apk\");\nIntent intent = new Intent(Intent.ACTION_VIEW);\n/* Set the mimetype to APK */\nintent.setDataAndType(Uri.fromFile(file), \"application/vnd.android.package-archive\");\n\nstartActivity(intent);\n\n```\nIn the following (good) example, the package is installed by using a `FileProvider`:\n\n\n```java\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport androidx.core.content.FileProvider;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\n\nString tempFilename = \"temporary.apk\";\nbyte[] buffer = new byte[16384];\n\n/* Copy application asset into temporary file */\ntry (InputStream is = getAssets().open(assetName);\n     FileOutputStream fout = openFileOutput(tempFilename, Context.MODE_PRIVATE)) {\n    int n;\n    while ((n=is.read(buffer)) >= 0) {\n        fout.write(buffer, 0, n);\n    }\n}\n\n/* Expose temporary file with FileProvider */\nFile toInstall = new File(this.getFilesDir(), tempFilename);\nUri applicationUri = FileProvider.getUriForFile(this, \"com.example.apkprovider\", toInstall);\n\n/* Create Intent and set data to APK file. */\nIntent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE);\nintent.setData(applicationUri);\nintent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\nstartActivity(intent);\n\n```\nIn the following (good) example, the package is installed using an instance of the `android.content.pm.PackageInstaller` class:\n\n\n```java\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInstaller;\n\nprivate static final String PACKAGE_INSTALLED_ACTION =\n    \"com.example.SESSION_API_PACKAGE_INSTALLED\";\n\n/* Create the package installer and session */\nPackageInstaller packageInstaller = getPackageManager().getPackageInstaller();\nPackageInstaller.SessionParams params =\n    new PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL);\nint sessionId = packageInstaller.createSession(params);\nsession = packageInstaller.openSession(sessionId);\n\n/* Load asset into session */\ntry (OutputStream packageInSession = session.openWrite(\"package\", 0, -1);\n     InputStream is = getAssets().open(assetName)) {\n    byte[] buffer = new byte[16384];\n    int n;\n    while ((n = is.read(buffer)) >= 0) {\n        packageInSession.write(buffer, 0, n);\n    }\n}\n\n/* Create status receiver */\nIntent intent = new Intent(this, InstallApkSessionApi.class);\nintent.setAction(PACKAGE_INSTALLED_ACTION);\nPendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);\nIntentSender statusReceiver = pendingIntent.getIntentSender();\n\n/* Commit the session */\nsession.commit(statusReceiver);\n\n```\n\n## References\n* Android Developers: [Intent.ACTION_INSTALL_PACKAGE](https://developer.android.com/reference/android/content/Intent#ACTION_INSTALL_PACKAGE).\n* Android Developers: [Manifest.permission.REQUEST_INSTALL_PACKAGES](https://developer.android.com/reference/android/Manifest.permission#REQUEST_INSTALL_PACKAGES).\n* Android Developers: [PackageInstaller](https://developer.android.com/reference/android/content/pm/PackageInstaller).\n* Android Developers: [FileProvider](https://developer.android.com/reference/androidx/core/content/FileProvider).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"},"properties":{"tags":["security","external/cwe/cwe-094"],"description":"Creating an intent with a URI pointing to a untrusted file can lead to the installation of an untrusted application.","id":"java/android/arbitrary-apk-installation","kind":"path-problem","name":"Android APK installation","precision":"medium","problem.severity":"error","security-severity":"9.3"}},{"id":"java/potentially-dangerous-function","name":"java/potentially-dangerous-function","shortDescription":{"text":"Use of a potentially dangerous function"},"fullDescription":{"text":"Certain standard library routines are dangerous to call."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of a potentially dangerous function\nThis rule finds calls to methods that are dangerous to use. Currently, it checks for calls to `Thread.stop`.\n\nStopping a thread with `Thread.stop` causes it to receive a `ThreadDeath` exception. That exception propagates up the stack, releasing all monitors that the thread was holding. In some cases the relevant code will be protected by catching the `ThreadDeath` exception and cleaning up, but because the exception can potentially be thrown from so very many locations, it is impractical to catch all such cases. As a result, calling `Thread.stop` is likely to result in corrupt data.\n\n\n## Recommendation\nThe best solution is usually to provide an alternate communication mechanism for the thread that might need to be interrupted early. For example, Oracle gives the following example of using a volatile variable to communicate whether the worker thread should exit:\n\n\n```java\nprivate volatile Thread blinker;\n\npublic void stop() {\n    blinker = null;\n}\n\npublic void run() {\n    Thread thisThread = Thread.currentThread();\n    while (blinker == thisThread) {\n        try {\n            Thread.sleep(interval);\n        } catch (InterruptedException e){\n        }\n        repaint();\n    }\n}\n\n```\nIt is also possible to use `Thread.interrupt` and to catch and handle `InterruptedException` when it occurs. However, it can be difficult to handle an `InterruptedException` everywhere it might occur; for example, the sample code above simply discards the exception rather than actually exiting the thread.\n\nAnother strategy is to use message passing, for example via a `BlockingQueue`. In addition to passing the worker thread its ordinary work via such a message queue, the worker can be asked to exit by a particular kind of message being sent on the queue.\n\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [THI05-J. Do not use Thread.stop() to terminate threads](https://wiki.sei.cmu.edu/confluence/display/java/THI05-J.+Do+not+use+Thread.stop()+to+terminate+threads).\n* Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html).\n* Java API Specification: [Thread.interrupt](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#interrupt()), [BlockingQueue](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/BlockingQueue.html).\n* Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n","markdown":"# Use of a potentially dangerous function\nThis rule finds calls to methods that are dangerous to use. Currently, it checks for calls to `Thread.stop`.\n\nStopping a thread with `Thread.stop` causes it to receive a `ThreadDeath` exception. That exception propagates up the stack, releasing all monitors that the thread was holding. In some cases the relevant code will be protected by catching the `ThreadDeath` exception and cleaning up, but because the exception can potentially be thrown from so very many locations, it is impractical to catch all such cases. As a result, calling `Thread.stop` is likely to result in corrupt data.\n\n\n## Recommendation\nThe best solution is usually to provide an alternate communication mechanism for the thread that might need to be interrupted early. For example, Oracle gives the following example of using a volatile variable to communicate whether the worker thread should exit:\n\n\n```java\nprivate volatile Thread blinker;\n\npublic void stop() {\n    blinker = null;\n}\n\npublic void run() {\n    Thread thisThread = Thread.currentThread();\n    while (blinker == thisThread) {\n        try {\n            Thread.sleep(interval);\n        } catch (InterruptedException e){\n        }\n        repaint();\n    }\n}\n\n```\nIt is also possible to use `Thread.interrupt` and to catch and handle `InterruptedException` when it occurs. However, it can be difficult to handle an `InterruptedException` everywhere it might occur; for example, the sample code above simply discards the exception rather than actually exiting the thread.\n\nAnother strategy is to use message passing, for example via a `BlockingQueue`. In addition to passing the worker thread its ordinary work via such a message queue, the worker can be asked to exit by a particular kind of message being sent on the queue.\n\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [THI05-J. Do not use Thread.stop() to terminate threads](https://wiki.sei.cmu.edu/confluence/display/java/THI05-J.+Do+not+use+Thread.stop()+to+terminate+threads).\n* Java API Specification: [Java Thread Primitive Deprecation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html).\n* Java API Specification: [Thread.interrupt](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#interrupt()), [BlockingQueue](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/BlockingQueue.html).\n* Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-676"],"description":"Certain standard library routines are dangerous to call.","id":"java/potentially-dangerous-function","kind":"problem","name":"Use of a potentially dangerous function","precision":"medium","problem.severity":"warning","security-severity":"10.0"}},{"id":"java/android/sensitive-result-receiver","name":"java/android/sensitive-result-receiver","shortDescription":{"text":"Leaking sensitive information through a ResultReceiver"},"fullDescription":{"text":"Sending sensitive data to a 'ResultReceiver' obtained from an untrusted source can allow malicious actors access to your information."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Leaking sensitive information through a ResultReceiver\nIf a `ResultReceiver` is obtained from an untrusted source, such as an `Intent` received by an exported component, do not send it sensitive data. Otherwise, the information may be leaked to a malicious application.\n\n\n## Recommendation\nDo not send sensitive data to an untrusted `ResultReceiver`.\n\n\n## Example\nIn the following (bad) example, sensitive data is sent to an untrusted `ResultReceiver`.\n\n\n```java\n// BAD: Sensitive data is sent to an untrusted result receiver \nvoid bad(String password) {\n    Intent intent = getIntent();\n    ResultReceiver rec = intent.getParcelableExtra(\"Receiver\");\n    Bundle b = new Bundle();\n    b.putCharSequence(\"pass\", password);\n    rec.send(0, b); \n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n","markdown":"# Leaking sensitive information through a ResultReceiver\nIf a `ResultReceiver` is obtained from an untrusted source, such as an `Intent` received by an exported component, do not send it sensitive data. Otherwise, the information may be leaked to a malicious application.\n\n\n## Recommendation\nDo not send sensitive data to an untrusted `ResultReceiver`.\n\n\n## Example\nIn the following (bad) example, sensitive data is sent to an untrusted `ResultReceiver`.\n\n\n```java\n// BAD: Sensitive data is sent to an untrusted result receiver \nvoid bad(String password) {\n    Intent intent = getIntent();\n    ResultReceiver rec = intent.getParcelableExtra(\"Receiver\");\n    Bundle b = new Bundle();\n    b.putCharSequence(\"pass\", password);\n    rec.send(0, b); \n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n"},"properties":{"tags":["security","external/cwe/cwe-927"],"description":"Sending sensitive data to a 'ResultReceiver' obtained from an untrusted source\n              can allow malicious actors access to your information.","id":"java/android/sensitive-result-receiver","kind":"path-problem","name":"Leaking sensitive information through a ResultReceiver","precision":"medium","problem.severity":"error","security-severity":"8.2"}},{"id":"java/android/sensitive-communication","name":"java/android/sensitive-communication","shortDescription":{"text":"Leaking sensitive information through an implicit Intent"},"fullDescription":{"text":"An Android application uses implicit Intents containing sensitive data in a way that exposes it to arbitrary applications on the device."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Leaking sensitive information through an implicit Intent\nWhen an implicit Intent is used with a method such as `startActivity`, `startService`, or `sendBroadcast`, it may be read by other applications on the device.\n\nThis means that sensitive data in these Intents may be leaked.\n\n\n## Recommendation\nFor `sendBroadcast` methods, a receiver permission may be specified so that only applications with a certain permission may receive the Intent; or a `LocalBroadcastManager` may be used. Otherwise, ensure that Intents containing sensitive data have an explicit receiver class set.\n\n\n## Example\nThe following example shows two ways of broadcasting Intents. In the 'BAD' case, no \"receiver permission\" is specified. In the 'GOOD' case, \"receiver permission\" or \"receiver application\" is specified.\n\n\n```java\npublic void sendBroadcast1(Context context, String token, String refreshToken) \n{\n    {\n        // BAD: broadcast sensitive information to all listeners\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.custom_action\");\n        intent.putExtra(\"token\", token);\n        intent.putExtra(\"refreshToken\", refreshToken);\n        context.sendBroadcast(intent);\n    }\n\n    {\n        // GOOD: broadcast sensitive information only to those with permission\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.custom_action\");\n        intent.putExtra(\"token\", token);\n        intent.putExtra(\"refreshToken\", refreshToken);\n        context.sendBroadcast(intent, \"com.example.user_permission\");\n    }\n\n    {\n        // GOOD: broadcast sensitive information to a specific application\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.custom_action\");\n        intent.setClassName(\"com.example2\", \"com.example2.UserInfoHandler\");\n        intent.putExtra(\"token\", token);\n        intent.putExtra(\"refreshToken\", refreshToken);\n        context.sendBroadcast(intent);\n    }\n}\n```\n\n## References\n* Android Developers: [Security considerations and best practices for sending and receiving broadcasts](https://developer.android.com/guide/components/broadcasts)\n* SonarSource: [Broadcasting intents is security-sensitive](https://rules.sonarsource.com/java/type/Security%20Hotspot/RSPEC-5320)\n* Android Developer Fundamentals: [Restricting broadcasts](https://google-developer-training.github.io/android-developer-fundamentals-course-concepts-v2/unit-3-working-in-the-background/lesson-7-background-tasks/7-3-c-broadcasts/7-3-c-broadcasts.html)\n* Carnegie Mellon University: [DRD03-J. Do not broadcast sensitive information using an implicit intent](https://wiki.sei.cmu.edu/confluence/display/android/DRD03-J.+Do+not+broadcast+sensitive+information+using+an+implicit+intent)\n* Android Developers: [Android LiveData Overview](https://developer.android.com/topic/libraries/architecture/livedata)\n* Oversecured: [Interception of Android implicit intents](https://blog.oversecured.com/Interception-of-Android-implicit-intents/)\n* Common Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n","markdown":"# Leaking sensitive information through an implicit Intent\nWhen an implicit Intent is used with a method such as `startActivity`, `startService`, or `sendBroadcast`, it may be read by other applications on the device.\n\nThis means that sensitive data in these Intents may be leaked.\n\n\n## Recommendation\nFor `sendBroadcast` methods, a receiver permission may be specified so that only applications with a certain permission may receive the Intent; or a `LocalBroadcastManager` may be used. Otherwise, ensure that Intents containing sensitive data have an explicit receiver class set.\n\n\n## Example\nThe following example shows two ways of broadcasting Intents. In the 'BAD' case, no \"receiver permission\" is specified. In the 'GOOD' case, \"receiver permission\" or \"receiver application\" is specified.\n\n\n```java\npublic void sendBroadcast1(Context context, String token, String refreshToken) \n{\n    {\n        // BAD: broadcast sensitive information to all listeners\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.custom_action\");\n        intent.putExtra(\"token\", token);\n        intent.putExtra(\"refreshToken\", refreshToken);\n        context.sendBroadcast(intent);\n    }\n\n    {\n        // GOOD: broadcast sensitive information only to those with permission\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.custom_action\");\n        intent.putExtra(\"token\", token);\n        intent.putExtra(\"refreshToken\", refreshToken);\n        context.sendBroadcast(intent, \"com.example.user_permission\");\n    }\n\n    {\n        // GOOD: broadcast sensitive information to a specific application\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.custom_action\");\n        intent.setClassName(\"com.example2\", \"com.example2.UserInfoHandler\");\n        intent.putExtra(\"token\", token);\n        intent.putExtra(\"refreshToken\", refreshToken);\n        context.sendBroadcast(intent);\n    }\n}\n```\n\n## References\n* Android Developers: [Security considerations and best practices for sending and receiving broadcasts](https://developer.android.com/guide/components/broadcasts)\n* SonarSource: [Broadcasting intents is security-sensitive](https://rules.sonarsource.com/java/type/Security%20Hotspot/RSPEC-5320)\n* Android Developer Fundamentals: [Restricting broadcasts](https://google-developer-training.github.io/android-developer-fundamentals-course-concepts-v2/unit-3-working-in-the-background/lesson-7-background-tasks/7-3-c-broadcasts/7-3-c-broadcasts.html)\n* Carnegie Mellon University: [DRD03-J. Do not broadcast sensitive information using an implicit intent](https://wiki.sei.cmu.edu/confluence/display/android/DRD03-J.+Do+not+broadcast+sensitive+information+using+an+implicit+intent)\n* Android Developers: [Android LiveData Overview](https://developer.android.com/topic/libraries/architecture/livedata)\n* Oversecured: [Interception of Android implicit intents](https://blog.oversecured.com/Interception-of-Android-implicit-intents/)\n* Common Weakness Enumeration: [CWE-927](https://cwe.mitre.org/data/definitions/927.html).\n"},"properties":{"tags":["security","external/cwe/cwe-927"],"description":"An Android application uses implicit Intents containing sensitive data\n              in a way that exposes it to arbitrary applications on the device.","id":"java/android/sensitive-communication","kind":"path-problem","name":"Leaking sensitive information through an implicit Intent","precision":"medium","problem.severity":"warning","security-severity":"8.2"}},{"id":"java/user-controlled-bypass","name":"java/user-controlled-bypass","shortDescription":{"text":"User-controlled bypass of sensitive method"},"fullDescription":{"text":"User-controlled bypassing of sensitive methods may allow attackers to avoid passing through authentication systems."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# User-controlled bypass of sensitive method\nMany Java constructs enable code statements to be executed conditionally, for example `if` statements and `for` statements. If these statements contain important authentication or login code, and the decision about whether to execute this code is based on user-controlled data, it may be possible for an attacker to bypass security systems by preventing this code from executing.\n\n\n## Recommendation\nNever decide whether to authenticate a user based on data that may be controlled by that user. If necessary, ensure that the data is validated extensively when it is input before any authentication checks are performed.\n\nIt is still possible to have a system that \"remembers\" users, thus not requiring the user to login on every interaction. For example, personalization settings can be applied without authentication because this is not sensitive information. However, users should be allowed to take sensitive actions only when they have been fully authenticated.\n\n\n## Example\nThis example shows two ways of deciding whether to authenticate a user. The first way shows a decision that is based on the value of a cookie. Cookies can be easily controlled by the user, and so this allows a user to become authenticated without providing valid credentials. The second, more secure way shows a decision that is based on looking up the user in a security database.\n\n\n```java\npublic boolean doLogin(String user, String password) {\n\tCookie adminCookie = getCookies()[0];\n\n\t// BAD: login is executed only if the value of 'adminCookie' is 'false', \n\t// but 'adminCookie' is controlled by the user\n\tif(adminCookie.getValue()==\"false\")\n\t\treturn login(user, password);\n\t\n\treturn true;\n}\n\npublic boolean doLogin(String user, String password) {\n\tCookie adminCookie = getCookies()[0];\n\t\n\t// GOOD: use server-side information based on the credentials to decide\n\t// whether user has privileges\n\tboolean isAdmin = queryDbForAdminStatus(user, password);\n\tif(!isAdmin)\n\t\treturn login(user, password);\n\t\n\treturn true;\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SEC02-J. Do not base security checks on untrusted sources](https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources).\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n","markdown":"# User-controlled bypass of sensitive method\nMany Java constructs enable code statements to be executed conditionally, for example `if` statements and `for` statements. If these statements contain important authentication or login code, and the decision about whether to execute this code is based on user-controlled data, it may be possible for an attacker to bypass security systems by preventing this code from executing.\n\n\n## Recommendation\nNever decide whether to authenticate a user based on data that may be controlled by that user. If necessary, ensure that the data is validated extensively when it is input before any authentication checks are performed.\n\nIt is still possible to have a system that \"remembers\" users, thus not requiring the user to login on every interaction. For example, personalization settings can be applied without authentication because this is not sensitive information. However, users should be allowed to take sensitive actions only when they have been fully authenticated.\n\n\n## Example\nThis example shows two ways of deciding whether to authenticate a user. The first way shows a decision that is based on the value of a cookie. Cookies can be easily controlled by the user, and so this allows a user to become authenticated without providing valid credentials. The second, more secure way shows a decision that is based on looking up the user in a security database.\n\n\n```java\npublic boolean doLogin(String user, String password) {\n\tCookie adminCookie = getCookies()[0];\n\n\t// BAD: login is executed only if the value of 'adminCookie' is 'false', \n\t// but 'adminCookie' is controlled by the user\n\tif(adminCookie.getValue()==\"false\")\n\t\treturn login(user, password);\n\t\n\treturn true;\n}\n\npublic boolean doLogin(String user, String password) {\n\tCookie adminCookie = getCookies()[0];\n\t\n\t// GOOD: use server-side information based on the credentials to decide\n\t// whether user has privileges\n\tboolean isAdmin = queryDbForAdminStatus(user, password);\n\tif(!isAdmin)\n\t\treturn login(user, password);\n\t\n\treturn true;\n}\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SEC02-J. Do not base security checks on untrusted sources](https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources).\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).\n"},"properties":{"tags":["security","external/cwe/cwe-807","external/cwe/cwe-290"],"description":"User-controlled bypassing of sensitive methods may allow attackers to avoid\n              passing through authentication systems.","id":"java/user-controlled-bypass","kind":"path-problem","name":"User-controlled bypass of sensitive method","precision":"medium","problem.severity":"error","security-severity":"7.8"}},{"id":"java/insecure-smtp-ssl","name":"java/insecure-smtp-ssl","shortDescription":{"text":"Insecure JavaMail SSL Configuration"},"fullDescription":{"text":"Configuring a Java application to use authenticated mail session over SSL without certificate validation makes the session susceptible to a man-in-the-middle attack."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Insecure JavaMail SSL Configuration\nJavaMail is commonly used in Java applications to send emails. There are popular third-party libraries like Apache Commons Email which are built on JavaMail and facilitate integration. Authenticated mail sessions require user credentials and mail sessions can require SSL/TLS authentication. It is a common security vulnerability that host-specific certificate data is not validated or is incorrectly validated. Failing to validate the certificate makes the SSL session susceptible to a man-in-the-middle attack.\n\nThis query checks whether the SSL certificate is validated when credentials are used and SSL is enabled in email communications.\n\nThe query has code for both plain JavaMail invocation and mailing through Apache SimpleMail to make it more comprehensive.\n\n\n## Recommendation\nValidate SSL certificate when sensitive information is sent in email communications.\n\n\n## Example\nThe following two examples show two ways of configuring secure emails through JavaMail or Apache SimpleMail. In the 'BAD' case, credentials are sent in an SSL session without certificate validation. In the 'GOOD' case, the certificate is validated.\n\n\n```java\nimport java.util.Properties;\n\nimport javax.activation.DataSource;\nimport javax.mail.Authenticator;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.PasswordAuthentication;\nimport javax.mail.Session;\n\nimport org.apache.logging.log4j.util.PropertiesUtil;\n\nclass JavaMail {\n    public static void main(String[] args) {\n      // BAD: Don't have server certificate check\n      {\n\t\tfinal Properties properties = PropertiesUtil.getSystemProperties();\n\t\tproperties.put(\"mail.transport.protocol\", \"protocol\");\n\t\tproperties.put(\"mail.smtp.host\", \"hostname\");\n\t\tproperties.put(\"mail.smtp.socketFactory.class\", \"classname\");\n\n\t\tfinal Authenticator authenticator = buildAuthenticator(\"username\", \"password\");\n\t\tif (null != authenticator) {\n\t\t\tproperties.put(\"mail.smtp.auth\", \"true\");\n\t\t}\n\t\tfinal Session session = Session.getInstance(properties, authenticator);\n      }\n\n      // GOOD: Have server certificate check\n      {\n\t\tfinal Properties properties = PropertiesUtil.getSystemProperties();\n\t\tproperties.put(\"mail.transport.protocol\", \"protocol\");\n\t\tproperties.put(\"mail.smtp.host\", \"hostname\");\n\t\tproperties.put(\"mail.smtp.socketFactory.class\", \"classname\");\n\n\t\tfinal Authenticator authenticator = buildAuthenticator(\"username\", \"password\");\n\t\tif (null != authenticator) {\n\t\t\tproperties.put(\"mail.smtp.auth\", \"true\");\n\t\t\tproperties.put(\"mail.smtp.ssl.checkserveridentity\", \"true\");\n\t\t}\n\t\tfinal Session session = Session.getInstance(properties, authenticator);\n      }\n    }\n}\n```\n\n```java\nimport org.apache.commons.mail.DefaultAuthenticator;\nimport org.apache.commons.mail.Email;\nimport org.apache.commons.mail.EmailException;\nimport org.apache.commons.mail.SimpleEmail;\n\nclass SimpleMail {\n    public static void main(String[] args) throws EmailException {\n      // BAD: Don't have setSSLCheckServerIdentity set or set as false    \n      {\n        Email email = new SimpleEmail();\n        email.setHostName(\"hostName\");\n        email.setSmtpPort(25);\n        email.setAuthenticator(new DefaultAuthenticator(\"username\", \"password\"));\n        email.setSSLOnConnect(true);\n        \n        //email.setSSLCheckServerIdentity(false);\n        email.setFrom(\"fromAddress\");\n        email.setSubject(\"subject\");\n        email.setMsg(\"body\");\n        email.addTo(\"toAddress\");\n        email.send();\n      }\n\n      // GOOD: Have setSSLCheckServerIdentity set to true\n      {\n        Email email = new SimpleEmail();\n        email.setHostName(\"hostName\");\n        email.setSmtpPort(25);\n        email.setAuthenticator(new DefaultAuthenticator(\"username\", \"password\"));\n        email.setSSLOnConnect(true);\n\n        email.setSSLCheckServerIdentity(true);\n        email.setFrom(\"fromAddress\");\n        email.setSubject(\"subject\");\n        email.setMsg(\"body\");\n        email.addTo(\"toAddress\");\n        email.send();\n      }\n    }\n}\n```\n\n## References\n* Jakarta Mail: [SSL Notes](https://eclipse-ee4j.github.io/mail/docs/SSLNOTES.txt).\n* Apache Commons: [Email security](https://commons.apache.org/proper/commons-email/userguide.html#Security).\n* Log4j2: [Add support for specifying an SSL configuration for SmtpAppender (CVE-2020-9488)](https://issues.apache.org/jira/browse/LOG4J2-2819).\n* Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n","markdown":"# Insecure JavaMail SSL Configuration\nJavaMail is commonly used in Java applications to send emails. There are popular third-party libraries like Apache Commons Email which are built on JavaMail and facilitate integration. Authenticated mail sessions require user credentials and mail sessions can require SSL/TLS authentication. It is a common security vulnerability that host-specific certificate data is not validated or is incorrectly validated. Failing to validate the certificate makes the SSL session susceptible to a man-in-the-middle attack.\n\nThis query checks whether the SSL certificate is validated when credentials are used and SSL is enabled in email communications.\n\nThe query has code for both plain JavaMail invocation and mailing through Apache SimpleMail to make it more comprehensive.\n\n\n## Recommendation\nValidate SSL certificate when sensitive information is sent in email communications.\n\n\n## Example\nThe following two examples show two ways of configuring secure emails through JavaMail or Apache SimpleMail. In the 'BAD' case, credentials are sent in an SSL session without certificate validation. In the 'GOOD' case, the certificate is validated.\n\n\n```java\nimport java.util.Properties;\n\nimport javax.activation.DataSource;\nimport javax.mail.Authenticator;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.PasswordAuthentication;\nimport javax.mail.Session;\n\nimport org.apache.logging.log4j.util.PropertiesUtil;\n\nclass JavaMail {\n    public static void main(String[] args) {\n      // BAD: Don't have server certificate check\n      {\n\t\tfinal Properties properties = PropertiesUtil.getSystemProperties();\n\t\tproperties.put(\"mail.transport.protocol\", \"protocol\");\n\t\tproperties.put(\"mail.smtp.host\", \"hostname\");\n\t\tproperties.put(\"mail.smtp.socketFactory.class\", \"classname\");\n\n\t\tfinal Authenticator authenticator = buildAuthenticator(\"username\", \"password\");\n\t\tif (null != authenticator) {\n\t\t\tproperties.put(\"mail.smtp.auth\", \"true\");\n\t\t}\n\t\tfinal Session session = Session.getInstance(properties, authenticator);\n      }\n\n      // GOOD: Have server certificate check\n      {\n\t\tfinal Properties properties = PropertiesUtil.getSystemProperties();\n\t\tproperties.put(\"mail.transport.protocol\", \"protocol\");\n\t\tproperties.put(\"mail.smtp.host\", \"hostname\");\n\t\tproperties.put(\"mail.smtp.socketFactory.class\", \"classname\");\n\n\t\tfinal Authenticator authenticator = buildAuthenticator(\"username\", \"password\");\n\t\tif (null != authenticator) {\n\t\t\tproperties.put(\"mail.smtp.auth\", \"true\");\n\t\t\tproperties.put(\"mail.smtp.ssl.checkserveridentity\", \"true\");\n\t\t}\n\t\tfinal Session session = Session.getInstance(properties, authenticator);\n      }\n    }\n}\n```\n\n```java\nimport org.apache.commons.mail.DefaultAuthenticator;\nimport org.apache.commons.mail.Email;\nimport org.apache.commons.mail.EmailException;\nimport org.apache.commons.mail.SimpleEmail;\n\nclass SimpleMail {\n    public static void main(String[] args) throws EmailException {\n      // BAD: Don't have setSSLCheckServerIdentity set or set as false    \n      {\n        Email email = new SimpleEmail();\n        email.setHostName(\"hostName\");\n        email.setSmtpPort(25);\n        email.setAuthenticator(new DefaultAuthenticator(\"username\", \"password\"));\n        email.setSSLOnConnect(true);\n        \n        //email.setSSLCheckServerIdentity(false);\n        email.setFrom(\"fromAddress\");\n        email.setSubject(\"subject\");\n        email.setMsg(\"body\");\n        email.addTo(\"toAddress\");\n        email.send();\n      }\n\n      // GOOD: Have setSSLCheckServerIdentity set to true\n      {\n        Email email = new SimpleEmail();\n        email.setHostName(\"hostName\");\n        email.setSmtpPort(25);\n        email.setAuthenticator(new DefaultAuthenticator(\"username\", \"password\"));\n        email.setSSLOnConnect(true);\n\n        email.setSSLCheckServerIdentity(true);\n        email.setFrom(\"fromAddress\");\n        email.setSubject(\"subject\");\n        email.setMsg(\"body\");\n        email.addTo(\"toAddress\");\n        email.send();\n      }\n    }\n}\n```\n\n## References\n* Jakarta Mail: [SSL Notes](https://eclipse-ee4j.github.io/mail/docs/SSLNOTES.txt).\n* Apache Commons: [Email security](https://commons.apache.org/proper/commons-email/userguide.html#Security).\n* Log4j2: [Add support for specifying an SSL configuration for SmtpAppender (CVE-2020-9488)](https://issues.apache.org/jira/browse/LOG4J2-2819).\n* Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).\n"},"properties":{"tags":["security","external/cwe/cwe-297"],"description":"Configuring a Java application to use authenticated mail session\n              over SSL without certificate validation\n              makes the session susceptible to a man-in-the-middle attack.","id":"java/insecure-smtp-ssl","kind":"problem","name":"Insecure JavaMail SSL Configuration","precision":"medium","problem.severity":"warning","security-severity":"5.9"}},{"id":"java/toctou-race-condition","name":"java/toctou-race-condition","shortDescription":{"text":"Time-of-check time-of-use race condition"},"fullDescription":{"text":"Using a resource after an unsynchronized state check can lead to a race condition, if the state may be changed between the check and use."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Time-of-check time-of-use race condition\nOften it is necessary to check the state of a resource before using it. If the resource is accessed concurrently, then the check and the use need to be performed atomically, otherwise the state of the resource may change between the check and the use. This can lead to a \"time-of-check/time-of-use\" (TOCTOU) race condition.\n\nIn Java, classes may present state inspection methods and operation methods which are synchronized. This prevents multiple threads from executing those methods simultaneously, but it does not prevent a state change in between separate method invocations.\n\n\n## Recommendation\nWhen calling a series of methods which require a consistent view of an object, make sure to synchronize on a monitor that will prevent any other access to the object during your operations.\n\nIf the class that you are using has a well-designed interface, then synchronizing on the object itself will prevent its state being changed inappropriately.\n\n\n## Example\nThe following example shows a resource which has a readiness state, and an action that is only valid if the resource is ready.\n\nIn the bad case, the caller checks the readiness state and then acts, but does not synchronize around the two calls, so the readiness state may be changed by another thread.\n\nIn the good case, the caller jointly synchronizes the check and the use on the resource, so no other thread can modify the state before the use.\n\n\n```java\nclass Resource {\n\tpublic synchronized boolean isReady() { ... }\n\n\tpublic synchronized void setReady(boolean ready) { ... }\n\t\n\tpublic synchronized void act() { \n\t\tif (!isReady())\n\t\t\tthrow new IllegalStateException();\n\t\t...\n\t}\n}\n\t\npublic synchronized void bad(Resource r) {\n\tif (r.isReady()) {\n\t\t// r might no longer be ready, another thread might\n\t\t// have called setReady(false)\n\t\tr.act();\n\t}\n}\n\npublic synchronized void good(Resource r) {\n\tsynchronized(r) {\n\t\tif (r.isReady()) {\n\t\t\tr.act();\n\t\t}\n\t}\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-367](https://cwe.mitre.org/data/definitions/367.html).\n","markdown":"# Time-of-check time-of-use race condition\nOften it is necessary to check the state of a resource before using it. If the resource is accessed concurrently, then the check and the use need to be performed atomically, otherwise the state of the resource may change between the check and the use. This can lead to a \"time-of-check/time-of-use\" (TOCTOU) race condition.\n\nIn Java, classes may present state inspection methods and operation methods which are synchronized. This prevents multiple threads from executing those methods simultaneously, but it does not prevent a state change in between separate method invocations.\n\n\n## Recommendation\nWhen calling a series of methods which require a consistent view of an object, make sure to synchronize on a monitor that will prevent any other access to the object during your operations.\n\nIf the class that you are using has a well-designed interface, then synchronizing on the object itself will prevent its state being changed inappropriately.\n\n\n## Example\nThe following example shows a resource which has a readiness state, and an action that is only valid if the resource is ready.\n\nIn the bad case, the caller checks the readiness state and then acts, but does not synchronize around the two calls, so the readiness state may be changed by another thread.\n\nIn the good case, the caller jointly synchronizes the check and the use on the resource, so no other thread can modify the state before the use.\n\n\n```java\nclass Resource {\n\tpublic synchronized boolean isReady() { ... }\n\n\tpublic synchronized void setReady(boolean ready) { ... }\n\t\n\tpublic synchronized void act() { \n\t\tif (!isReady())\n\t\t\tthrow new IllegalStateException();\n\t\t...\n\t}\n}\n\t\npublic synchronized void bad(Resource r) {\n\tif (r.isReady()) {\n\t\t// r might no longer be ready, another thread might\n\t\t// have called setReady(false)\n\t\tr.act();\n\t}\n}\n\npublic synchronized void good(Resource r) {\n\tsynchronized(r) {\n\t\tif (r.isReady()) {\n\t\t\tr.act();\n\t\t}\n\t}\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-367](https://cwe.mitre.org/data/definitions/367.html).\n"},"properties":{"tags":["security","external/cwe/cwe-367"],"description":"Using a resource after an unsynchronized state check can lead to a race condition,\n              if the state may be changed between the check and use.","id":"java/toctou-race-condition","kind":"problem","name":"Time-of-check time-of-use race condition","precision":"medium","problem.severity":"warning","security-severity":"7.7"}},{"id":"java/potentially-weak-cryptographic-algorithm","name":"java/potentially-weak-cryptographic-algorithm","shortDescription":{"text":"Use of a potentially broken or risky cryptographic algorithm"},"fullDescription":{"text":"Using broken or weak cryptographic algorithms can allow an attacker to compromise security."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of a potentially broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048. Do not use the ECB encryption mode since it is vulnerable to replay and other attacks.\n\n\n## Example\nThe following code shows an example of using a java `Cipher` to encrypt some data. When creating a `Cipher` instance, you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```java\n// BAD: DES is a weak algorithm \nCipher des = Cipher.getInstance(\"DES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n\nbyte[] encrypted = cipher.doFinal(input.getBytes(\"UTF-8\"));\n\n// ...\n\n// GOOD: AES is a strong algorithm\nCipher aes = Cipher.getInstance(\"AES\");\n\n// ...\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n","markdown":"# Use of a potentially broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048. Do not use the ECB encryption mode since it is vulnerable to replay and other attacks.\n\n\n## Example\nThe following code shows an example of using a java `Cipher` to encrypt some data. When creating a `Cipher` instance, you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```java\n// BAD: DES is a weak algorithm \nCipher des = Cipher.getInstance(\"DES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n\nbyte[] encrypted = cipher.doFinal(input.getBytes(\"UTF-8\"));\n\n// ...\n\n// GOOD: AES is a strong algorithm\nCipher aes = Cipher.getInstance(\"AES\");\n\n// ...\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n"},"properties":{"tags":["security","external/cwe/cwe-327","external/cwe/cwe-328"],"description":"Using broken or weak cryptographic algorithms can allow an attacker to compromise security.","id":"java/potentially-weak-cryptographic-algorithm","kind":"path-problem","name":"Use of a potentially broken or risky cryptographic algorithm","precision":"medium","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/trust-boundary-violation","name":"java/trust-boundary-violation","shortDescription":{"text":"Trust boundary violation"},"fullDescription":{"text":"Modifying the HTTP session attributes based on data from an untrusted source may violate a trust boundary."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Trust boundary violation\nA trust boundary violation occurs when a value is passed from a less trusted context to a more trusted context.\n\nFor example, a value that is generated by a less trusted source, such as a user, may be passed to a more trusted source, such as a system process. If the less trusted source is malicious, then the value may be crafted to exploit the more trusted source.\n\nTrust boundary violations are often caused by a failure to validate input. For example, if a web application accepts a cookie from a user, then the application should validate the cookie before using it. If the cookie is not validated, then the user may be able to craft a malicious cookie that exploits the application.\n\n\n## Recommendation\nTo maintain a trust boundary, validate data from less trusted sources before use.\n\n\n## Example\nIn the first (bad) example, the server accepts a parameter from the user, then uses it to set the username without validation.\n\n\n```java\npublic void doGet(HttpServletRequest request, HttpServletResponse response) {\n    String username = request.getParameter(\"username\");\n\n    // BAD: The input is written to the session without being sanitized.\n    request.getSession().setAttribute(\"username\", username);\n}\n```\nIn the second (good) example, the server validates the parameter from the user, then uses it to set the username.\n\n\n```java\npublic void doGet(HttpServletRequest request, HttpServletResponse response) {\n    String username = request.getParameter(\"username\");\n\n    if (validator.isValidInput(\"HTTP parameter\", username, \"username\", 20, false)) {\n        // GOOD: The input is sanitized before being written to the session.\n        request.getSession().setAttribute(\"username\", username);\n    }\n}\n```\n\n## References\n* Wikipedia: [Trust boundary](http://en.wikipedia.org/wiki/Trust_boundary).\n* Common Weakness Enumeration: [CWE-501](https://cwe.mitre.org/data/definitions/501.html).\n","markdown":"# Trust boundary violation\nA trust boundary violation occurs when a value is passed from a less trusted context to a more trusted context.\n\nFor example, a value that is generated by a less trusted source, such as a user, may be passed to a more trusted source, such as a system process. If the less trusted source is malicious, then the value may be crafted to exploit the more trusted source.\n\nTrust boundary violations are often caused by a failure to validate input. For example, if a web application accepts a cookie from a user, then the application should validate the cookie before using it. If the cookie is not validated, then the user may be able to craft a malicious cookie that exploits the application.\n\n\n## Recommendation\nTo maintain a trust boundary, validate data from less trusted sources before use.\n\n\n## Example\nIn the first (bad) example, the server accepts a parameter from the user, then uses it to set the username without validation.\n\n\n```java\npublic void doGet(HttpServletRequest request, HttpServletResponse response) {\n    String username = request.getParameter(\"username\");\n\n    // BAD: The input is written to the session without being sanitized.\n    request.getSession().setAttribute(\"username\", username);\n}\n```\nIn the second (good) example, the server validates the parameter from the user, then uses it to set the username.\n\n\n```java\npublic void doGet(HttpServletRequest request, HttpServletResponse response) {\n    String username = request.getParameter(\"username\");\n\n    if (validator.isValidInput(\"HTTP parameter\", username, \"username\", 20, false)) {\n        // GOOD: The input is sanitized before being written to the session.\n        request.getSession().setAttribute(\"username\", username);\n    }\n}\n```\n\n## References\n* Wikipedia: [Trust boundary](http://en.wikipedia.org/wiki/Trust_boundary).\n* Common Weakness Enumeration: [CWE-501](https://cwe.mitre.org/data/definitions/501.html).\n"},"properties":{"tags":["security","external/cwe/cwe-501"],"description":"Modifying the HTTP session attributes based on data from an untrusted source may violate a trust boundary.","id":"java/trust-boundary-violation","kind":"path-problem","name":"Trust boundary violation","precision":"medium","problem.severity":"error","security-severity":"8.8"}},{"id":"java/unsafe-cert-trust","name":"java/unsafe-cert-trust","shortDescription":{"text":"Unsafe certificate trust"},"fullDescription":{"text":"SSLSocket/SSLEngine ignores all SSL certificate validation errors when establishing an HTTPS connection, thereby making the app vulnerable to man-in-the-middle attacks."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unsafe certificate trust\nJava offers two mechanisms for SSL authentication - trust manager and hostname verifier (the later is checked by the `java/insecure-hostname-verifier` query). The trust manager validates the peer's certificate chain while hostname verification establishes that the hostname in the URL matches the hostname in the server's identification.\n\nWhen `SSLSocket` or `SSLEngine` are created without a secure `setEndpointIdentificationAlgorithm`, hostname verification is disabled by default.\n\nThis query checks whether `setEndpointIdentificationAlgorithm` is missing, thereby making the application vulnerable to man-in-the-middle attacks. The query also covers insecure configurations of `com.rabbitmq.client.ConnectionFactory`.\n\n\n## Recommendation\nValidate SSL certificates in SSL authentication.\n\n\n## Example\nThe following two examples show two ways of configuring SSLSocket/SSLEngine. In the 'BAD' case, `setEndpointIdentificationAlgorithm` is not called, thus no hostname verification takes place. In the 'GOOD' case, `setEndpointIdentificationAlgorithm` is called.\n\n\n```java\npublic static void main(String[] args) {\n\n\t{\n\t\tSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\t\tSSLEngine sslEngine = sslContext.createSSLEngine();\n\t\tSSLParameters sslParameters = sslEngine.getSSLParameters();\n\t\tsslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\"); //GOOD: Set a valid endpointIdentificationAlgorithm for SSL engine to trigger hostname verification\n\t\tsslEngine.setSSLParameters(sslParameters);\n\t}\n\n\t{\n\t\tSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\t\tSSLEngine sslEngine = sslContext.createSSLEngine();  //BAD: No endpointIdentificationAlgorithm set\n\t}\n\n\t{\n\t\tSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\t\tfinal SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n\t\tSSLSocket socket = (SSLSocket) socketFactory.createSocket(\"www.example.com\", 443); \n\t\tSSLParameters sslParameters = sslEngine.getSSLParameters();\n\t\tsslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\"); //GOOD: Set a valid endpointIdentificationAlgorithm for SSL socket to trigger hostname verification\n\t\tsocket.setSSLParameters(sslParameters);\n\t}\n\n\t{\n\t\tcom.rabbitmq.client.ConnectionFactory connectionFactory = new com.rabbitmq.client.ConnectionFactory();\n\t\tconnectionFactory.useSslProtocol();\n\t\tconnectionFactory.enableHostnameVerification();  //GOOD: Enable hostname verification for rabbitmq ConnectionFactory\n\t}\n\n\t{\n\t\tcom.rabbitmq.client.ConnectionFactory connectionFactory = new com.rabbitmq.client.ConnectionFactory();\n\t\tconnectionFactory.useSslProtocol(); //BAD: Hostname verification for rabbitmq ConnectionFactory is not enabled\n\t}\n}\n```\n\n## References\n* [Testing Endpoint Identify Verification (MSTG-NETWORK-3)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05g-Testing-Network-Communication.md).\n* [SSLParameters.setEndpointIdentificationAlgorithm documentation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLParameters.html#setEndpointIdentificationAlgorithm(java.lang.String)).\n* RabbitMQ: [ConnectionFactory.enableHostnameVerification documentation](https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/ConnectionFactory.html#enableHostnameVerification()).\n* RabbitMQ: [Using TLS in the Java Client](https://www.rabbitmq.com/ssl.html#java-client).\n* [CVE-2018-17187: Apache Qpid Proton-J transport issue with hostname verification](https://github.com/advisories/GHSA-xvch-r4wf-h8w9).\n* [CVE-2018-8034: Apache Tomcat - host name verification when using TLS with the WebSocket client](https://github.com/advisories/GHSA-46j3-r4pj-4835).\n* [CVE-2018-11087: Pivotal Spring AMQP vulnerability due to lack of hostname validation](https://github.com/advisories/GHSA-w4g2-9hj6-5472).\n* [CVE-2018-11775: TLS hostname verification issue when using the Apache ActiveMQ Client](https://github.com/advisories/GHSA-m9w8-v359-9ffr).\n* Common Weakness Enumeration: [CWE-273](https://cwe.mitre.org/data/definitions/273.html).\n","markdown":"# Unsafe certificate trust\nJava offers two mechanisms for SSL authentication - trust manager and hostname verifier (the later is checked by the `java/insecure-hostname-verifier` query). The trust manager validates the peer's certificate chain while hostname verification establishes that the hostname in the URL matches the hostname in the server's identification.\n\nWhen `SSLSocket` or `SSLEngine` are created without a secure `setEndpointIdentificationAlgorithm`, hostname verification is disabled by default.\n\nThis query checks whether `setEndpointIdentificationAlgorithm` is missing, thereby making the application vulnerable to man-in-the-middle attacks. The query also covers insecure configurations of `com.rabbitmq.client.ConnectionFactory`.\n\n\n## Recommendation\nValidate SSL certificates in SSL authentication.\n\n\n## Example\nThe following two examples show two ways of configuring SSLSocket/SSLEngine. In the 'BAD' case, `setEndpointIdentificationAlgorithm` is not called, thus no hostname verification takes place. In the 'GOOD' case, `setEndpointIdentificationAlgorithm` is called.\n\n\n```java\npublic static void main(String[] args) {\n\n\t{\n\t\tSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\t\tSSLEngine sslEngine = sslContext.createSSLEngine();\n\t\tSSLParameters sslParameters = sslEngine.getSSLParameters();\n\t\tsslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\"); //GOOD: Set a valid endpointIdentificationAlgorithm for SSL engine to trigger hostname verification\n\t\tsslEngine.setSSLParameters(sslParameters);\n\t}\n\n\t{\n\t\tSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\t\tSSLEngine sslEngine = sslContext.createSSLEngine();  //BAD: No endpointIdentificationAlgorithm set\n\t}\n\n\t{\n\t\tSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\t\tfinal SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n\t\tSSLSocket socket = (SSLSocket) socketFactory.createSocket(\"www.example.com\", 443); \n\t\tSSLParameters sslParameters = sslEngine.getSSLParameters();\n\t\tsslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\"); //GOOD: Set a valid endpointIdentificationAlgorithm for SSL socket to trigger hostname verification\n\t\tsocket.setSSLParameters(sslParameters);\n\t}\n\n\t{\n\t\tcom.rabbitmq.client.ConnectionFactory connectionFactory = new com.rabbitmq.client.ConnectionFactory();\n\t\tconnectionFactory.useSslProtocol();\n\t\tconnectionFactory.enableHostnameVerification();  //GOOD: Enable hostname verification for rabbitmq ConnectionFactory\n\t}\n\n\t{\n\t\tcom.rabbitmq.client.ConnectionFactory connectionFactory = new com.rabbitmq.client.ConnectionFactory();\n\t\tconnectionFactory.useSslProtocol(); //BAD: Hostname verification for rabbitmq ConnectionFactory is not enabled\n\t}\n}\n```\n\n## References\n* [Testing Endpoint Identify Verification (MSTG-NETWORK-3)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05g-Testing-Network-Communication.md).\n* [SSLParameters.setEndpointIdentificationAlgorithm documentation](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLParameters.html#setEndpointIdentificationAlgorithm(java.lang.String)).\n* RabbitMQ: [ConnectionFactory.enableHostnameVerification documentation](https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/ConnectionFactory.html#enableHostnameVerification()).\n* RabbitMQ: [Using TLS in the Java Client](https://www.rabbitmq.com/ssl.html#java-client).\n* [CVE-2018-17187: Apache Qpid Proton-J transport issue with hostname verification](https://github.com/advisories/GHSA-xvch-r4wf-h8w9).\n* [CVE-2018-8034: Apache Tomcat - host name verification when using TLS with the WebSocket client](https://github.com/advisories/GHSA-46j3-r4pj-4835).\n* [CVE-2018-11087: Pivotal Spring AMQP vulnerability due to lack of hostname validation](https://github.com/advisories/GHSA-w4g2-9hj6-5472).\n* [CVE-2018-11775: TLS hostname verification issue when using the Apache ActiveMQ Client](https://github.com/advisories/GHSA-m9w8-v359-9ffr).\n* Common Weakness Enumeration: [CWE-273](https://cwe.mitre.org/data/definitions/273.html).\n"},"properties":{"tags":["security","external/cwe/cwe-273"],"description":"SSLSocket/SSLEngine ignores all SSL certificate validation\n              errors when establishing an HTTPS connection, thereby making\n              the app vulnerable to man-in-the-middle attacks.","id":"java/unsafe-cert-trust","kind":"problem","name":"Unsafe certificate trust","precision":"medium","problem.severity":"warning","security-severity":"9.8"}},{"id":"java/android/cleartext-storage-shared-prefs","name":"java/android/cleartext-storage-shared-prefs","shortDescription":{"text":"Cleartext storage of sensitive information using `SharedPreferences` on Android"},"fullDescription":{"text":"Cleartext Storage of Sensitive Information using SharedPreferences on Android allows access for users with root privileges or unexpected exposure from chained vulnerabilities."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Cleartext storage of sensitive information using `SharedPreferences` on Android\n`SharedPreferences` is an Android API that stores application preferences using simple sets of data values. It allows you to easily save, alter, and retrieve the values stored in a user's profile. However, sensitive information should not be saved in cleartext. Otherwise it can be accessed by any process or user in rooted devices, or can be disclosed through chained vulnerabilities, like unexpected access to the private storage through exposed components.\n\n\n## Recommendation\nUse the `EncryptedSharedPreferences` API or other encryption algorithms for storing sensitive information.\n\n\n## Example\nIn the first example, sensitive user information is stored in cleartext.\n\nIn the second and third examples, the code encrypts sensitive information before saving it to the device.\n\n\n```java\npublic void testSetSharedPrefs(Context context, String name, String password)\n{\n\t{\n\t\t// BAD - sensitive information saved in cleartext.\n\t\tSharedPreferences sharedPrefs = context.getSharedPreferences(\"user_prefs\", Context.MODE_PRIVATE);\n\t\tEditor editor = sharedPrefs.edit();\n\t\teditor.putString(\"name\", name);\n\t\teditor.putString(\"password\", password);\n\t\teditor.commit();\n\t}\n\n\t{\n\t\t// GOOD - save sensitive information encrypted with a custom method.\n\t\tSharedPreferences sharedPrefs = context.getSharedPreferences(\"user_prefs\", Context.MODE_PRIVATE);\n\t\tEditor editor = sharedPrefs.edit();\n\t\teditor.putString(\"name\", encrypt(name));\n\t\teditor.putString(\"password\", encrypt(password));\n\t\teditor.commit();\n\t}\n\n\t{\n\t\t// GOOD - sensitive information saved using the built-in `EncryptedSharedPreferences` class in androidx.\n\t\tMasterKey masterKey = new MasterKey.Builder(context, MasterKey.DEFAULT_MASTER_KEY_ALIAS)\n\t\t\t.setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n\t\t\t.build();\n\n\t\tSharedPreferences sharedPreferences = EncryptedSharedPreferences.create(\n\t\t\tcontext,\n\t\t\t\"secret_shared_prefs\",\n\t\t\tmasterKey,\n\t\t\tEncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n\t\t\tEncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM);\n\n\t\tSharedPreferences.Editor editor = sharedPreferences.edit();\n\t\teditor.putString(\"name\", name);\n\t\teditor.putString(\"password\", password);\n\t\teditor.commit();\n\t}\n}\n\nprivate static String encrypt(String cleartext) throws Exception {\n\t// Use an encryption or hashing algorithm in real world. The demo below just returns its\n\t// hash.\n\tMessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n\tbyte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n\tString encoded = Base64.getEncoder().encodeToString(hash);\n\treturn encoded;\n}\n\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n* ProAndroidDev: [Encrypted Preferences in Android](https://proandroiddev.com/encrypted-preferences-in-android-af57a89af7c8)\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n","markdown":"# Cleartext storage of sensitive information using `SharedPreferences` on Android\n`SharedPreferences` is an Android API that stores application preferences using simple sets of data values. It allows you to easily save, alter, and retrieve the values stored in a user's profile. However, sensitive information should not be saved in cleartext. Otherwise it can be accessed by any process or user in rooted devices, or can be disclosed through chained vulnerabilities, like unexpected access to the private storage through exposed components.\n\n\n## Recommendation\nUse the `EncryptedSharedPreferences` API or other encryption algorithms for storing sensitive information.\n\n\n## Example\nIn the first example, sensitive user information is stored in cleartext.\n\nIn the second and third examples, the code encrypts sensitive information before saving it to the device.\n\n\n```java\npublic void testSetSharedPrefs(Context context, String name, String password)\n{\n\t{\n\t\t// BAD - sensitive information saved in cleartext.\n\t\tSharedPreferences sharedPrefs = context.getSharedPreferences(\"user_prefs\", Context.MODE_PRIVATE);\n\t\tEditor editor = sharedPrefs.edit();\n\t\teditor.putString(\"name\", name);\n\t\teditor.putString(\"password\", password);\n\t\teditor.commit();\n\t}\n\n\t{\n\t\t// GOOD - save sensitive information encrypted with a custom method.\n\t\tSharedPreferences sharedPrefs = context.getSharedPreferences(\"user_prefs\", Context.MODE_PRIVATE);\n\t\tEditor editor = sharedPrefs.edit();\n\t\teditor.putString(\"name\", encrypt(name));\n\t\teditor.putString(\"password\", encrypt(password));\n\t\teditor.commit();\n\t}\n\n\t{\n\t\t// GOOD - sensitive information saved using the built-in `EncryptedSharedPreferences` class in androidx.\n\t\tMasterKey masterKey = new MasterKey.Builder(context, MasterKey.DEFAULT_MASTER_KEY_ALIAS)\n\t\t\t.setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n\t\t\t.build();\n\n\t\tSharedPreferences sharedPreferences = EncryptedSharedPreferences.create(\n\t\t\tcontext,\n\t\t\t\"secret_shared_prefs\",\n\t\t\tmasterKey,\n\t\t\tEncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n\t\t\tEncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM);\n\n\t\tSharedPreferences.Editor editor = sharedPreferences.edit();\n\t\teditor.putString(\"name\", name);\n\t\teditor.putString(\"password\", password);\n\t\teditor.commit();\n\t}\n}\n\nprivate static String encrypt(String cleartext) throws Exception {\n\t// Use an encryption or hashing algorithm in real world. The demo below just returns its\n\t// hash.\n\tMessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n\tbyte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n\tString encoded = Base64.getEncoder().encodeToString(hash);\n\treturn encoded;\n}\n\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n* ProAndroidDev: [Encrypted Preferences in Android](https://proandroiddev.com/encrypted-preferences-in-android-af57a89af7c8)\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"},"properties":{"tags":["security","external/cwe/cwe-312"],"description":"Cleartext Storage of Sensitive Information using\n              SharedPreferences on Android allows access for users with root\n              privileges or unexpected exposure from chained vulnerabilities.","id":"java/android/cleartext-storage-shared-prefs","kind":"problem","name":"Cleartext storage of sensitive information using `SharedPreferences` on Android","precision":"medium","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/android/cleartext-storage-filesystem","name":"java/android/cleartext-storage-filesystem","shortDescription":{"text":"Cleartext storage of sensitive information in the Android filesystem"},"fullDescription":{"text":"Cleartext storage of sensitive information in the Android filesystem allows access for users with root privileges or unexpected exposure from chained vulnerabilities."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Cleartext storage of sensitive information in the Android filesystem\nAndroid applications with the appropriate permissions can write files either to the device external storage or the application internal storage, depending on the application's needs. However, sensitive information should not be saved in cleartext. Otherwise it can be accessed by any process or user in rooted devices, or can be disclosed through chained vulnerabilities, like unexpected access to the private storage through exposed components.\n\n\n## Recommendation\nConsider using the `EncryptedFile` class to work with files containing sensitive data. Alternatively, use encryption algorithms to encrypt the sensitive data being stored.\n\n\n## Example\nIn the first example, sensitive user information is stored in cleartext using a local file.\n\nIn the second and third examples, the code encrypts sensitive information before saving it to the filesystem.\n\n\n```java\npublic void fileSystemStorageUnsafe(String name, String password) {\n\t// BAD - sensitive data stored in cleartext\n    FileWriter fw = new FileWriter(\"some_file.txt\");\n    fw.write(name + \":\" + password);\n    fw.close();\n}\n\npublic void filesystemStorageEncryptedFileSafe(Context context, String name, String password) {\n\t// GOOD - the whole file is encrypted with androidx.security.crypto.EncryptedFile\n    File file = new File(\"some_file.txt\");\n    String masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);\n    EncryptedFile encryptedFile = new EncryptedFile.Builder(\n        file,\n        context,\n        masterKeyAlias,\n        EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB\n    ).build();\n\tFileOutputStream encryptedOutputStream = encryptedFile.openFileOutput();\n\tencryptedOutputStream.write(name + \":\" + password);\n}\n\npublic void fileSystemStorageSafe(String name, String password) {\n\t// GOOD - sensitive data is encrypted using a custom method\n    FileWriter fw = new FileWriter(\"some_file.txt\");\n    fw.write(name + \":\" + encrypt(password));\n    fw.close();\n}\n\nprivate static String encrypt(String cleartext) {\n    // Use an encryption or strong hashing algorithm in the real world.\n    // The example below just returns a SHA-256 hash.\n    MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n    byte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n    String encoded = Base64.getEncoder().encodeToString(hash);\n    return encoded;\n}\n\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n* Android Developers: [EncryptedFile](https://developer.android.com/reference/androidx/security/crypto/EncryptedFile)\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n","markdown":"# Cleartext storage of sensitive information in the Android filesystem\nAndroid applications with the appropriate permissions can write files either to the device external storage or the application internal storage, depending on the application's needs. However, sensitive information should not be saved in cleartext. Otherwise it can be accessed by any process or user in rooted devices, or can be disclosed through chained vulnerabilities, like unexpected access to the private storage through exposed components.\n\n\n## Recommendation\nConsider using the `EncryptedFile` class to work with files containing sensitive data. Alternatively, use encryption algorithms to encrypt the sensitive data being stored.\n\n\n## Example\nIn the first example, sensitive user information is stored in cleartext using a local file.\n\nIn the second and third examples, the code encrypts sensitive information before saving it to the filesystem.\n\n\n```java\npublic void fileSystemStorageUnsafe(String name, String password) {\n\t// BAD - sensitive data stored in cleartext\n    FileWriter fw = new FileWriter(\"some_file.txt\");\n    fw.write(name + \":\" + password);\n    fw.close();\n}\n\npublic void filesystemStorageEncryptedFileSafe(Context context, String name, String password) {\n\t// GOOD - the whole file is encrypted with androidx.security.crypto.EncryptedFile\n    File file = new File(\"some_file.txt\");\n    String masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);\n    EncryptedFile encryptedFile = new EncryptedFile.Builder(\n        file,\n        context,\n        masterKeyAlias,\n        EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB\n    ).build();\n\tFileOutputStream encryptedOutputStream = encryptedFile.openFileOutput();\n\tencryptedOutputStream.write(name + \":\" + password);\n}\n\npublic void fileSystemStorageSafe(String name, String password) {\n\t// GOOD - sensitive data is encrypted using a custom method\n    FileWriter fw = new FileWriter(\"some_file.txt\");\n    fw.write(name + \":\" + encrypt(password));\n    fw.close();\n}\n\nprivate static String encrypt(String cleartext) {\n    // Use an encryption or strong hashing algorithm in the real world.\n    // The example below just returns a SHA-256 hash.\n    MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n    byte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n    String encoded = Base64.getEncoder().encodeToString(hash);\n    return encoded;\n}\n\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n* Android Developers: [EncryptedFile](https://developer.android.com/reference/androidx/security/crypto/EncryptedFile)\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"},"properties":{"tags":["security","external/cwe/cwe-312"],"description":"Cleartext storage of sensitive information in the Android filesystem\n              allows access for users with root privileges or unexpected exposure\n              from chained vulnerabilities.","id":"java/android/cleartext-storage-filesystem","kind":"problem","name":"Cleartext storage of sensitive information in the Android filesystem","precision":"medium","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/android/cleartext-storage-database","name":"java/android/cleartext-storage-database","shortDescription":{"text":"Cleartext storage of sensitive information using a local database on Android"},"fullDescription":{"text":"Cleartext Storage of Sensitive Information using a local database on Android allows access for users with root privileges or unexpected exposure from chained vulnerabilities."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Cleartext storage of sensitive information using a local database on Android\nSQLite is a lightweight database engine commonly used in Android devices to store data. By itself, SQLite does not offer any encryption mechanism by default and stores all data in cleartext, which introduces a risk if sensitive data like credentials, authentication tokens or personal identifiable information (PII) are directly stored in a SQLite database. The information could be accessed by any process or user in rooted devices, or can be disclosed through chained vulnerabilities, like unexpected access to the private storage through exposed components.\n\n\n## Recommendation\nUse `SQLCipher` or similar libraries to add encryption capabilities to SQLite. Alternatively, encrypt sensitive data using cryptographically secure algorithms before storing it in the database.\n\n\n## Example\nIn the first example, sensitive user information is stored in cleartext.\n\nIn the second and third examples, the code encrypts sensitive information before saving it to the database.\n\n\n```java\npublic void sqliteStorageUnsafe(Context ctx, String name, String password) {\n\t// BAD - sensitive information saved in cleartext.\n\tSQLiteDatabase db = ctx.openOrCreateDatabase(\"test\", Context.MODE_PRIVATE, null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name, password});\n}\n\npublic void sqliteStorageSafe(Context ctx, String name, String password) {\n\t// GOOD - sensitive information encrypted with a custom method.\n\tSQLiteDatabase db = ctx.openOrCreateDatabase(\"test\", Context.MODE_PRIVATE, null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name, encrypt(password)});\n}\n\npublic void sqlCipherStorageSafe(String name, String password, String databasePassword) {\n\t// GOOD - sensitive information saved using SQLCipher.\n\tnet.sqlcipher.database.SQLiteDatabase db = \n\t\tnet.sqlcipher.database.SQLiteDatabase.openOrCreateDatabase(\"test\", databasePassword, null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name, password});\n}\n\nprivate static String encrypt(String cleartext) {\n    // Use an encryption or strong hashing algorithm in the real world.\n    // The example below just returns a SHA-256 hash.\n    MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n    byte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n    String encoded = Base64.getEncoder().encodeToString(hash);\n    return encoded;\n}\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n* SQLCipher: [Android Application Integration](https://www.zetetic.net/sqlcipher/sqlcipher-for-android/)\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n","markdown":"# Cleartext storage of sensitive information using a local database on Android\nSQLite is a lightweight database engine commonly used in Android devices to store data. By itself, SQLite does not offer any encryption mechanism by default and stores all data in cleartext, which introduces a risk if sensitive data like credentials, authentication tokens or personal identifiable information (PII) are directly stored in a SQLite database. The information could be accessed by any process or user in rooted devices, or can be disclosed through chained vulnerabilities, like unexpected access to the private storage through exposed components.\n\n\n## Recommendation\nUse `SQLCipher` or similar libraries to add encryption capabilities to SQLite. Alternatively, encrypt sensitive data using cryptographically secure algorithms before storing it in the database.\n\n\n## Example\nIn the first example, sensitive user information is stored in cleartext.\n\nIn the second and third examples, the code encrypts sensitive information before saving it to the database.\n\n\n```java\npublic void sqliteStorageUnsafe(Context ctx, String name, String password) {\n\t// BAD - sensitive information saved in cleartext.\n\tSQLiteDatabase db = ctx.openOrCreateDatabase(\"test\", Context.MODE_PRIVATE, null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name, password});\n}\n\npublic void sqliteStorageSafe(Context ctx, String name, String password) {\n\t// GOOD - sensitive information encrypted with a custom method.\n\tSQLiteDatabase db = ctx.openOrCreateDatabase(\"test\", Context.MODE_PRIVATE, null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name, encrypt(password)});\n}\n\npublic void sqlCipherStorageSafe(String name, String password, String databasePassword) {\n\t// GOOD - sensitive information saved using SQLCipher.\n\tnet.sqlcipher.database.SQLiteDatabase db = \n\t\tnet.sqlcipher.database.SQLiteDatabase.openOrCreateDatabase(\"test\", databasePassword, null);\n\tdb.execSQL(\"INSERT INTO users VALUES (?, ?)\", new String[] {name, password});\n}\n\nprivate static String encrypt(String cleartext) {\n    // Use an encryption or strong hashing algorithm in the real world.\n    // The example below just returns a SHA-256 hash.\n    MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n    byte[] hash = digest.digest(cleartext.getBytes(StandardCharsets.UTF_8));\n    String encoded = Base64.getEncoder().encodeToString(hash);\n    return encoded;\n}\n```\n\n## References\n* Android Developers: [Work with data more securely](https://developer.android.com/topic/security/data)\n* SQLCipher: [Android Application Integration](https://www.zetetic.net/sqlcipher/sqlcipher-for-android/)\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n"},"properties":{"tags":["security","external/cwe/cwe-312"],"description":"Cleartext Storage of Sensitive Information using\n              a local database on Android allows access for users with root\n              privileges or unexpected exposure from chained vulnerabilities.","id":"java/android/cleartext-storage-database","kind":"problem","name":"Cleartext storage of sensitive information using a local database on Android","precision":"medium","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/cleartext-storage-in-properties","name":"java/cleartext-storage-in-properties","shortDescription":{"text":"Cleartext storage of sensitive information using 'Properties' class"},"fullDescription":{"text":"Storing sensitive information in cleartext can expose it to an attacker."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Cleartext storage of sensitive information using 'Properties' class\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. It may be wise to encrypt information before it is put into a heap data structure (such as `Java.util.Properties`) that may be written to disk later. Objects that are serializable or marshallable should also always contain encrypted information unless you are certain that they are not ever going to be serialized.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a cookie. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are hashed before storing them.\n\n\n```java\npublic static void main(String[] args) {\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"BP@ssw0rd\".toCharArray());\n\t\tdata = credentials.getUserName() + \":\" + new String(credentials.getPassword());\n\t\n\t\t// BAD: store data in a cookie in cleartext form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n\t\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"GP@ssw0rd\".toCharArray());\n\t\tString salt = \"ThisIsMySalt\";\n\t\tMessageDigest messageDigest = MessageDigest.getInstance(\"SHA-512\");\n\t\tmessageDigest.reset();\n\t\tString credentialsToHash =\n\t\t\t\tcredentials.getUserName() + \":\" + credentials.getPassword();\n\t\tbyte[] hashedCredsAsBytes =\n\t\t\t\tmessageDigest.digest((salt+credentialsToHash).getBytes(\"UTF-8\"));\n\t\tdata = bytesToString(hashedCredsAsBytes);\n\t\t\n\t\t// GOOD: store data in a cookie in encrypted form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).\n","markdown":"# Cleartext storage of sensitive information using 'Properties' class\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. It may be wise to encrypt information before it is put into a heap data structure (such as `Java.util.Properties`) that may be written to disk later. Objects that are serializable or marshallable should also always contain encrypted information unless you are certain that they are not ever going to be serialized.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a cookie. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are hashed before storing them.\n\n\n```java\npublic static void main(String[] args) {\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"BP@ssw0rd\".toCharArray());\n\t\tdata = credentials.getUserName() + \":\" + new String(credentials.getPassword());\n\t\n\t\t// BAD: store data in a cookie in cleartext form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n\t\n\t{\n\t\tString data;\n\t\tPasswordAuthentication credentials =\n\t\t\t\tnew PasswordAuthentication(\"user\", \"GP@ssw0rd\".toCharArray());\n\t\tString salt = \"ThisIsMySalt\";\n\t\tMessageDigest messageDigest = MessageDigest.getInstance(\"SHA-512\");\n\t\tmessageDigest.reset();\n\t\tString credentialsToHash =\n\t\t\t\tcredentials.getUserName() + \":\" + credentials.getPassword();\n\t\tbyte[] hashedCredsAsBytes =\n\t\t\t\tmessageDigest.digest((salt+credentialsToHash).getBytes(\"UTF-8\"));\n\t\tdata = bytesToString(hashedCredsAsBytes);\n\t\t\n\t\t// GOOD: store data in a cookie in encrypted form\n\t\tresponse.addCookie(new Cookie(\"auth\", data));\n\t}\n}\n\n```\n\n## References\n* SEI CERT Oracle Coding Standard for Java: [SER03-J. Do not serialize unencrypted, sensitive data](https://wiki.sei.cmu.edu/confluence/display/java/SER03-J.+Do+not+serialize+unencrypted+sensitive+data).\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).\n"},"properties":{"tags":["security","external/cwe/cwe-313"],"description":"Storing sensitive information in cleartext can expose it to an attacker.","id":"java/cleartext-storage-in-properties","kind":"problem","name":"Cleartext storage of sensitive information using 'Properties' class","precision":"medium","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/partial-path-traversal","name":"java/partial-path-traversal","shortDescription":{"text":"Partial path traversal vulnerability"},"fullDescription":{"text":"A prefix used to check that a canonicalised path falls within another must be slash-terminated."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Partial path traversal vulnerability\nA common way to check that a user-supplied path `SUBDIR` falls inside a directory `DIR` is to use `getCanonicalPath()` to remove any path-traversal elements and then check that `DIR` is a prefix. However, if `DIR` is not slash-terminated, this can unexpectedly allow access to siblings of `DIR`.\n\nSee also `java/partial-path-traversal-from-remote`, which is similar to this query but only flags instances with evidence of remote exploitability.\n\n\n## Recommendation\nIf the user should only access items within a certain directory `DIR`, ensure that `DIR` is slash-terminated before checking that `DIR` is a prefix of the user-provided path, `SUBDIR`. Note, Java's `getCanonicalPath()` returns a **non**-slash-terminated path string, so a slash must be added to `DIR` if that method is used.\n\n\n## Example\nIn this example, the `if` statement checks if `parent.getCanonicalPath()` is a prefix of `dir.getCanonicalPath()`. However, `parent.getCanonicalPath()` is not slash-terminated. This means that users that supply `dir` may be also allowed to access siblings of `parent` and not just children of `parent`, which is a security issue.\n\n\n```java\npublic class PartialPathTraversalBad {\n    public void example(File dir, File parent) throws IOException {\n        if (!dir.getCanonicalPath().startsWith(parent.getCanonicalPath())) {\n            throw new IOException(\"Path traversal attempt: \" + dir.getCanonicalPath());\n        }\n    }\n}\n\n```\nIn this example, the `if` statement checks if `parent.toPath()` is a prefix of `dir.normalize()`. Because `Path#startsWith` does the correct check that `dir` is a child of `parent`, users will not be able to access siblings of `parent`, as desired.\n\n\n```java\nimport java.io.File;\n\npublic class PartialPathTraversalGood {\n    public void example(File dir, File parent) throws IOException {\n        if (!dir.toPath().normalize().startsWith(parent.toPath())) {\n            throw new IOException(\"Path traversal attempt: \" + dir.getCanonicalPath());\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Partial Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* CVE-2022-23457: [ ESAPI Vulnerability Report](https://github.com/ESAPI/esapi-java-legacy/blob/develop/documentation/GHSL-2022-008_The_OWASP_Enterprise_Security_API.md).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n","markdown":"# Partial path traversal vulnerability\nA common way to check that a user-supplied path `SUBDIR` falls inside a directory `DIR` is to use `getCanonicalPath()` to remove any path-traversal elements and then check that `DIR` is a prefix. However, if `DIR` is not slash-terminated, this can unexpectedly allow access to siblings of `DIR`.\n\nSee also `java/partial-path-traversal-from-remote`, which is similar to this query but only flags instances with evidence of remote exploitability.\n\n\n## Recommendation\nIf the user should only access items within a certain directory `DIR`, ensure that `DIR` is slash-terminated before checking that `DIR` is a prefix of the user-provided path, `SUBDIR`. Note, Java's `getCanonicalPath()` returns a **non**-slash-terminated path string, so a slash must be added to `DIR` if that method is used.\n\n\n## Example\nIn this example, the `if` statement checks if `parent.getCanonicalPath()` is a prefix of `dir.getCanonicalPath()`. However, `parent.getCanonicalPath()` is not slash-terminated. This means that users that supply `dir` may be also allowed to access siblings of `parent` and not just children of `parent`, which is a security issue.\n\n\n```java\npublic class PartialPathTraversalBad {\n    public void example(File dir, File parent) throws IOException {\n        if (!dir.getCanonicalPath().startsWith(parent.getCanonicalPath())) {\n            throw new IOException(\"Path traversal attempt: \" + dir.getCanonicalPath());\n        }\n    }\n}\n\n```\nIn this example, the `if` statement checks if `parent.toPath()` is a prefix of `dir.normalize()`. Because `Path#startsWith` does the correct check that `dir` is a child of `parent`, users will not be able to access siblings of `parent`, as desired.\n\n\n```java\nimport java.io.File;\n\npublic class PartialPathTraversalGood {\n    public void example(File dir, File parent) throws IOException {\n        if (!dir.toPath().normalize().startsWith(parent.toPath())) {\n            throw new IOException(\"Path traversal attempt: \" + dir.getCanonicalPath());\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Partial Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* CVE-2022-23457: [ ESAPI Vulnerability Report](https://github.com/ESAPI/esapi-java-legacy/blob/develop/documentation/GHSL-2022-008_The_OWASP_Enterprise_Security_API.md).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n"},"properties":{"tags":["security","external/cwe/cwe-023"],"description":"A prefix used to check that a canonicalised path falls within another must be slash-terminated.","id":"java/partial-path-traversal","kind":"problem","name":"Partial path traversal vulnerability","precision":"medium","problem.severity":"error","security-severity":"9.3"}},{"id":"java/unreachable-exit-in-loop","name":"java/unreachable-exit-in-loop","shortDescription":{"text":"Loop with unreachable exit condition"},"fullDescription":{"text":"An iteration or loop with an exit condition that cannot be reached is an indication of faulty logic and can likely lead to infinite looping."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Loop with unreachable exit condition\nLoops can contain multiple exit conditions, either directly in the loop condition or as guards around `break` or `return` statements. If an exit condition cannot be satisfied, then the code is misleading at best, and the loop might not terminate.\n\n\n## Recommendation\nWhen writing a loop that is intended to terminate, make sure that all the necessary exit conditions can be satisfied and that loop termination is clear.\n\n\n## Example\nThe following example shows a potentially infinite loop, since the inner loop condition is constantly true. Of course, the loop may or may not be infinite depending on the behavior of `shouldBreak`, but if this was intended as the only exit condition the loop should be rewritten to make this clear.\n\n\n```java\nfor (int i=0; i<10; i++) {\n    for (int j=0; i<10; j++) {\n        // do stuff\n        if (shouldBreak()) break;\n    }\n}\n\n```\nTo fix the loop the condition is corrected to check the right variable.\n\n\n```java\nfor (int i=0; i<10; i++) {\n    for (int j=0; j<10; j++) {\n        // do stuff\n        if (shouldBreak()) break;\n    }\n}\n\n```\n\n## References\n* Java Language Specification: [Blocks and Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html).\n* Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).\n","markdown":"# Loop with unreachable exit condition\nLoops can contain multiple exit conditions, either directly in the loop condition or as guards around `break` or `return` statements. If an exit condition cannot be satisfied, then the code is misleading at best, and the loop might not terminate.\n\n\n## Recommendation\nWhen writing a loop that is intended to terminate, make sure that all the necessary exit conditions can be satisfied and that loop termination is clear.\n\n\n## Example\nThe following example shows a potentially infinite loop, since the inner loop condition is constantly true. Of course, the loop may or may not be infinite depending on the behavior of `shouldBreak`, but if this was intended as the only exit condition the loop should be rewritten to make this clear.\n\n\n```java\nfor (int i=0; i<10; i++) {\n    for (int j=0; i<10; j++) {\n        // do stuff\n        if (shouldBreak()) break;\n    }\n}\n\n```\nTo fix the loop the condition is corrected to check the right variable.\n\n\n```java\nfor (int i=0; i<10; i++) {\n    for (int j=0; j<10; j++) {\n        // do stuff\n        if (shouldBreak()) break;\n    }\n}\n\n```\n\n## References\n* Java Language Specification: [Blocks and Statements](https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html).\n* Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).\n"},"properties":{"tags":["security","external/cwe/cwe-835"],"description":"An iteration or loop with an exit condition that cannot be\n              reached is an indication of faulty logic and can likely lead to infinite\n              looping.","id":"java/unreachable-exit-in-loop","kind":"problem","name":"Loop with unreachable exit condition","precision":"medium","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/insecure-basic-auth","name":"java/insecure-basic-auth","shortDescription":{"text":"Insecure basic authentication"},"fullDescription":{"text":"Basic authentication only obfuscates username/password in Base64 encoding, which can be easily recognized and reversed. Transmitting sensitive information without using HTTPS makes the data vulnerable to packet sniffing."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Insecure basic authentication\nBasic authentication only obfuscates usernames and passwords in Base64 encoding, which can be easily recognized and reversed, thus it must not be transmitted over the cleartext HTTP channel. Transmitting sensitive information without using HTTPS makes the data vulnerable to packet sniffing.\n\n\n## Recommendation\nEither use a more secure authentication mechanism like digest authentication or federated authentication, or use the HTTPS communication protocol.\n\n\n## Example\nThe following example shows two ways of using basic authentication. In the 'BAD' case, the credentials are transmitted over HTTP. In the 'GOOD' case, the credentials are transmitted over HTTPS.\n\n\n```java\npublic class InsecureBasicAuth {\n  /**\n   * Test basic authentication with Apache HTTP request.\n   */\n  public void testApacheHttpRequest(String username, String password) {\n\n    // BAD: basic authentication over HTTP\n    String url = \"http://www.example.com/rest/getuser.do?uid=abcdx\";\n\n    // GOOD: basic authentication over HTTPS\n    url = \"https://www.example.com/rest/getuser.do?uid=abcdx\";\n\n    HttpPost post = new HttpPost(url);\n    post.setHeader(\"Accept\", \"application/json\");\n    post.setHeader(\"Content-type\", \"application/json\");\n\n    String authString = username + \":\" + password;\n    byte[] authEncBytes = Base64.getEncoder().encode(authString.getBytes());\n    String authStringEnc = new String(authEncBytes);\n\n    post.addHeader(\"Authorization\", \"Basic \" + authStringEnc);\n  }\n\n  /**\n   * Test basic authentication with Java HTTP URL connection.\n   */\n  public void testHttpUrlConnection(String username, String password) {\n\n    // BAD: basic authentication over HTTP\n    String urlStr = \"http://www.example.com/rest/getuser.do?uid=abcdx\";\n\n    // GOOD: basic authentication over HTTPS\n    urlStr = \"https://www.example.com/rest/getuser.do?uid=abcdx\";\n\n    String authString = username + \":\" + password;\n    String encoding = Base64.getEncoder().encodeToString(authString.getBytes(\"UTF-8\"));\n    URL url = new URL(urlStr);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.setRequestMethod(\"POST\");\n    conn.setDoOutput(true);\n    conn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n  }\n}\n\n```\n\n## References\n* SonarSource rule: [Basic authentication should not be used](https://rules.sonarsource.com/java/tag/owasp/RSPEC-2647).\n* Acunetix: [WEB VULNERABILITIES INDEX - Basic authentication over HTTP](https://www.acunetix.com/vulnerabilities/web/basic-authentication-over-http/).\n* Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n","markdown":"# Insecure basic authentication\nBasic authentication only obfuscates usernames and passwords in Base64 encoding, which can be easily recognized and reversed, thus it must not be transmitted over the cleartext HTTP channel. Transmitting sensitive information without using HTTPS makes the data vulnerable to packet sniffing.\n\n\n## Recommendation\nEither use a more secure authentication mechanism like digest authentication or federated authentication, or use the HTTPS communication protocol.\n\n\n## Example\nThe following example shows two ways of using basic authentication. In the 'BAD' case, the credentials are transmitted over HTTP. In the 'GOOD' case, the credentials are transmitted over HTTPS.\n\n\n```java\npublic class InsecureBasicAuth {\n  /**\n   * Test basic authentication with Apache HTTP request.\n   */\n  public void testApacheHttpRequest(String username, String password) {\n\n    // BAD: basic authentication over HTTP\n    String url = \"http://www.example.com/rest/getuser.do?uid=abcdx\";\n\n    // GOOD: basic authentication over HTTPS\n    url = \"https://www.example.com/rest/getuser.do?uid=abcdx\";\n\n    HttpPost post = new HttpPost(url);\n    post.setHeader(\"Accept\", \"application/json\");\n    post.setHeader(\"Content-type\", \"application/json\");\n\n    String authString = username + \":\" + password;\n    byte[] authEncBytes = Base64.getEncoder().encode(authString.getBytes());\n    String authStringEnc = new String(authEncBytes);\n\n    post.addHeader(\"Authorization\", \"Basic \" + authStringEnc);\n  }\n\n  /**\n   * Test basic authentication with Java HTTP URL connection.\n   */\n  public void testHttpUrlConnection(String username, String password) {\n\n    // BAD: basic authentication over HTTP\n    String urlStr = \"http://www.example.com/rest/getuser.do?uid=abcdx\";\n\n    // GOOD: basic authentication over HTTPS\n    urlStr = \"https://www.example.com/rest/getuser.do?uid=abcdx\";\n\n    String authString = username + \":\" + password;\n    String encoding = Base64.getEncoder().encodeToString(authString.getBytes(\"UTF-8\"));\n    URL url = new URL(urlStr);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.setRequestMethod(\"POST\");\n    conn.setDoOutput(true);\n    conn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n  }\n}\n\n```\n\n## References\n* SonarSource rule: [Basic authentication should not be used](https://rules.sonarsource.com/java/tag/owasp/RSPEC-2647).\n* Acunetix: [WEB VULNERABILITIES INDEX - Basic authentication over HTTP](https://www.acunetix.com/vulnerabilities/web/basic-authentication-over-http/).\n* Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n"},"properties":{"tags":["security","external/cwe/cwe-522","external/cwe/cwe-319"],"description":"Basic authentication only obfuscates username/password in\n              Base64 encoding, which can be easily recognized and reversed.\n              Transmitting sensitive information without using HTTPS makes\n              the data vulnerable to packet sniffing.","id":"java/insecure-basic-auth","kind":"path-problem","name":"Insecure basic authentication","precision":"medium","problem.severity":"warning","security-severity":"8.8"}},{"id":"java/android/unsafe-android-webview-fetch","name":"java/android/unsafe-android-webview-fetch","shortDescription":{"text":"Unsafe resource fetching in Android WebView"},"fullDescription":{"text":"JavaScript rendered inside WebViews can access protected application files and web resources from any origin exposing them to attack."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unsafe resource fetching in Android WebView\nAndroid WebViews that allow externally controlled URLs to be loaded, and whose JavaScript interface is enabled, are potentially vulnerable to cross-site scripting and sensitive resource disclosure attacks.\n\nA `WebView` whose `WebSettings` object has called `setAllowFileAccessFromFileURLs(true)` or `setAllowUniversalAccessFromFileURLs(true)` must not load any untrusted web content.\n\nEnabling these settings allows malicious scripts loaded in a `file://` context to launch cross-site scripting attacks, accessing arbitrary local files including WebView cookies, session tokens, private app data or even credentials used on arbitrary web sites.\n\nThis query detects the following two scenarios:\n\n1. A vulnerability introduced by WebViews when JavaScript is enabled and remote inputs are allowed.\n1. A more severe vulnerability when \"allow cross-origin resource access\" is also enabled. This setting was deprecated in API level 30 (Android 11), but most devices are still affected, especially since some Android phones are updated slowly or no longer updated at all.\n\n## Recommendation\nOnly allow trusted web content to be displayed in WebViews when JavaScript is enabled. Disallow cross-origin resource access in WebSettings to reduce the attack surface.\n\n\n## Example\nThe following example shows both 'BAD' and 'GOOD' configurations. In the 'BAD' configuration, JavaScript and the allow access setting are enabled and URLs are loaded from externally controlled inputs. In the 'GOOD' configuration, JavaScript is disabled or only trusted web content is allowed to be loaded.\n\n\n```java\npublic class UnsafeAndroidAccess extends Activity {\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.webview);\n\n\t\t// BAD: Have both JavaScript and cross-origin resource access enabled in webview while\n\t\t// taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(R.id.my_webview);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twebSettings.setJavaScriptEnabled(true);\n\t\t\twebSettings.setAllowUniversalAccessFromFileURLs(true);\n\n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString thisUrl = getIntent().getExtras().getString(\"url\"); // dangerous remote input from  the intent's Bundle of extras\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// BAD: Have both JavaScript and cross-origin resource access enabled in webview while\n\t\t// taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(R.id.my_webview);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twebSettings.setJavaScriptEnabled(true);\n\t\t\twebSettings.setAllowUniversalAccessFromFileURLs(true);\n\n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString thisUrl = getIntent().getStringExtra(\"url\"); //dangerous remote input from intent extra\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// GOOD: Have JavaScript and cross-origin resource access disabled by default on modern Android (Jellybean+) while taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(-1);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString thisUrl = getIntent().getExtras().getString(\"url\"); // remote input\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// GOOD: Have JavaScript enabled in webview but remote user input is not allowed\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(-1);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twebSettings.setJavaScriptEnabled(true);\n\n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twv.loadUrl(\"https://www.mycorp.com\");\n\t\t}\n\t}\n}\n```\n\n## References\n* Google Help: [Fixing a File-based XSS Vulnerability](https://support.google.com/faqs/answer/7668153?hl=en)\n* OWASP: [Testing JavaScript Execution in WebViews (MSTG-PLATFORM-5)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-javascript-execution-in-webviews-mstg-platform-5)\n* OWASP: [Testing WebView Protocol Handlers (MSTG-PLATFORM-6)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-webview-protocol-handlers-mstg-platform-6)\n* Common Weakness Enumeration: [CWE-749](https://cwe.mitre.org/data/definitions/749.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n","markdown":"# Unsafe resource fetching in Android WebView\nAndroid WebViews that allow externally controlled URLs to be loaded, and whose JavaScript interface is enabled, are potentially vulnerable to cross-site scripting and sensitive resource disclosure attacks.\n\nA `WebView` whose `WebSettings` object has called `setAllowFileAccessFromFileURLs(true)` or `setAllowUniversalAccessFromFileURLs(true)` must not load any untrusted web content.\n\nEnabling these settings allows malicious scripts loaded in a `file://` context to launch cross-site scripting attacks, accessing arbitrary local files including WebView cookies, session tokens, private app data or even credentials used on arbitrary web sites.\n\nThis query detects the following two scenarios:\n\n1. A vulnerability introduced by WebViews when JavaScript is enabled and remote inputs are allowed.\n1. A more severe vulnerability when \"allow cross-origin resource access\" is also enabled. This setting was deprecated in API level 30 (Android 11), but most devices are still affected, especially since some Android phones are updated slowly or no longer updated at all.\n\n## Recommendation\nOnly allow trusted web content to be displayed in WebViews when JavaScript is enabled. Disallow cross-origin resource access in WebSettings to reduce the attack surface.\n\n\n## Example\nThe following example shows both 'BAD' and 'GOOD' configurations. In the 'BAD' configuration, JavaScript and the allow access setting are enabled and URLs are loaded from externally controlled inputs. In the 'GOOD' configuration, JavaScript is disabled or only trusted web content is allowed to be loaded.\n\n\n```java\npublic class UnsafeAndroidAccess extends Activity {\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.webview);\n\n\t\t// BAD: Have both JavaScript and cross-origin resource access enabled in webview while\n\t\t// taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(R.id.my_webview);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twebSettings.setJavaScriptEnabled(true);\n\t\t\twebSettings.setAllowUniversalAccessFromFileURLs(true);\n\n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString thisUrl = getIntent().getExtras().getString(\"url\"); // dangerous remote input from  the intent's Bundle of extras\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// BAD: Have both JavaScript and cross-origin resource access enabled in webview while\n\t\t// taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(R.id.my_webview);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twebSettings.setJavaScriptEnabled(true);\n\t\t\twebSettings.setAllowUniversalAccessFromFileURLs(true);\n\n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString thisUrl = getIntent().getStringExtra(\"url\"); //dangerous remote input from intent extra\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// GOOD: Have JavaScript and cross-origin resource access disabled by default on modern Android (Jellybean+) while taking remote user inputs\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(-1);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tString thisUrl = getIntent().getExtras().getString(\"url\"); // remote input\n\t\t\twv.loadUrl(thisUrl);\n\t\t}\n\n\t\t// GOOD: Have JavaScript enabled in webview but remote user input is not allowed\n\t\t{\n\t\t\tWebView wv = (WebView) findViewById(-1);\n\t\t\tWebSettings webSettings = wv.getSettings();\n\n\t\t\twebSettings.setJavaScriptEnabled(true);\n\n\t\t\twv.setWebViewClient(new WebViewClient() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean shouldOverrideUrlLoading(WebView view, String url) {\n\t\t\t\t\tview.loadUrl(url);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twv.loadUrl(\"https://www.mycorp.com\");\n\t\t}\n\t}\n}\n```\n\n## References\n* Google Help: [Fixing a File-based XSS Vulnerability](https://support.google.com/faqs/answer/7668153?hl=en)\n* OWASP: [Testing JavaScript Execution in WebViews (MSTG-PLATFORM-5)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-javascript-execution-in-webviews-mstg-platform-5)\n* OWASP: [Testing WebView Protocol Handlers (MSTG-PLATFORM-6)](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-webview-protocol-handlers-mstg-platform-6)\n* Common Weakness Enumeration: [CWE-749](https://cwe.mitre.org/data/definitions/749.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"},"properties":{"tags":["security","external/cwe/cwe-749","external/cwe/cwe-079"],"description":"JavaScript rendered inside WebViews can access protected\n              application files and web resources from any origin exposing them to attack.","id":"java/android/unsafe-android-webview-fetch","kind":"path-problem","name":"Unsafe resource fetching in Android WebView","precision":"medium","problem.severity":"warning","security-severity":"6.1"}},{"id":"java/sensitive-log","name":"java/sensitive-log","shortDescription":{"text":"Insertion of sensitive information into log files"},"fullDescription":{"text":"Writing sensitive information to log files can allow that information to be leaked to an attacker more easily."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Insertion of sensitive information into log files\nInformation written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information. Third-party logging utilities like Log4J and SLF4J are widely used in Java projects. When sensitive information is written to logs without properly set logging levels, it is accessible to potential attackers who can use it to gain access to file storage.\n\n\n## Recommendation\nDo not write secrets into the log files and enforce proper logging level control.\n\n\n## Example\nThe following example shows two ways of logging sensitive information. In the 'BAD' case, the credentials are simply written to a debug log. In the 'GOOD' case, the credentials are never written to debug logs.\n\n\n```java\npublic static void main(String[] args) {\n    {\n        private static final Logger logger = LogManager.getLogger(SensitiveInfoLog.class);\n\n        String password = \"Pass@0rd\";\n\n        // BAD: user password is written to debug log\n        logger.debug(\"User password is \"+password);\n    }\n\t\n    {\n        private static final Logger logger = LogManager.getLogger(SensitiveInfoLog.class);\n  \n        String password = \"Pass@0rd\";\n\n        // GOOD: user password is never written to debug log\n        logger.debug(\"User password changed\")\n    }\n}\n\n```\n\n## References\n* [OWASP Logging Guide](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n","markdown":"# Insertion of sensitive information into log files\nInformation written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information. Third-party logging utilities like Log4J and SLF4J are widely used in Java projects. When sensitive information is written to logs without properly set logging levels, it is accessible to potential attackers who can use it to gain access to file storage.\n\n\n## Recommendation\nDo not write secrets into the log files and enforce proper logging level control.\n\n\n## Example\nThe following example shows two ways of logging sensitive information. In the 'BAD' case, the credentials are simply written to a debug log. In the 'GOOD' case, the credentials are never written to debug logs.\n\n\n```java\npublic static void main(String[] args) {\n    {\n        private static final Logger logger = LogManager.getLogger(SensitiveInfoLog.class);\n\n        String password = \"Pass@0rd\";\n\n        // BAD: user password is written to debug log\n        logger.debug(\"User password is \"+password);\n    }\n\t\n    {\n        private static final Logger logger = LogManager.getLogger(SensitiveInfoLog.class);\n  \n        String password = \"Pass@0rd\";\n\n        // GOOD: user password is never written to debug log\n        logger.debug(\"User password changed\")\n    }\n}\n\n```\n\n## References\n* [OWASP Logging Guide](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"},"properties":{"tags":["security","external/cwe/cwe-532"],"description":"Writing sensitive information to log files can allow that\n              information to be leaked to an attacker more easily.","id":"java/sensitive-log","kind":"path-problem","name":"Insertion of sensitive information into log files","precision":"medium","problem.severity":"warning","security-severity":"7.5"}},{"id":"java/hardcoded-credential-api-call","name":"java/hardcoded-credential-api-call","shortDescription":{"text":"Hard-coded credential in API call"},"fullDescription":{"text":"Using a hard-coded credential in a call to a sensitive Java API may compromise security."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Hard-coded credential in API call\nIncluding unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\n\n## Example\nThe following code example connects to a database using a hard-coded user name and password:\n\n\n```java\nprivate static final String p = \"123456\"; // hard-coded credential\n\npublic static void main(String[] args) throws SQLException {\n    String url = \"jdbc:mysql://localhost/test\";\n    String u = \"admin\"; // hard-coded credential\n\n    getConn(url, u, p);\n}\n\npublic static void getConn(String url, String v, String q) throws SQLException {\n    DriverManager.getConnection(url, v, q); // sensitive call\n}\n\n```\nInstead, the user name and password could be supplied through environment variables, which can be set externally without hard-coding credentials in the source code.\n\n\n## References\n* OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n","markdown":"# Hard-coded credential in API call\nIncluding unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\n\n## Example\nThe following code example connects to a database using a hard-coded user name and password:\n\n\n```java\nprivate static final String p = \"123456\"; // hard-coded credential\n\npublic static void main(String[] args) throws SQLException {\n    String url = \"jdbc:mysql://localhost/test\";\n    String u = \"admin\"; // hard-coded credential\n\n    getConn(url, u, p);\n}\n\npublic static void getConn(String url, String v, String q) throws SQLException {\n    DriverManager.getConnection(url, v, q); // sensitive call\n}\n\n```\nInstead, the user name and password could be supplied through environment variables, which can be set externally without hard-coding credentials in the source code.\n\n\n## References\n* OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"},"properties":{"tags":["security","external/cwe/cwe-798"],"description":"Using a hard-coded credential in a call to a sensitive Java API may compromise security.","id":"java/hardcoded-credential-api-call","kind":"path-problem","name":"Hard-coded credential in API call","precision":"medium","problem.severity":"error","security-severity":"9.8"}},{"id":"java/log-injection","name":"java/log-injection","shortDescription":{"text":"Log Injection"},"fullDescription":{"text":"Building log entries from user-controlled data may allow insertion of forged log entries by malicious users."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Log Injection\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input creating the appearance of multiple log entries. This can include unescaped new-line characters, or HTML or other markup.\n\n\n## Recommendation\nUser input should be suitably sanitized before it is logged.\n\nIf the log entries are plain text then line breaks should be removed from user input, using for example `String replace(char oldChar, char newChar)` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.\n\nFor log entries that will be displayed in HTML, user input should be HTML encoded before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the first example, a username, provided by the user, is logged using `logger.warn` (from `org.slf4j.Logger`). In the first case (`/bad` endpoint), the username is logged without any sanitization. If a malicious user provides `Guest'%0AUser:'Admin` as a username parameter, the log entry will be split into two separate lines, where the first line will be `User:'Guest'` and the second one will be `User:'Admin'`.\n\n\n```java\npackage com.example.restservice;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class LogInjection {\n\n    private final Logger log = LoggerFactory.getLogger(LogInjection.class);\n\n    // /bad?username=Guest'%0AUser:'Admin\n    @GetMapping(\"/bad\")\n    public String bad(@RequestParam(value = \"username\", defaultValue = \"name\") String username) {\n        log.warn(\"User:'{}'\", username);\n        // The logging call above would result in multiple log entries as shown below:\n        // User:'Guest'\n        // User:'Admin'\n        return username;\n    }\n}\n\n\n```\nIn the second example (`/good` endpoint), `matches()` is used to ensure the user input only has alphanumeric characters. If a malicious user provides \\`Guest'%0AUser:'Admin\\` as a username parameter, the log entry will not be logged at all, preventing the injection.\n\n\n```java\npackage com.example.restservice;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class LogInjection {\n\n    private final Logger log = LoggerFactory.getLogger(LogInjection.class);\n\n    // /good?username=Guest'%0AUser:'Admin\n    @GetMapping(\"/good\")\n    public String good(@RequestParam(value = \"username\", defaultValue = \"name\") String username) {\n        // The regex check here, allows only alphanumeric characters to pass.\n        // Hence, does not result in log injection\n        if (username.matches(\"\\\\w*\")) {\n            log.warn(\"User:'{}'\", username);\n\n            return username;\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Log Injection](https://owasp.org/www-community/attacks/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n","markdown":"# Log Injection\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input creating the appearance of multiple log entries. This can include unescaped new-line characters, or HTML or other markup.\n\n\n## Recommendation\nUser input should be suitably sanitized before it is logged.\n\nIf the log entries are plain text then line breaks should be removed from user input, using for example `String replace(char oldChar, char newChar)` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.\n\nFor log entries that will be displayed in HTML, user input should be HTML encoded before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the first example, a username, provided by the user, is logged using `logger.warn` (from `org.slf4j.Logger`). In the first case (`/bad` endpoint), the username is logged without any sanitization. If a malicious user provides `Guest'%0AUser:'Admin` as a username parameter, the log entry will be split into two separate lines, where the first line will be `User:'Guest'` and the second one will be `User:'Admin'`.\n\n\n```java\npackage com.example.restservice;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class LogInjection {\n\n    private final Logger log = LoggerFactory.getLogger(LogInjection.class);\n\n    // /bad?username=Guest'%0AUser:'Admin\n    @GetMapping(\"/bad\")\n    public String bad(@RequestParam(value = \"username\", defaultValue = \"name\") String username) {\n        log.warn(\"User:'{}'\", username);\n        // The logging call above would result in multiple log entries as shown below:\n        // User:'Guest'\n        // User:'Admin'\n        return username;\n    }\n}\n\n\n```\nIn the second example (`/good` endpoint), `matches()` is used to ensure the user input only has alphanumeric characters. If a malicious user provides \\`Guest'%0AUser:'Admin\\` as a username parameter, the log entry will not be logged at all, preventing the injection.\n\n\n```java\npackage com.example.restservice;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class LogInjection {\n\n    private final Logger log = LoggerFactory.getLogger(LogInjection.class);\n\n    // /good?username=Guest'%0AUser:'Admin\n    @GetMapping(\"/good\")\n    public String good(@RequestParam(value = \"username\", defaultValue = \"name\") String username) {\n        // The regex check here, allows only alphanumeric characters to pass.\n        // Hence, does not result in log injection\n        if (username.matches(\"\\\\w*\")) {\n            log.warn(\"User:'{}'\", username);\n\n            return username;\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Log Injection](https://owasp.org/www-community/attacks/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n"},"properties":{"tags":["security","external/cwe/cwe-117"],"description":"Building log entries from user-controlled data may allow\n              insertion of forged log entries by malicious users.","id":"java/log-injection","kind":"path-problem","name":"Log Injection","precision":"medium","problem.severity":"error","security-severity":"7.8"}},{"id":"java/exec-tainted-environment","name":"java/exec-tainted-environment","shortDescription":{"text":"Building a command with an injected environment variable"},"fullDescription":{"text":"Passing environment variables containing externally controlled strings to a command line is vulnerable to malicious changes to the environment of a subprocess."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Building a command with an injected environment variable\nPassing unvalidated user input into the environment variables of a subprocess can allow an attacker to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the environment variable or its value. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable environment variables cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nIn the following (BAD) example, the environment variable `PATH` is set to the value of the user input `path` without validation.\n\n\n```java\npublic void doGet(HttpServletRequest request, HttpServletResponse response) {\n    String path = request.getParameter(\"path\");\n\n    Map<String, String> env = processBuilder.environment();\n    // BAD: path is tainted and being added to the environment\n    env.put(\"PATH\", path);\n\n    processBuilder.start();\n}\n```\nIn the following (BAD) example, an environment variable is set with a name that is derived from the user input `var` without validation.\n\n\n```java\npublic void doGet(HttpServletRequest request, HttpServletResponse response) {\n    String attr = request.getParameter(\"attribute\");\n    String value = request.getParameter(\"value\");\n\n    Map<String, String> env = processBuilder.environment();\n    // BAD: attr and value are tainted and being added to the environment\n    env.put(attr, value);\n\n    processBuilder.start();\n}\n```\nIn the following (GOOD) example, the user's input is validated before being used to set the environment variable.\n\n\n```java\nString opt = request.getParameter(\"opt\");\nString value = request.getParameter(\"value\");\n\nMap<String, String> env = processBuilder.environment();\n\n// GOOD: opt and value are checked before being added to the environment\nif (permittedJavaOptions.contains(opt) && validOption(opt, value)) {\n    env.put(opt, value);\n}\n```\nIn the following (GOOD) example, the user's input is checked and used to determine an environment variable to add.\n\n\n```java\nMap<String, String> env = builder.environment();\nString debug = request.getParameter(\"debug\");\n\n// GOOD: Checking the value and not tainting the variable added to the environment\nif (debug != null) {\n    env.put(\"PYTHONDEBUG\", \"1\");\n}\n\n```\n\n## References\n* The Java Tutorials: [Environment Variables](https://docs.oracle.com/javase/tutorial/essential/environment/env.html).\n* OWASP: [Command injection](https://owasp.org/www-community/attacks/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n* Common Weakness Enumeration: [CWE-454](https://cwe.mitre.org/data/definitions/454.html).\n","markdown":"# Building a command with an injected environment variable\nPassing unvalidated user input into the environment variables of a subprocess can allow an attacker to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the environment variable or its value. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable environment variables cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nIn the following (BAD) example, the environment variable `PATH` is set to the value of the user input `path` without validation.\n\n\n```java\npublic void doGet(HttpServletRequest request, HttpServletResponse response) {\n    String path = request.getParameter(\"path\");\n\n    Map<String, String> env = processBuilder.environment();\n    // BAD: path is tainted and being added to the environment\n    env.put(\"PATH\", path);\n\n    processBuilder.start();\n}\n```\nIn the following (BAD) example, an environment variable is set with a name that is derived from the user input `var` without validation.\n\n\n```java\npublic void doGet(HttpServletRequest request, HttpServletResponse response) {\n    String attr = request.getParameter(\"attribute\");\n    String value = request.getParameter(\"value\");\n\n    Map<String, String> env = processBuilder.environment();\n    // BAD: attr and value are tainted and being added to the environment\n    env.put(attr, value);\n\n    processBuilder.start();\n}\n```\nIn the following (GOOD) example, the user's input is validated before being used to set the environment variable.\n\n\n```java\nString opt = request.getParameter(\"opt\");\nString value = request.getParameter(\"value\");\n\nMap<String, String> env = processBuilder.environment();\n\n// GOOD: opt and value are checked before being added to the environment\nif (permittedJavaOptions.contains(opt) && validOption(opt, value)) {\n    env.put(opt, value);\n}\n```\nIn the following (GOOD) example, the user's input is checked and used to determine an environment variable to add.\n\n\n```java\nMap<String, String> env = builder.environment();\nString debug = request.getParameter(\"debug\");\n\n// GOOD: Checking the value and not tainting the variable added to the environment\nif (debug != null) {\n    env.put(\"PYTHONDEBUG\", \"1\");\n}\n\n```\n\n## References\n* The Java Tutorials: [Environment Variables](https://docs.oracle.com/javase/tutorial/essential/environment/env.html).\n* OWASP: [Command injection](https://owasp.org/www-community/attacks/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n* Common Weakness Enumeration: [CWE-454](https://cwe.mitre.org/data/definitions/454.html).\n"},"properties":{"tags":["security","external/cwe/cwe-078","external/cwe/cwe-088","external/cwe/cwe-454"],"description":"Passing environment variables containing externally controlled\n              strings to a command line is vulnerable to malicious changes to the\n              environment of a subprocess.","id":"java/exec-tainted-environment","kind":"path-problem","name":"Building a command with an injected environment variable","precision":"medium","problem.severity":"error","security-severity":"9.8"}},{"id":"java/relative-path-command","name":"java/relative-path-command","shortDescription":{"text":"Executing a command with a relative path"},"fullDescription":{"text":"Executing a command with a relative path is vulnerable to malicious changes in the PATH environment variable."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Executing a command with a relative path\nWhen a command is executed with a relative path, the runtime uses the PATH environment variable to find which executable to run. Therefore, any user who can change the PATH environment variable can cause the software to run a different, malicious executable.\n\n\n## Recommendation\nIn most cases, simply use a command that has an absolute path instead of a relative path.\n\nIn some cases, the location of the executable might be different on different installations. In such cases, consider specifying the location of key executables with some form of configuration. When using this approach, be careful that the configuration system is not itself vulnerable to malicious modifications.\n\n\n## Example\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        // BAD: relative path\n        Runtime.getRuntime().exec(\"make\");\n        \n        // GOOD: absolute path\n        Runtime.getRuntime().exec(\"/usr/bin/make\");\n\n        // GOOD: build an absolute path from known values\n        Runtime.getRuntime().exec(Paths.MAKE_PREFIX + \"/bin/make\");\n    }\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n","markdown":"# Executing a command with a relative path\nWhen a command is executed with a relative path, the runtime uses the PATH environment variable to find which executable to run. Therefore, any user who can change the PATH environment variable can cause the software to run a different, malicious executable.\n\n\n## Recommendation\nIn most cases, simply use a command that has an absolute path instead of a relative path.\n\nIn some cases, the location of the executable might be different on different installations. In such cases, consider specifying the location of key executables with some form of configuration. When using this approach, be careful that the configuration system is not itself vulnerable to malicious modifications.\n\n\n## Example\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        // BAD: relative path\n        Runtime.getRuntime().exec(\"make\");\n        \n        // GOOD: absolute path\n        Runtime.getRuntime().exec(\"/usr/bin/make\");\n\n        // GOOD: build an absolute path from known values\n        Runtime.getRuntime().exec(Paths.MAKE_PREFIX + \"/bin/make\");\n    }\n}\n```\n\n## References\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"},"properties":{"tags":["security","external/cwe/cwe-078","external/cwe/cwe-088"],"description":"Executing a command with a relative path is vulnerable to\n              malicious changes in the PATH environment variable.","id":"java/relative-path-command","kind":"problem","name":"Executing a command with a relative path","precision":"medium","problem.severity":"warning","security-severity":"5.4"}},{"id":"java/summary/lines-of-code-kotlin","name":"java/summary/lines-of-code-kotlin","shortDescription":{"text":"Total lines of Kotlin code in the database"},"fullDescription":{"text":"The total number of lines of code across all Kotlin files. This is a useful metric of the size of a database. For all Kotlin files that were seen during the build, this query counts the lines of code, excluding whitespace or comments."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","debug"],"description":"The total number of lines of code across all Kotlin files. This is a useful metric of the size of a database.\n              For all Kotlin files that were seen during the build, this query counts the lines of code, excluding whitespace\n              or comments.","id":"java/summary/lines-of-code-kotlin","kind":"metric","name":"Total lines of Kotlin code in the database"}},{"id":"java/summary/lines-of-code","name":"java/summary/lines-of-code","shortDescription":{"text":"Total lines of Java/Kotlin code in the database"},"fullDescription":{"text":"The total number of lines of code across all Java and Kotlin files. This is a useful metric of the size of a database. For all source files that were seen during the build, this query counts the lines of code, excluding whitespace or comments."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","lines-of-code","debug"],"description":"The total number of lines of code across all Java and Kotlin files. This is a useful metric of the size of a database.\n              For all source files that were seen during the build, this query counts the lines of code, excluding whitespace\n              or comments.","id":"java/summary/lines-of-code","kind":"metric","name":"Total lines of Java/Kotlin code in the database"}},{"id":"java/summary/lines-of-code-java","name":"java/summary/lines-of-code-java","shortDescription":{"text":"Total lines of Java code in the database"},"fullDescription":{"text":"The total number of lines of code across all Java files. This is a useful metric of the size of a database. For all Java files that were seen during the build, this query counts the lines of code, excluding whitespace or comments."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","debug"],"description":"The total number of lines of code across all Java files. This is a useful metric of the size of a database.\n              For all Java files that were seen during the build, this query counts the lines of code, excluding whitespace\n              or comments.","id":"java/summary/lines-of-code-java","kind":"metric","name":"Total lines of Java code in the database"}},{"id":"java/telemetry/supported-external-api-taint","name":"java/telemetry/supported-external-api-taint","shortDescription":{"text":"Supported flow steps in external libraries"},"fullDescription":{"text":"A list of 3rd party APIs detected as flow steps. Excludes test and generated code."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"A list of 3rd party APIs detected as flow steps. Excludes test and generated code.","id":"java/telemetry/supported-external-api-taint","kind":"metric","name":"Supported flow steps in external libraries"}},{"id":"java/telemetry/supported-external-api","name":"java/telemetry/supported-external-api","shortDescription":{"text":"Usage of supported APIs coming from external libraries"},"fullDescription":{"text":"A list of supported 3rd party APIs used in the codebase. Excludes test and generated code."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"A list of supported 3rd party APIs used in the codebase. Excludes test and generated code.","id":"java/telemetry/supported-external-api","kind":"metric","name":"Usage of supported APIs coming from external libraries"}},{"id":"java/telemetry/external-libs","name":"java/telemetry/external-libs","shortDescription":{"text":"External libraries"},"fullDescription":{"text":"A list of external libraries used in the code"},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"A list of external libraries used in the code","id":"java/telemetry/external-libs","kind":"metric","name":"External libraries"}},{"id":"java/telemetry/extraction-information","name":"java/telemetry/extraction-information","shortDescription":{"text":"Java extraction information"},"fullDescription":{"text":"Information about the extraction for a Java database"},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"Information about the extraction for a Java database","id":"java/telemetry/extraction-information","kind":"metric","name":"Java extraction information"}},{"id":"java/telemetry/supported-external-api-sources","name":"java/telemetry/supported-external-api-sources","shortDescription":{"text":"Supported sources in external libraries"},"fullDescription":{"text":"A list of 3rd party APIs detected as sources. Excludes test and generated code."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"A list of 3rd party APIs detected as sources. Excludes test and generated code.","id":"java/telemetry/supported-external-api-sources","kind":"metric","name":"Supported sources in external libraries"}},{"id":"java/telemetry/unsupported-external-api","name":"java/telemetry/unsupported-external-api","shortDescription":{"text":"Usage of unsupported APIs coming from external libraries"},"fullDescription":{"text":"A list of 3rd party APIs used in the codebase. Excludes test and generated code."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"A list of 3rd party APIs used in the codebase. Excludes test and generated code.","id":"java/telemetry/unsupported-external-api","kind":"metric","name":"Usage of unsupported APIs coming from external libraries"}},{"id":"java/telemetry/supported-external-api-sinks","name":"java/telemetry/supported-external-api-sinks","shortDescription":{"text":"Supported sinks in external libraries"},"fullDescription":{"text":"A list of 3rd party APIs detected as sinks. Excludes test and generated code."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"A list of 3rd party APIs detected as sinks. Excludes test and generated code.","id":"java/telemetry/supported-external-api-sinks","kind":"metric","name":"Supported sinks in external libraries"}}],"locations":[{"uri":"file:///opt/hostedtoolcache/CodeQL/2.20.4/x64/codeql/qlpacks/codeql/java-queries/1.1.13/","description":{"text":"The QL pack root directory."},"properties":{"tags":["CodeQL/LocalPackRoot"]}},{"uri":"file:///opt/hostedtoolcache/CodeQL/2.20.4/x64/codeql/qlpacks/codeql/java-queries/1.1.13/qlpack.yml","description":{"text":"The QL pack definition file."},"properties":{"tags":["CodeQL/LocalPackDefinitionFile"]}}]},{"name":"codeql/java-all","semanticVersion":"7.0.0+c524a98eb91c769cb2994b8373181c2ebd27c20f","locations":[{"uri":"file:///opt/hostedtoolcache/CodeQL/2.20.4/x64/codeql/qlpacks/codeql/java-queries/1.1.13/.codeql/libraries/codeql/java-all/7.0.0/","description":{"text":"The QL pack root directory."},"properties":{"tags":["CodeQL/LocalPackRoot"]}},{"uri":"file:///opt/hostedtoolcache/CodeQL/2.20.4/x64/codeql/qlpacks/codeql/java-queries/1.1.13/.codeql/libraries/codeql/java-all/7.0.0/qlpack.yml","description":{"text":"The QL pack definition file."},"properties":{"tags":["CodeQL/LocalPackDefinitionFile"]}}]},{"name":"codeql/threat-models","semanticVersion":"1.0.16+c524a98eb91c769cb2994b8373181c2ebd27c20f","locations":[{"uri":"file:///opt/hostedtoolcache/CodeQL/2.20.4/x64/codeql/qlpacks/codeql/java-queries/1.1.13/.codeql/libraries/codeql/threat-models/1.0.16/","description":{"text":"The QL pack root directory."},"properties":{"tags":["CodeQL/LocalPackRoot"]}},{"uri":"file:///opt/hostedtoolcache/CodeQL/2.20.4/x64/codeql/qlpacks/codeql/java-queries/1.1.13/.codeql/libraries/codeql/threat-models/1.0.16/qlpack.yml","description":{"text":"The QL pack definition file."},"properties":{"tags":["CodeQL/LocalPackDefinitionFile"]}}]}]},"invocations":[{"toolExecutionNotifications":[{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Arrays.java","uriBaseId":"%SRCROOT%","index":1}}}],"message":{"text":""},"level":"none","descriptor":{"id":"java/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/Runtime.java","uriBaseId":"%SRCROOT%","index":6}}}],"message":{"text":""},"level":"none","descriptor":{"id":"java/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/Tag.java","uriBaseId":"%SRCROOT%","index":7}}}],"message":{"text":""},"level":"none","descriptor":{"id":"java/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/Cases.java","uriBaseId":"%SRCROOT%","index":8}}}],"message":{"text":""},"level":"none","descriptor":{"id":"java/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/Case.java","uriBaseId":"%SRCROOT%","index":9}}}],"message":{"text":""},"level":"none","descriptor":{"id":"java/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Loops.java","uriBaseId":"%SRCROOT%","index":0}}}],"message":{"text":""},"level":"none","descriptor":{"id":"java/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Calls.java","uriBaseId":"%SRCROOT%","index":10}}}],"message":{"text":""},"level":"none","descriptor":{"id":"java/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/InputParser.java","uriBaseId":"%SRCROOT%","index":5}}}],"message":{"text":""},"level":"none","descriptor":{"id":"java/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/CaseContent.java","uriBaseId":"%SRCROOT%","index":2}}}],"message":{"text":""},"level":"none","descriptor":{"id":"java/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Simple.java","uriBaseId":"%SRCROOT%","index":11}}}],"message":{"text":""},"level":"none","descriptor":{"id":"java/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Tricky.java","uriBaseId":"%SRCROOT%","index":12}}}],"message":{"text":""},"level":"none","descriptor":{"id":"java/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/solutions/interpret.py","uriBaseId":"%SRCROOT%","index":13}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/setup.py","uriBaseId":"%SRCROOT%","index":14}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/bin/evaluate.py","uriBaseId":"%SRCROOT%","index":15}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/solutions/apriori.py","uriBaseId":"%SRCROOT%","index":16}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/solutions/syntaxer.py","uriBaseId":"%SRCROOT%","index":17}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/jpamb_utils/__init__.py","uriBaseId":"%SRCROOT%","index":18}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/solutions/conservative.py","uriBaseId":"%SRCROOT%","index":19}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/bin/utils.py","uriBaseId":"%SRCROOT%","index":20}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/solutions/bytecoder.py","uriBaseId":"%SRCROOT%","index":21}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/bin/build.py","uriBaseId":"%SRCROOT%","index":22}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/solutions/cheater.py","uriBaseId":"%SRCROOT%","index":23}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/bin/stats.py","uriBaseId":"%SRCROOT%","index":24}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"scripts/generate_dot.py","uriBaseId":"%SRCROOT%","index":25}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/bin/test.py","uriBaseId":"%SRCROOT%","index":26}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/Cases.java","uriBaseId":"%SRCROOT%","index":8}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/java","index":1},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/Case.java","uriBaseId":"%SRCROOT%","index":9}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/java","index":1},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/CaseContent.java","uriBaseId":"%SRCROOT%","index":2}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/java","index":1},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/InputParser.java","uriBaseId":"%SRCROOT%","index":5}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/java","index":1},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Tricky.java","uriBaseId":"%SRCROOT%","index":12}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/java","index":1},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Loops.java","uriBaseId":"%SRCROOT%","index":0}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/java","index":1},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Simple.java","uriBaseId":"%SRCROOT%","index":11}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/java","index":1},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Arrays.java","uriBaseId":"%SRCROOT%","index":1}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/java","index":1},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/Runtime.java","uriBaseId":"%SRCROOT%","index":6}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/java","index":1},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Calls.java","uriBaseId":"%SRCROOT%","index":10}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/java","index":1},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/Tag.java","uriBaseId":"%SRCROOT%","index":7}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/java","index":1},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/timer/sieve.c","uriBaseId":"%SRCROOT%","index":27}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/c","index":2},"properties":{"formattedMessage":{"text":""}}},{"message":{"text":"The manual build mode was specified.","markdown":"The manual build mode was specified."},"level":"none","timeUtc":"2025-02-08T20:34:16.705544277Z","descriptor":{"id":"cli/build-mode","index":3},"properties":{"attributes":{"buildMode":"manual"},"visibility":{"statusPage":false,"telemetry":true}}},{"message":{"text":""},"level":"none","timeUtc":"2025-02-08T20:34:10.663Z","descriptor":{"id":"codeql-action/bundle-download-telemetry","index":4},"properties":{"attributes":{"cacheDurationMs":13456.726619000001,"combinedDurationMs":3967,"compressionMethod":"zstd","streamExtraction":true,"toolsUrl":"https://github.com/github/codeql-action/releases/download/codeql-bundle-v2.20.4/codeql-bundle-linux64.tar.zst"},"visibility":{"statusPage":false,"telemetry":true}}}],"executionSuccessful":true}],"artifacts":[{"location":{"uri":"jpamb/src/main/java/jpamb/cases/Loops.java","uriBaseId":"%SRCROOT%","index":0}},{"location":{"uri":"jpamb/src/main/java/jpamb/cases/Arrays.java","uriBaseId":"%SRCROOT%","index":1}},{"location":{"uri":"jpamb/src/main/java/jpamb/utils/CaseContent.java","uriBaseId":"%SRCROOT%","index":2}},{"location":{"uri":"file:/modules/java.base/java/lang/Record.class","index":3}},{"location":{"uri":"file:/modules/java.base/java/lang/Enum.class","index":4}},{"location":{"uri":"jpamb/src/main/java/jpamb/utils/InputParser.java","uriBaseId":"%SRCROOT%","index":5}},{"location":{"uri":"jpamb/src/main/java/jpamb/Runtime.java","uriBaseId":"%SRCROOT%","index":6}},{"location":{"uri":"jpamb/src/main/java/jpamb/utils/Tag.java","uriBaseId":"%SRCROOT%","index":7}},{"location":{"uri":"jpamb/src/main/java/jpamb/utils/Cases.java","uriBaseId":"%SRCROOT%","index":8}},{"location":{"uri":"jpamb/src/main/java/jpamb/utils/Case.java","uriBaseId":"%SRCROOT%","index":9}},{"location":{"uri":"jpamb/src/main/java/jpamb/cases/Calls.java","uriBaseId":"%SRCROOT%","index":10}},{"location":{"uri":"jpamb/src/main/java/jpamb/cases/Simple.java","uriBaseId":"%SRCROOT%","index":11}},{"location":{"uri":"jpamb/src/main/java/jpamb/cases/Tricky.java","uriBaseId":"%SRCROOT%","index":12}},{"location":{"uri":"jpamb/solutions/interpret.py","uriBaseId":"%SRCROOT%","index":13}},{"location":{"uri":"jpamb/setup.py","uriBaseId":"%SRCROOT%","index":14}},{"location":{"uri":"jpamb/bin/evaluate.py","uriBaseId":"%SRCROOT%","index":15}},{"location":{"uri":"jpamb/solutions/apriori.py","uriBaseId":"%SRCROOT%","index":16}},{"location":{"uri":"jpamb/solutions/syntaxer.py","uriBaseId":"%SRCROOT%","index":17}},{"location":{"uri":"jpamb/jpamb_utils/__init__.py","uriBaseId":"%SRCROOT%","index":18}},{"location":{"uri":"jpamb/solutions/conservative.py","uriBaseId":"%SRCROOT%","index":19}},{"location":{"uri":"jpamb/bin/utils.py","uriBaseId":"%SRCROOT%","index":20}},{"location":{"uri":"jpamb/solutions/bytecoder.py","uriBaseId":"%SRCROOT%","index":21}},{"location":{"uri":"jpamb/bin/build.py","uriBaseId":"%SRCROOT%","index":22}},{"location":{"uri":"jpamb/solutions/cheater.py","uriBaseId":"%SRCROOT%","index":23}},{"location":{"uri":"jpamb/bin/stats.py","uriBaseId":"%SRCROOT%","index":24}},{"location":{"uri":"scripts/generate_dot.py","uriBaseId":"%SRCROOT%","index":25}},{"location":{"uri":"jpamb/bin/test.py","uriBaseId":"%SRCROOT%","index":26}},{"location":{"uri":"jpamb/timer/sieve.c","uriBaseId":"%SRCROOT%","index":27}}],"results":[{"ruleId":"java/constant-comparison","rule":{"id":"java/constant-comparison","index":16,"toolComponent":{"index":0}},"message":{"text":"Test is always true."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Loops.java","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":19,"startColumn":12,"endColumn":17}}}],"partialFingerprints":{"primaryLocationLineHash":"e7f021309bf796d5:1","primaryLocationStartColumnFingerprint":"7"}},{"ruleId":"java/constant-comparison","rule":{"id":"java/constant-comparison","index":16,"toolComponent":{"index":0}},"message":{"text":"Test is always true."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Loops.java","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":28,"startColumn":12,"endColumn":17}}}],"partialFingerprints":{"primaryLocationLineHash":"690ed2ed31a07ca9:1","primaryLocationStartColumnFingerprint":"7"}},{"ruleId":"java/constant-loop-condition","rule":{"id":"java/constant-loop-condition","index":22,"toolComponent":{"index":0}},"message":{"text":"[Loop](1) might not terminate, as this loop condition is constant within the loop."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Loops.java","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":19,"startColumn":12,"endColumn":17}}}],"partialFingerprints":{"primaryLocationLineHash":"e7f021309bf796d5:1","primaryLocationStartColumnFingerprint":"7"},"relatedLocations":[{"id":1,"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Loops.java","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":19,"startColumn":5,"endColumn":18}},"message":{"text":"Loop"}}]},{"ruleId":"java/constant-loop-condition","rule":{"id":"java/constant-loop-condition","index":22,"toolComponent":{"index":0}},"message":{"text":"[Loop](1) might not terminate, as this loop condition is constant within the loop."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Loops.java","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":28,"startColumn":12,"endColumn":17}}}],"partialFingerprints":{"primaryLocationLineHash":"690ed2ed31a07ca9:1","primaryLocationStartColumnFingerprint":"7"},"relatedLocations":[{"id":1,"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Loops.java","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":28,"startColumn":5,"endColumn":18}},"message":{"text":"Loop"}}]},{"ruleId":"java/dereferenced-value-is-always-null","rule":{"id":"java/dereferenced-value-is-always-null","index":29,"toolComponent":{"index":0}},"message":{"text":"Variable [array](1) is always null at this dereference."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Arrays.java","uriBaseId":"%SRCROOT%","index":1},"region":{"startLine":33,"startColumn":5,"endColumn":10}}}],"partialFingerprints":{"primaryLocationLineHash":"6cc7e97e31e46d22:1","primaryLocationStartColumnFingerprint":"0"},"relatedLocations":[{"id":1,"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Arrays.java","uriBaseId":"%SRCROOT%","index":1},"region":{"startLine":32,"startColumn":5,"endColumn":24}},"message":{"text":"array"}}]},{"ruleId":"java/dereferenced-value-is-always-null","rule":{"id":"java/dereferenced-value-is-always-null","index":29,"toolComponent":{"index":0}},"message":{"text":"Variable [array](1) is always null at this dereference."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Arrays.java","uriBaseId":"%SRCROOT%","index":1},"region":{"startLine":40,"startColumn":12,"endColumn":17}}}],"partialFingerprints":{"primaryLocationLineHash":"8c2f72e37d9f959d:1","primaryLocationStartColumnFingerprint":"7"},"relatedLocations":[{"id":1,"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Arrays.java","uriBaseId":"%SRCROOT%","index":1},"region":{"startLine":39,"startColumn":5,"endColumn":24}},"message":{"text":"array"}}]},{"ruleId":"java/dereferenced-value-may-be-null","rule":{"id":"java/dereferenced-value-may-be-null","index":30,"toolComponent":{"index":0}},"message":{"text":"Variable [array](1) may be null at this access because of [this](2) assignment."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Arrays.java","uriBaseId":"%SRCROOT%","index":1},"region":{"startLine":51,"startColumn":5,"endColumn":10}}}],"partialFingerprints":{"primaryLocationLineHash":"a205393899258cce:1","primaryLocationStartColumnFingerprint":"0"},"relatedLocations":[{"id":1,"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Arrays.java","uriBaseId":"%SRCROOT%","index":1},"region":{"startLine":47,"startColumn":5,"endColumn":24}},"message":{"text":"array"}},{"id":2,"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Arrays.java","uriBaseId":"%SRCROOT%","index":1},"region":{"startLine":47,"startColumn":9,"endColumn":23}},"message":{"text":"this"}}]},{"ruleId":"java/index-out-of-bounds","rule":{"id":"java/index-out-of-bounds","index":40,"toolComponent":{"index":0}},"message":{"text":"This array access might be out of bounds, as the index might be equal to the array length + 1."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Arrays.java","uriBaseId":"%SRCROOT%","index":1},"region":{"startLine":12,"startColumn":5,"endColumn":13}}}],"partialFingerprints":{"primaryLocationLineHash":"801148fe3411a282:1","primaryLocationStartColumnFingerprint":"0"}},{"ruleId":"java/index-out-of-bounds","rule":{"id":"java/index-out-of-bounds","index":40,"toolComponent":{"index":0}},"message":{"text":"This array access might be out of bounds, as the index might be equal to the array length."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/cases/Arrays.java","uriBaseId":"%SRCROOT%","index":1},"region":{"startLine":51,"startColumn":5,"endColumn":13}}}],"partialFingerprints":{"primaryLocationLineHash":"a205393899258cce:1","primaryLocationStartColumnFingerprint":"0"}},{"ruleId":"java/missing-override-annotation","rule":{"id":"java/missing-override-annotation","index":55,"toolComponent":{"index":0}},"message":{"text":"This method overrides [Record.toString](1); it is advisable to add an Override annotation."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/CaseContent.java","uriBaseId":"%SRCROOT%","index":2},"region":{"startLine":14,"startColumn":17,"endColumn":25}}}],"partialFingerprints":{"primaryLocationLineHash":"10f3c42ead12ed74:1","primaryLocationStartColumnFingerprint":"14"},"relatedLocations":[{"id":1,"physicalLocation":{"artifactLocation":{"uri":"file:/modules/java.base/java/lang/Record.class","index":3}},"message":{"text":"Record.toString"}}]},{"ruleId":"java/missing-override-annotation","rule":{"id":"java/missing-override-annotation","index":55,"toolComponent":{"index":0}},"message":{"text":"This method overrides [Enum<ResultType>.toString](1); it is advisable to add an Override annotation."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/CaseContent.java","uriBaseId":"%SRCROOT%","index":2},"region":{"startLine":73,"startColumn":19,"endColumn":27}}}],"partialFingerprints":{"primaryLocationLineHash":"d6504f434129b7ac:1","primaryLocationStartColumnFingerprint":"14"},"relatedLocations":[{"id":1,"physicalLocation":{"artifactLocation":{"uri":"file:/modules/java.base/java/lang/Enum.class","index":4}},"message":{"text":"Enum<ResultType>.toString"}}]},{"ruleId":"java/uncaught-number-format-exception","rule":{"id":"java/uncaught-number-format-exception","index":78,"toolComponent":{"index":0}},"message":{"text":"Potential uncaught 'java.lang.NumberFormatException'."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/InputParser.java","uriBaseId":"%SRCROOT%","index":5},"region":{"startLine":48,"startColumn":19,"endColumn":49}}}],"partialFingerprints":{"primaryLocationLineHash":"d0143d710be8ff3b:1","primaryLocationStartColumnFingerprint":"12"}},{"ruleId":"java/uncaught-number-format-exception","rule":{"id":"java/uncaught-number-format-exception","index":78,"toolComponent":{"index":0}},"message":{"text":"Potential uncaught 'java.lang.NumberFormatException'."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/InputParser.java","uriBaseId":"%SRCROOT%","index":5},"region":{"startLine":89,"startColumn":15,"endColumn":45}}}],"partialFingerprints":{"primaryLocationLineHash":"80039eba6bdd9266:1","primaryLocationStartColumnFingerprint":"10"}},{"ruleId":"java/uncaught-number-format-exception","rule":{"id":"java/uncaught-number-format-exception","index":78,"toolComponent":{"index":0}},"message":{"text":"Potential uncaught 'java.lang.NumberFormatException'."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"jpamb/src/main/java/jpamb/utils/InputParser.java","uriBaseId":"%SRCROOT%","index":5},"region":{"startLine":96,"startColumn":17,"endColumn":47}}}],"partialFingerprints":{"primaryLocationLineHash":"6e4f1e6c6fe806d0:1","primaryLocationStartColumnFingerprint":"10"}}],"columnKind":"utf16CodeUnits","properties":{"semmle.formatSpecifier":"sarif-latest","metricResults":[{"rule":{"id":"java/summary/lines-of-code-kotlin","index":227,"toolComponent":{"index":0}},"ruleId":"java/summary/lines-of-code-kotlin","value":0},{"rule":{"id":"java/summary/lines-of-code","index":228,"toolComponent":{"index":0}},"ruleId":"java/summary/lines-of-code","value":719,"baseline":719},{"rule":{"id":"java/summary/lines-of-code-java","index":229,"toolComponent":{"index":0}},"ruleId":"java/summary/lines-of-code-java","value":719},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":17,"message":{"text":"java.lang.String#equals(Object)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":10,"message":{"text":"java.lang.StringBuilder#append(String)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":8,"message":{"text":"java.lang.RuntimeException#RuntimeException(String)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":7,"message":{"text":"java.util.List#add(Object)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":6,"message":{"text":"java.util.ArrayList#add(Object)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":5,"message":{"text":"java.lang.String#charAt(int)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":5,"message":{"text":"java.util.regex.Matcher#group(int)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":3,"message":{"text":"java.lang.Integer#parseInt(String)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":2,"message":{"text":"java.util.regex.Pattern#compile(String)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":2,"message":{"text":"java.lang.String#join(CharSequence,Iterable)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":2,"message":{"text":"java.util.Collection#stream()"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":2,"message":{"text":"java.util.ArrayList#get(int)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":2,"message":{"text":"java.lang.reflect.Method#getAnnotation(Class)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":2,"message":{"text":"java.util.stream.Stream#toList()"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":2,"message":{"text":"java.util.regex.Pattern#matcher(CharSequence)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":2,"message":{"text":"java.io.PrintStream#printf(String,Object\\[\\])"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.lang.reflect.Method#getName()"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.util.Scanner#findWithinHorizon(String,int)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.util.Scanner#useDelimiter(String)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.util.Scanner#Scanner(String)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.lang.reflect.InvocationTargetException#getCause()"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.util.stream.Stream#map(Function)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.lang.reflect.Method#getParameterTypes()"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.util.Arrays#asList(Object\\[\\])"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.util.stream.Stream#of(Object\\[\\])"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.lang.StringBuilder#toString()"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.util.List#of(Object,Object,Object,Object,Object)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.util.List#toArray(Object\\[\\])"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.lang.String#substring(int)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.util.stream.Stream#flatMap(Function)"}},{"rule":{"id":"java/telemetry/supported-external-api-taint","index":230,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-taint","value":1,"message":{"text":"java.util.ArrayList#toArray()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":17,"message":{"text":"java.lang.String#equals(Object)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":10,"message":{"text":"java.lang.StringBuilder#append(String)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":8,"message":{"text":"java.lang.RuntimeException#RuntimeException(String)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":8,"message":{"text":"java.lang.Object#equals(Object)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":7,"message":{"text":"java.util.List#add(Object)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":6,"message":{"text":"java.util.ArrayList#add(Object)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":6,"message":{"text":"java.lang.String#matches(String)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":5,"message":{"text":"java.lang.String#charAt(int)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":5,"message":{"text":"java.util.regex.Matcher#group(int)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":4,"message":{"text":"java.util.ArrayList#size()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":3,"message":{"text":"java.lang.Integer#parseInt(String)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.util.ArrayList#get(int)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.io.PrintStream#println(Object)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.lang.Enum#Enum(String,int)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.lang.String#join(CharSequence,Iterable)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.util.Collection#stream()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.io.PrintStream#printf(String,Object\\[\\])"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.lang.reflect.Method#getAnnotation(Class)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.lang.reflect.Modifier#isStatic(int)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.lang.reflect.Method#getModifiers()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.util.stream.Stream#toList()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.util.regex.Matcher#find()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.util.regex.Pattern#matcher(CharSequence)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":2,"message":{"text":"java.util.regex.Pattern#compile(String)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.stream.Stream#flatMap(Function)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.stream.Stream#of(Object\\[\\])"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.ArrayList#toArray()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.Class#getMethods()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.Arrays#toString(Object\\[\\])"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.Arrays#toString(int\\[\\])"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.Arrays#asList(Object\\[\\])"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.Scanner#findWithinHorizon(String,int)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.Scanner#hasNext()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.Scanner#useDelimiter(String)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.Scanner#Scanner(String)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.reflect.InvocationTargetException#getCause()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.Class#getMethod(String,Class\\[\\])"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.Class#getName()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.reflect.Method#invoke(Object,Object\\[\\])"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.reflect.Method#getParameterTypes()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.reflect.Method#getReturnType()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.stream.Stream#map(Function)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.reflect.Method#getName()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.String#substring(int)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.StringBuilder#toString()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.Class#toString()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.String#length()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.reflect.Method#getDeclaringClass()"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.List#of(Object,Object,Object,Object,Object)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.lang.Class#forName(String)"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.List#toArray(Object\\[\\])"}},{"rule":{"id":"java/telemetry/supported-external-api","index":231,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api","value":1,"message":{"text":"java.util.List#size()"}},{"rule":{"id":"java/telemetry/external-libs","index":232,"toolComponent":{"index":0}},"ruleId":"java/telemetry/external-libs","value":134,"message":{"text":"rt.jar"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":1,"message":{"text":"Number of diagnostics from CodeQL Java extractor with severity 2"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":938,"message":{"text":"Number of files with extension class"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":11,"message":{"text":"Number of files with extension java"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":1,"message":{"text":"Number of files with extension xml"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":1,"message":{"text":"Annotation processors enabled: true"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":1,"message":{"text":"Used annotation processor: lombok.launch.AnnotationProcessorHider$AnnotationProcessor"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":1,"message":{"text":"Used annotation processor: lombok.launch.AnnotationProcessorHider$ClaimingProcessor"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":1,"message":{"text":"Total number of diagnostics from CodeQL Java extractor"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":719,"message":{"text":"Number of lines of code with extension java"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":75,"message":{"text":"Number of lines of code with extension xml"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":842,"message":{"text":"Total number of lines with extension java"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":75,"message":{"text":"Total number of lines with extension xml"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":951,"message":{"text":"Number of files"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":917,"message":{"text":"Total number of lines"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":794,"message":{"text":"Number of lines of code"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":225,"message":{"text":"Number of calls with call target"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":1543,"message":{"text":"Number of expressions with known type"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":0,"message":{"text":"Number of expressions with unknown type"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":0,"message":{"text":"Number of calls with missing call target"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":100,"message":{"text":"Percentage of calls with call target"}},{"rule":{"id":"java/telemetry/extraction-information","index":233,"toolComponent":{"index":0}},"ruleId":"java/telemetry/extraction-information","value":100,"message":{"text":"Percentage of expressions with known type"}},{"rule":{"id":"java/telemetry/unsupported-external-api","index":235,"toolComponent":{"index":0}},"ruleId":"java/telemetry/unsupported-external-api","value":1,"message":{"text":"java.lang.Object#toString()"}},{"rule":{"id":"java/telemetry/supported-external-api-sinks","index":236,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-sinks","value":6,"message":{"text":"java.lang.String#matches(String)"}},{"rule":{"id":"java/telemetry/supported-external-api-sinks","index":236,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-sinks","value":2,"message":{"text":"java.io.PrintStream#println(Object)"}},{"rule":{"id":"java/telemetry/supported-external-api-sinks","index":236,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-sinks","value":2,"message":{"text":"java.util.regex.Pattern#matcher(CharSequence)"}},{"rule":{"id":"java/telemetry/supported-external-api-sinks","index":236,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-sinks","value":2,"message":{"text":"java.util.regex.Pattern#compile(String)"}},{"rule":{"id":"java/telemetry/supported-external-api-sinks","index":236,"toolComponent":{"index":0}},"ruleId":"java/telemetry/supported-external-api-sinks","value":2,"message":{"text":"java.io.PrintStream#printf(String,Object\\[\\])"}}],"codeqlConfigSummary":{"disableDefaultQueries":false,"queries":[{"type":"builtinSuite","uses":"security-and-quality"}]},"jobRunUuid":"72fe4893-ceff-4e8d-8105-a022c3a3578a"}}]}